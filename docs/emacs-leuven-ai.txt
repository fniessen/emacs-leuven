# Hey Emacs, this is a -*- org -*- file ...
#+TITLE:     Emacs-Leuven-AI
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:  emacs, dotfile, config
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:2
#+EXCLUDE_TAGS: noexport

#+PROPERTY:  header-args :eval never :padline yes :tangle ../lisp/emacs-leuven-ai.el

#+SETUPFILE: ~/org/html-theme-readtheorg.setup

#+LINK: GitHub https://github.com/
#+LINK: YouTube https://www.youtube.com/watch?v=

* Tasks

** TODO Research ChatGPT integration with Emacs

- [ ] Test c3po integration (recommended)
- [ ] Evaluate org-ai package
- [ ] Review CodeGPT capabilities
- [ ] Explore [[GitHub:ai-boost/awesome-prompts][Awesome Prompts Collection]]

References:
- [[YouTube:H8jvhz0CGzU][Boost your Emacs productivity with ChatGPT and Copilot]]
- https://www.armindarvish.com/post/use_emacs_as_a_chatgpt_client/

** Sort out

;; Backend Claude
(gptel-make-anthropic "Claude"
  :stream t
  :key (getenv "ANTHROPIC_API_KEY"))

(gptel-make-tool "web_search"
  :description "Effectue une recherche web"
  :function (lambda (query) (my-web-search-function query)))

Les raccourcis associés incluent :
SPC $ g g : Démarrer une session GPTel.
SPC $ g s : Envoyer un message.
SPC $ g m : Ouvrir le menu transient.

* Introduction

#+begin_src emacs-lisp
;;; emacs-leuven-ai.el --- GPTel & org-ai Integration  -*- lexical-binding: t -*-

;; Author: Fabrice Niessen
;; Keywords: tools, ai, convenience
;; URL: https://...
;; Version: 0.1

;;; Commentary:

;; Provides helpers for GPTel and org-ai.

;;; Code:

(require 'subr-x)  ;; string-trim, string-empty-p, etc.
#+end_src

** Helper functions

*** boost--try-require

#+begin_src emacs-lisp
;; Require a feature/library if available; if not, fail silently.
(defun boost--try-require (feature)
  "Try to (require FEATURE) silently.
Return t on success, nil on failure. If `init-file-debug' is non-nil,
emit a warning when the feature can't be loaded."
  (if (require feature nil 'noerror)
      t
    (when (bound-and-true-p init-file-debug)
      (display-warning 'boost
                       (format "Cannot load `%s'" feature)
                       :warning))
    nil))
#+end_src

*** boost--set-key-if-free

#+begin_src emacs-lisp
(defun boost--set-key-if-free (keymap key command &optional scope)
  "Bind KEY to COMMAND in KEYMAP only if KEY is unbound.
KEYMAP may be the map itself or a symbol naming it.
If already bound, emit a warning mentioning SCOPE (string)."
  (let* ((map (if (keymapp keymap)
                  keymap
                (when (and (symbolp keymap) (boundp keymap))
                  (symbol-value keymap))))
         (existing-binding (and map (lookup-key map key t))))
    (cond
     ((not map)
      (display-warning 'boost "Keymap not available (yet)" :warning))
     ((or (null existing-binding) (numberp existing-binding))
      (define-key map key command))
     (t
      (when init-file-debug
        (display-warning 'boost
                         (format "Keyboard shortcut %s conflicts with an existing one%s!"
                                 (key-description key)
                                 (if scope (format " in %s" scope) ""))
                         :warning))))))
#+end_src

* Integrating AI tools into Emacs

** OpenAI API key loading

#+begin_src emacs-lisp
;; Set OpenAI API key.
(defvar boost-openai-api-key nil
  "OpenAI API key from env or ~/.openai_api_key; nil if unavailable.")

(defun boost--load-openai-api-key ()
  "Retourne la clé OpenAI ou affiche un warning si absente."
  (let* ((api-key (or (getenv "OPENAI_API_KEY")
                      (let ((f (expand-file-name "~/.openai_api_key")))
                        (when (file-exists-p f)
                          (with-temp-buffer
                            (insert-file-contents f)
                            (buffer-string))))))
         (trimmed-api-key (and (stringp api-key) (string-trim api-key))))
    (cond
     ((and (stringp trimmed-api-key) (not (string-empty-p trimmed-api-key)))
      (message "[OpenAI API key loaded]")
      trimmed-api-key)
     (t
      (when init-file-debug
        (display-warning 'boost "No valid OpenAI API key found!" :warning))
      nil))))

(setq boost-openai-api-key (boost--load-openai-api-key))
#+end_src

* GPTel

Useful functions:
- gptel-send (or C-c RET) :: Send a query (buffer up to point, or active region)
  to the LLM.  as prompt to the AI and insert the result below.
  + Prefix with ~C-u~ to adjust the transient menu for fine-tuning
    LLM and input/output options -- model, backend, temperature, and more.
- gptel :: Open a dedicated chat buffer.
  - With a prefix (C-u M-x gptel), open a second dedicated chat buffer.
- gptel-rewrite :: Rewrite or refactor the selected region, ideal for polishing code or prose.
- gptel-menu :: Direct access to menu.
- gptel-add :: Add context (DWIM) to the request (region, buffer or file).
- gptel-add-file :: Include a file (text or media) into your request. Enable
  ~gptel-track-media~ to seamlessly include media across all queries.
- gptel-org-set-properties :: Define Org-mode properties for granular,
  section-specific configurations.
- gptel-org-set-topic :: Limit context to an Org section.
- gptel-make-preset ::
- gptel-make-tool ::

** Base configuration

*** GPTel core settings

#+begin_src emacs-lisp
;; Load gptel.
(when (boost--try-require 'gptel)

  ;; Set OpenAI API key.
  (when (bound-and-true-p boost-openai-api-key)
    (setq gptel-api-key boost-openai-api-key))

  (setq gptel-model 'gpt-5)

  ;; Set logging level to info.
  (setq gptel-log-level 'info)

  ;; Enable media tracking.
  (setq gptel-track-media t)

  ;; Controls randomness (lower = more deterministic).
  (setq gptel-temperature 0.7)

  ;; Set default mode for response buffer.
  (setq gptel-default-mode 'org-mode)

  ;; Enable GPTel's expert/power-user commands.
  (setq gptel-expert-commands t)
#+end_src

*** Prompt / response formatting (Org mode style)

#+begin_src emacs-lisp
  (defgroup boost-gptel nil
    "Tweaks GPTel."
    :group 'applications
    :prefix "boost-gptel-")

  (defcustom boost-gptel-prompt-prefix "** --- User prompt ---\n\n"
    "Prompt prefix inserted before user text in GPTel Org buffers."
    :type 'string
    :group 'boost-gptel)

  (defcustom boost-gptel-response-prefix "** --- AI response ---\n\n"
    "Response prefix inserted before AI output in GPTel Org buffers."
    :type 'string
    :group 'boost-gptel)

  ;; Update or create the org-mode entries (no duplicates).
  (let ((cell (assq 'org-mode gptel-prompt-prefix-alist)))
    (if cell
        (setcdr cell boost-gptel-prompt-prefix)
      (push (cons 'org-mode boost-gptel-prompt-prefix)
            gptel-prompt-prefix-alist)))

  (let ((cell (assq 'org-mode gptel-response-prefix-alist)))
    (if cell
        (setcdr cell boost-gptel-response-prefix)
      (push (cons 'org-mode boost-gptel-response-prefix)
            gptel-response-prefix-alist)))
#+end_src

*** Post-response hooks

#+begin_src emacs-lisp :tangle no
  ;; Add auto-scrolling after GPTel stream ends.
  (when (fboundp 'gptel-auto-scroll)
    (add-hook 'gptel-post-stream-hook #'gptel-auto-scroll))

  ;; Automatically move cursor to end of response.
  (when (fboundp 'gptel-end-of-response)
    (add-hook 'gptel-post-response-functions #'gptel-end-of-response))
#+end_src

#+begin_src emacs-lisp :tangle no
  ;; Auto-formatage des réponses
  (add-hook 'gptel-post-response-hook
            (lambda (process response)
              (when (eq major-mode 'gptel-mode)
                (fill-paragraph))))
#+end_src

** System prompts (directives)

*************** TODO Add quick selection key/menu (like in Karthink / c3po demos)
[[YouTube:yAL0cw1ePqw]] at 05:35
(Also in demo of Karthink, see [[YouTube:bsRnh_brggM]])
*************** END

#+begin_src emacs-lisp
(defcustom boost-gptel-directives-directory
  (expand-file-name "~/ai-prompts/")
  "Répertoire racine contenant des fichiers .txt pour les directives GPTel (recurse)."
  :type 'directory
  :group 'boost-gptel)

(defun boost--gptel-read-directive-file (name directive-file)
  "Read DIRECTIVE-FILE and set NAME entry in `gptel-directives' as a proper alist cell.
Return the directive content, or nil on failure."
  (when (file-readable-p directive-file)
    (with-temp-buffer
      (insert-file-contents directive-file)
      (let* ((content (string-trim (buffer-string)))
             (cell    (assoc name gptel-directives)))
        (if cell
            ;; Update existing (NAME . CONTENT).
            (setcdr cell content)
          ;; Append new cell to the end.
          (setq gptel-directives
                (append gptel-directives (list (cons name content)))))
        content))))

(defun boost--gptel-read-directives-from-directory (dir)
  "Populate `gptel-directives` from all .txt files under DIR (recursively),
sorted in ascending order by filename.
Existing entries with the same NAME are overwritten."
  (setq gptel-directives nil)           ; Reset old entries.
  ;; Now iterate.
  (dolist (f (directory-files-recursively (expand-file-name dir) "\\.txt\\'"))
    (condition-case err
        (let ((name (intern (file-name-base f))))
          (boost--gptel-read-directive-file name f))
      (error
       (display-warning 'boost
                        (format "[Failed to read directive %s: %s]"
                                f (error-message-string err))
                        :warning))))
  gptel-directives)

;; Load directives from the specified directory.
(if (file-directory-p boost-gptel-directives-directory)
    (condition-case err
        (boost--gptel-read-directives-from-directory boost-gptel-directives-directory)
      (error (message "[Error reading directives: %s]" (error-message-string err))))
  (message "[Directory %s does not exist.]" boost-gptel-directives-directory))
#+end_src

** GPTel presets

How to use them: =C-u M-x gptel-send=.

- Optimized for coding tasks, such as writing, refactoring, or explaining code.
- Designed for proofreading and improving text, such as fixing spelling,
  grammar, or style.
- A versatile preset for general conversations or ad-hoc queries with an LLM.
- Tailored for per-project workflows, such as analyzing code or documentation in
  a specific project directory.

*** Overview table

| Preset        | Primary Usage                | Suggested Backend | Recommended Model (2026)        | Temp. |
|---------------+------------------------------+-------------------+---------------------------------+-------|
| coding        | Code, refactor, debug        | OpenAI / Claude   | gpt-5.2-codex / claude-opus-4.6 |   0.7 |
| proofreading  | Text correction              | Claude            | claude-sonnet-4.5               |   0.7 |
| general-chat  | Quick questions              | OpenAI            | gpt-4o-mini / o1-mini           |   0.9 |
| project-agent | Project context / dir-locals | Claude            | claude-opus-4.6                 |   0.7 |

*** Preset Definitions

**** Coding

#+begin_src emacs-lisp
  ;; Coding preset - optimized for serious programming work.
  (gptel-make-preset 'coding
    :description "High-precision coding assistant with strong reasoning"
    :backend "ChatGPT"
    :model 'gpt-5
    :system
    "You are an expert programming assistant. Provide high-quality,
precise, well-structured and well-commented code solutions,
refactorings, and clear explanations. Ensure correctness, clarity, and
best practices in every response."
    :tools '("read_buffer" "modify_buffer")
    :temperature 0.7)
#+end_src

**** Proofreading

#+begin_src emacs-lisp
  ;; Proofreading / editing preset.
  (gptel-make-preset 'proofreading
    :description "Professional text polishing and correction"
    :backend "Claude"
    :model 'claude-sonnet-4-5-20250929   ;; Adapt to current best Sonnet.
    :system
    "You are a professional proofreader. Correct spelling and grammar,
improve clarity, style, structure, and readability, and rewrite
sentences when necessary to produce clear, polished, and
well-structured text."
    :tools '("read_buffer" "spell_check" "grammar_check")
    :temperature 0.7)
#+end_src

**** General-chat

#+begin_src emacs-lisp
  ;; Fast general-purpose chat.
  (gptel-make-preset 'general-chat
    :description "Fast, general-purpose conversations"
    :backend "ChatGPT"
    :model 'gpt-5-mini
    :system
    "You are a helpful assistant providing clear and concise answers to
a wide range of questions."
    :temperature 0.9)
#+end_src

**** Project-agent

#+begin_src emacs-lisp
  ;; Project-specific preset (good for .dir-locals.el)
  (gptel-make-preset 'project-agent
    :description "Project-aware assistant using codebase context"
    :backend "Claude"
    :model 'claude-opus-4-5-20251101
    :system
    "You are an AI assistant for a software project. Provide insights
based on the project's code and documentation."
    :tools '("read_buffer" "lsp_context")
    :temperature 0.7)
#+end_src

** Custom commands

*** Chat & Org integration

**** boost-gptel-chat-buffer

#+begin_src emacs-lisp
  (defun boost-gptel-chat-buffer ()
    "Switch to the GPTel chat buffer, creating it if it doesn't exist."
    (interactive)
    (let ((buffer-name "*ChatGPT*"))
      (if (get-buffer buffer-name)
          (pop-to-buffer buffer-name)
        (progn
          (call-interactively 'gptel)))))

  ;; (defun boost-gptel-chat-buffer (&optional arg)
  ;;   "Switch to the GPTel chat buffer.
  ;; Without prefix ARG, jump to `*ChatGPT*` creating it if needed (no prompt).
  ;; With C-u prefix, defer to `gptel`'s usual interactive flow (with prompts)."
  ;;   (interactive "P")
  ;;   (let ((buffer-name "*ChatGPT*"))
  ;;     (if arg
  ;;         ;; C-u -> keep original prompting/confirmation behavior.
  ;;         (call-interactively #'gptel)
  ;;       ;; No prefix -> reuse or create *ChatGPT* without prompting.
  ;;       (let ((buf (get-buffer buffer-name)))
  ;;         (if buf
  ;;             (pop-to-buffer buf)
  ;;           (funcall #'gptel buffer-name))))))
#+end_src

**** boost-gptel-org-send-to-chatgpt (Org subtree or region → *ChatGPT* buffer)

#+begin_src emacs-lisp
;;;###autoload
  (defun boost-gptel-org-send-to-chatgpt ()
    "Send selected region or Org subtree to the *ChatGPT* buffer.
    If a region is selected, send its text; otherwise, send the content of the Org subtree.
    Displays the response in the *ChatGPT* buffer."
    (interactive)

    ;; Validate context.
    (unless (derived-mode-p 'org-mode)
      (user-error "[This command works in Org buffers only]"))
    (unless (or (use-region-p) (org-at-heading-p))
      (user-error "[Place point on an Org heading or select a region]"))

    ;; Extract text.
    (let ((text (if (use-region-p)
                    (buffer-substring-no-properties (region-beginning) (region-end))
                  (save-excursion
                    (org-back-to-heading t)
                    (let ((beg (point)))
                      (org-end-of-subtree t)
                      (buffer-substring-no-properties beg (point)))))))

      ;; Prepare output buffer.
      (let ((buffer (get-buffer-create "*ChatGPT*")))
        (with-current-buffer buffer
          (goto-char (point-max))
          (insert (format-time-string
                   "\n\n* -------------------- GPT Session [%Y-%m-%d %H:%M] --------------------")
                  "\n\n" boost-gptel-prompt-prefix
                  text
                  "\n\n" boost-gptel-response-prefix)
          (goto-char (point-max)))

        ;; Send to GPTel with error handling.
        (condition-case err
            (gptel-request text :buffer buffer)
          (error (message "[GPTel error: %s]"
                          (error-message-string err))))

        ;; Display the buffer and provide user feedback.
        (pop-to-buffer buffer)
        (message "[GPTel: Prompt sent...]"))))
#+end_src

*** Git commit messages

**** Commit message

#+begin_src emacs-lisp
;; Commit-prompt file customization.
(defcustom boost-gptel-commit-prompt-file
  (expand-file-name "write-commit-message.txt"
                    boost-gptel-directives-directory)
  "System prompt file for commit-message generation."
  :type 'file :group 'boost-gptel)

;;;###autoload
  (defun boost-gptel-write-commit-message ()
    "Generate a Git commit message from the current diff region or buffer.
The result is shown in *Commit Message* and copied to the kill ring.
If ~/ai-prompts/write-commit-message.txt exists, use its contents as the system prompt."
    (interactive)
    (unless (or (use-region-p) (> (buffer-size) 0))
      (user-error "[No content to analyze]"))
    (let* ((prompt-file boost-gptel-commit-prompt-file)
           (default-prompt
            "Write a concise commit message (imperative mood, ≤72 char subject line) for this diff:\n\n")
           (system-prompt
            (if (file-readable-p prompt-file)
                (with-temp-buffer
                  (insert-file-contents prompt-file)
                  (buffer-string))
              default-prompt))
           (diff-text
            (if (use-region-p)
                (buffer-substring-no-properties (region-beginning) (region-end))
              (buffer-substring-no-properties (point-min) (point-max)))))
      ;; Notify user that the process has started.
      (message "[Writing commit message...]")
      ;; Create and clear the buffer initially.
      (with-current-buffer (get-buffer-create "*Commit Message*")
        (erase-buffer))
      ;; Send request without menu.
      (gptel-request diff-text
        :system system-prompt
        :callback (lambda (response info)
                    (if (stringp response)
                        (let ((output-buffer (get-buffer-create "*Commit Message*")))
                                        ; Create a new reference to the buffer
                                        ; to avoid closure dependency.
                          (with-current-buffer output-buffer
                            (erase-buffer)
                            (let ((msg (string-trim response)))
                              ;; Strip ``` fences if present.
                              (setq msg (replace-regexp-in-string "\\````[^\n]*\n?" "" msg))
                              (setq msg (replace-regexp-in-string "\n?```\\'" "" msg))
                              ;; Optional: convert backticks-quotes.
                              (setq msg (replace-regexp-in-string "`" "'" msg))
                              (kill-new msg) ; Add to kill ring.
                              (insert msg)
                              (message "[Commit message copied to kill ring.]")))
                          (display-buffer output-buffer
                           '((display-buffer-reuse-window display-buffer-pop-up-window)
                             (inhibit-same-window . t))))
                      (error "[Failed to generate commit message: %s]"
                             (plist-get info :status)))))))
#+end_src

**** gptel-commit (optional package)

#+begin_src emacs-lisp :tangle no
  (boost--try-require 'gptel-commit)
#+end_src

*** Code tools (Emacs Lisp)

**** Common

#+begin_src emacs-lisp
  (defun boost--extract-defun-source ()
    "Retourne le code de la defun courante ou signale une erreur."
    (save-excursion
      (unless (ignore-errors (beginning-of-defun 1))
        (error "[No function found at point]"))
      (let ((beg (point)))
        (end-of-defun)
        (buffer-substring-no-properties beg (point)))))
#+end_src

**** Unit tests

#+begin_src emacs-lisp
  (defun boost-gptel-generate-contextual-test ()
    "Generate a unit test for the current function by sending its source code to GPTel."
    (interactive)
    (let* ((function-source (boost--extract-defun-source))
           (prompt (format "Generate a unit test for the following function:\n\n%s"
                           function-source)))
      (gptel-request prompt)))
#+end_src

**** Refactoring

#+begin_src emacs-lisp
  (defun boost-gptel-refactor-function ()
    "Refactor the current function with suggestions from GPTel."
    (interactive)
    (let* ((function-source (boost--extract-defun-source))
           (prompt (format "Suggest a refactored, cleaner version of this function:

%s

Provide the refactored code and explain the improvements." function-source)))
      (gptel-request prompt)))
#+end_src

**** Documentation

#+begin_src emacs-lisp
  (defun boost-gptel-generate-docstring ()
    "Generate a docstring for the current function using GPTel."
    (interactive)
    (let* ((function-source (boost--extract-defun-source))
           (prompt (format "Generate a detailed docstring for the following function:

%s

Follow Emacs docstring conventions." function-source)))
      (gptel-request prompt)))
#+end_src

**** Bug analysis

#+begin_src emacs-lisp
  (defun boost-gptel-debug-function ()
    "Analyze the current function for bugs or improvements using GPTel."
    (interactive)
    (let* ((function-source (boost--extract-defun-source))
           (prompt (format "Analyze this function for potential bugs or improvements:

%s

Provide a list of issues and suggested fixes." function-source)))
      (gptel-request prompt)))
#+end_src

**** Usage examples

#+begin_src emacs-lisp
  (defun boost-gptel-generate-example-usage ()
    "Generate example usage for the current function using GPTel."
    (interactive)
    (let* ((function-name (or (which-function) "unknown-function"))
           (function-source (boost--extract-defun-source))
           (prompt (format "Provide example usage code for the following function named %s:

%s

Include a brief explanation of each example."
                           function-name function-source)))
      (gptel-request prompt)))
#+end_src

**** Function from description

#+begin_src emacs-lisp
  (defun boost-gptel-generate-function-from-spec ()
    "Generate an Emacs Lisp function from a user-provided specification using GPTel."
    (interactive)
    (let ((spec (read-string "Enter the function specification (e.g., 'Write a function to reverse a string'): ")))
      (when spec
        (let ((prompt (format "Generate an Emacs Lisp function based on this specification: %s

Provide the function code and a brief explanation of how it works."
                              spec)))
          (gptel-request prompt)))))
#+end_src

**** Performance

#+begin_src emacs-lisp
  (defun boost-gptel-optimize-function-performance ()
    "Suggest performance optimizations for the current function using GPTel."
    (interactive)
    (let* ((function-source (boost--extract-defun-source))
           (prompt (format "Analyze this Emacs Lisp function for performance bottlenecks:

%s

Suggest optimizations with code examples and explain why they improve performance." function-source)))
      (gptel-request prompt)))
#+end_src

**** Full code review

#+begin_src emacs-lisp
  (defvar boost-gptel-code-review-prompt
    "Perform a code review for this Emacs Lisp code:

%s

Provide detailed feedback, including clarity, style, potential bugs, and
suggestions for improvement."
    "Prompt template for AI code review.")

  (defun boost-gptel-code-review-function (&optional arg)
    "Perform a code review on the current Emacs Lisp function, region, or buffer using GPTel.
  With no prefix argument, review the current function.
  With one `C-u`, review the active region.
  With two `C-u` (i.e., `C-u C-u`), review the entire buffer.

  The review output is sent to the *Code Review* buffer."
    (interactive "p")
    (unless (fboundp 'gptel-request)
      (error "[GPTel package is not loaded or configured]"))
    (let* ((function-source
            (cond
             ((= arg 16) ;; C-u C-u
              (buffer-substring-no-properties (point-min) (point-max)))
             ((= arg 4)  ;; C-u
              (if (use-region-p)
                  (buffer-substring-no-properties (region-beginning) (region-end))
                (error "[No active region found]")))
             (t ;; default: current defun
              (save-excursion
                (unless (beginning-of-defun)
                  (error "[No function found at point]"))
                (buffer-substring-no-properties
                 (point)
                 (progn (end-of-defun) (point)))))))
           (prompt (format boost-gptel-code-review-prompt function-source))
           (output-buffer (get-buffer-create "*Code Review*")))
      (when (string-empty-p function-source)
        (error "[No valid code source extracted]"))
      (message "[Sending code for AI code review...]")
      (condition-case err
          (gptel-request prompt
            :buffer output-buffer
            :callback
            (lambda (response info)
              (let ((buf (or (plist-get info :buffer) output-buffer)))
               (with-current-buffer buf
                 (erase-buffer)
                 (insert (or response "[No response received from GPTel]"))
                 (emacs-lisp-mode)
                 (display-buffer buf))
               (message "[Code review completed!]"))))
        (error (message "[Code review failed: %s]" err)))))
#+end_src

**** Companion / inverse function

#+begin_src emacs-lisp
  (defun boost-gptel-generate-companion-function ()
    "Generate a companion function for the current function using GPTel."
    (interactive)
    (let* ((function-name (or (which-function) "unknown-function"))
           (function-source (boost--extract-defun-source))
           (prompt (format "Generate a companion function for this Emacs Lisp function named %s:

%s

The companion could be an inverse operation, a helper function, or
something that logically complements it. Provide the code and explain
its purpose."
                           function-name function-source)))
      (gptel-request prompt)))
#+end_src

*** Experimental / Commented

**** Template system with {{placeholders}}

#+begin_src emacs-lisp :tangle no
(defvar my/gptel-templates
  '(("facecam-30s"
     . "Rôle: maître des scripts viraux. Niche: {{NICHE}} (audience: {{AUDIENCE|débutants}}).
Écris un script face-cam de {{DUREE|35}}s sur: {{SUJET}}.
Structure: Hook puissant, Body (problème→solution→bénéfice), CTA pour s'abonner.")
    ("rewrite-friendly"
     . "Réécris ce texte pour {{OBJECTIF|clarifier et dynamiser}}, ton {{TON|amical et pro}}:\n\n{{TEXTE}}"))
  "Alist (NAME . TEMPLATE). Placeholders: {{Nom}} ou {{Nom|valeur-par-défaut}}.")

(defun my/render-template-placeholders (template)
  "Rend `TEMPLATE' en remplaçant {{Var}} ou {{Var|defaut}} par des saisies interactives."
  (let ((s template)
        (re "{{\\([^}|]+\\)\\(?:|\\([^}]*\\)\\)?}}")
        (seen (make-hash-table :test 'equal)))
    (while (string-match re s)
      (let* ((var  (string-trim (match-string 1 s)))
             (def  (or (match-string 2 s) ""))
             (prev (gethash var seen))
             (val  (or prev
                       (read-string (format "%s%s: " var (if (string-empty-p def) "" (format " (def: %s)" def)))
                                    nil nil def))))
        (puthash var val seen)
        (setq s (replace-match (regexp-quote val) t t s))))
    s))

(defun my/gptel--send (prompt)
  "Envoie PROMPT via gptel si disponible, sinon l'insère et le copie."
  (cond
   ;; gptel >= 0.9 : gptel-request est dispo
   ((fboundp 'gptel-request)
    (gptel-request prompt :stream t)
    (message "[gptel: requête envoyée]"))
   ;; fallback : insérer dans le buffer + copier
   (t
    (insert prompt)
    (kill-new prompt)
    (message "[gptel non trouvé : prompt inséré et copié (yank dans un buffer gptel)]"))))

(defun my/gptel-template-run (name)
  "Choisir un template par NAME, remplir les placeholders, et envoyer via gptel."
  (interactive
   (list (completing-read "Template: " (mapcar #'car my/gptel-templates) nil t)))
  (let* ((tmpl (alist-get name my/gptel-templates nil nil #'string=)))
    (unless tmpl (user-error "[Template introuvable: %s]" name))
    (my/gptel--send (my/render-template-placeholders tmpl))))

;; Raccourcis pratiques
(global-set-key (kbd "C-c t g") #'my/gptel-template-run)
#+end_src

** Keybindings

| Key     | Command                          | Context     | Status                            |
|---------+----------------------------------+-------------+-----------------------------------|
| C-c RET | gptel-send                       | global      | recommended                       |
| C-c g   | boost-gptel-chat-buffer or gptel | global      | OK                                |
| <f1>    | boost-gptel-chat-buffer          | global      | ← Warning: overwrites Emacs help! |
| C-c g   | gptel-menu (transient)           | global      | very useful                       |
| C-c q   | boost-gptel-org-send-to-chatgpt  | org-mode    | useful                            |
| C-x v w | boost-gptel-write-commit-message | global/diff | handy                             |

(global-set-key (kbd "C-c g") 'gptel-send)
(global-set-key (kbd "C-c r") 'gptel-rewrite)

:bind ("C-<f1>" . gptel)               ;; ← main entry: start / switch to chat buffer
:bind (("C-c g"   . gptel-menu)        ;; transient menu: change model, backend, etc.

#+begin_src emacs-lisp :tangle no
(defvar boost-ai-map
  (let ((map (make-sparse-keymap)))
    (define-key map "c" #'boost-gptel-chat-buffer)
    (define-key map "s" #'gptel-send)
    (define-key map "m" #'gptel-menu)
    (define-key map "q" #'boost-gptel-org-send-to-chatgpt)
    (define-key map "w" #'boost-gptel-write-commit-message)
    map))

(global-set-key (kbd "C-c g") boost-ai-map)
#+end_src

*** Global bindings

#+begin_src emacs-lisp
  ;; Unbind `C-c RET' in Org mode.
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-c RET") nil))

  ;; Quick access to gptel-send (only if key is free).
  (with-eval-after-load 'gptel
    (boost--set-key-if-free global-map (kbd "C-c RET")
                             #'gptel-send "global map"))
#+end_src

#+begin_src emacs-lisp
  ;; Global keybinding (only if free).
  (boost--set-key-if-free global-map (kbd "C-c g")
                           #'boost-gptel-chat-buffer "global map")

  ;; ;; Global keybinding (only if free).
  ;; (boost--set-key-if-free global-map (kbd "<f1>")
  ;;                          #'boost-gptel-chat-buffer "global map")
  (global-set-key (kbd "<f1>") #'boost-gptel-chat-buffer)
#+end_src

*** Org-mode specific

#+begin_src emacs-lisp
  ;; Org mode keybinding (only if free).
  (with-eval-after-load 'org
    (boost--set-key-if-free 'org-mode-map (kbd "C-c q")
                             #'boost-gptel-org-send-to-chatgpt "Org mode"))
#+end_src

*** Diff-mode specific

#+begin_src emacs-lisp
  ;; Diff mode keybinding (only if free).
  (with-eval-after-load 'diff-mode
    (boost--set-key-if-free 'diff-mode-map (kbd "w")
                             #'boost-gptel-write-commit-message "diff-mode"))

  ;; Global keybinding (only if free).
  (boost--set-key-if-free global-map (kbd "C-x v w")
                           #'boost-gptel-write-commit-message "global map")
#+end_src

#+begin_src emacs-lisp
)
#+end_src

* Org-ai

#+begin_src emacs-lisp
;; Load org-ai.
(when (boost--try-require 'org-ai)

  ;; Enable org-ai-mode in Org mode.
  (add-hook 'org-mode-hook #'org-ai-mode)

  ;; Set OpenAI API key.
  (when (bound-and-true-p boost-openai-api-key)
    (setq org-ai-openai-api-token boost-openai-api-key))

  ;; Install YASnippet templates for org-ai.
  (when (boost--try-require 'yasnippet)
    (org-ai-install-yasnippets)))
#+end_src

The package whisper.el is needed for transcribing speech.

* Finalization & Provide

#+begin_src emacs-lisp
(message "* --[ Loaded Emacs-Leuven AI %s ]--"
         (if (boundp 'lvn--emacs-version) lvn--emacs-version ""))
#+end_src

#+begin_src emacs-lisp
(provide 'emacs-leuven-ai)

;;; emacs-leuven-ai.el ends here
#+end_src

# emacs-leuven-ai.txt ends here
