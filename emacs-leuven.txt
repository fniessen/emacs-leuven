# Hey Emacs, this is a -*- org -*- file ...
#+TITLE:     Emacs Leuven
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
# Time-stamp: <2013-11-08 Fri 23:40>
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en

#+SEQ_TODO: TODO FIXME DOESN'T_WORK | WORKS

#+PROPERTY:  tangle emacs-leuven.el
#+PROPERTY:  padline yes
#+PROPERTY:  eval no

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="file:///D:/Users/fni/src/org-style/bigblow/css/bigblow.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="file:///D:/Users/fni/src/org-style/bigblow/css/htmlize.css"/>
#+OPTIONS:   H:4 num:nil

* Header

#+name: time-stamp
#+begin_src sh :eval yes :results silent :tangle no
echo "$(date '+%Y%m%d.%H%M')"
#+end_src

#+begin_src emacs-lisp :noweb yes
;;; emacs-leuven.el --- Emacs configuration file with more pleasant defaults

;; Copyright (C) 1999-2013 Fabrice Niessen

;; Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
;; URL: https://github.com/fniessen/emacs-leuven
;; Version: <<time-stamp()>>
;; Keywords: emacs, dotfile, config

;;
;;    ___ _ __ ___   __ _  ___ ___
;;   / _ \ '_ ` _ \ / _` |/ __/ __|
;;  |  __/ | | | | | (_| | (__\__ \
;; (_)___|_| |_| |_|\__,_|\___|___/
;;

;; This file is NOT part of GNU Emacs.

;; This file is free software: you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation, either version 3 of
;; the License, or (at your option) any later version.
;;
;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this file. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Emacs configuration file with many packages already enabled and a more
;; pleasant set of defaults.
;;
;; Operating systems: supposed to work both for Windows and for Linux.
;;
;; Minimal .emacs configuration file:
;;
;;     (add-to-list 'load-path "/path/to/emacs-leuven/")
;;     (require 'emacs-leuven)
;;
;; To get more debug info about the packages getting loaded, add the following
;; line before requiring Emacs Leuven.
;;
;;     ;; show messages describing progress of loading Emacs Leuven
;;     (setq leuven-load-verbose t)
;;
;; To avoid be questioned about packages to add to your local Emacs
;; installation (though, I think you should install them), add the following
;; line before requiring Emacs Leuven.
;;
;;     ;; do not (try to) install extra Emacs packages
;;     (setq leuven-packages nil)
;;
;; For help on the Emacs Editor, see (info "(emacs)")  <== `C-x C-e' here!

;;; Citations:

;; - Show me your ~/.emacs and I will tell you who you are.
;;   -- Bogdan Maryniuk
;;
;; - Emacs is like a laser guided missile. It only has to be slightly
;;   mis-configured to ruin your whole day.
;;   -- Sean McGrath
;;
;; - While any text editor can save your files, only Emacs can save your soul.
;;   -- Per Abrahamsen
#+end_src

* Code

#+begin_src emacs-lisp :noweb yes
;;; Code:

;; This file is only provided as an example. Customize it to your own taste!

(message "* --[ Loading Emacs Leuven <<time-stamp()>>]--")

;; uptimes
(when (string-match "XEmacs" (version))
  ;; XEmacs doesn't have `float-time'
  (defun float-time ()
    "Convert `current-time' to a floating point number."
    (multiple-value-bind (s0 s1 s2) (current-time)
      (+ (* (float (ash 1 16)) s0) (float s1) (* 0.0000001 s2)))))

(defconst leuven-before-time (float-time)
  "Value of `float-time' before loading the Emacs Leuven library.")

;; turn on Common Lisp support
(eval-when-compile (require 'cl)) ;; provide useful things like `loop' and `setf'
#+end_src

#+begin_src emacs-lisp
;;; User Customizable Internal Variables

(defgroup emacs-leuven nil
  "Emacs Leuven."
  :group 'files
  :group 'comm)

(defcustom leuven-load-verbose nil
  "If non-nil, means show messages describing progress of loading Emacs Leuven."
  :group 'emacs-leuven
  :type 'integer)
#+end_src

#+begin_src emacs-lisp
(when (and (string-match "GNU Emacs" (version))
           leuven-load-verbose)
  (defadvice message (before leuven-when-was-that activate)
    "Add time stamps to `message' output."
    (ad-set-arg 0 (concat (format-time-string "[%Y-%m-%d %T.")
                          (substring (format-time-string "%N") 0 3)
                          (format-time-string "] ")
                          (ad-get-arg 0)))))
#+end_src

#+begin_src emacs-lisp
;; allow quick include/exclude of setup parts -- DO NOT EDIT the DEFVAR!
(defvar leuven-chapter-0-environment t) ; required
(defvar leuven-chapter-0-loading-libraries t)
                                        ; required
(defvar leuven-chapter-0-debugging t)
(defvar leuven-chapter-1-screen t)
(defvar leuven-chapter-6-exiting t)
(defvar leuven-chapter-7-basic t)
(defvar leuven-chapter-8-minibuffer t)
(defvar leuven-chapter-10-help t)
(defvar leuven-chapter-11-mark t)
(defvar leuven-chapter-12-killing t)
(defvar leuven-chapter-13-registers t)
(defvar leuven-chapter-14-display t)
(defvar leuven-chapter-15-search t)
(defvar leuven-chapter-16-fixit t)
(defvar leuven-chapter-17-keyboard-macros t)
(defvar leuven-chapter-18-files t)
(defvar leuven-chapter-19-buffers t)
(defvar leuven-chapter-20-windows t)
(defvar leuven-chapter-21-frames t)
(defvar leuven-chapter-22-international t)
(defvar leuven-chapter-23-major-and-minor-modes t)
(defvar leuven-chapter-24-indentation t)
(defvar leuven-chapter-25-text t)
(defvar leuven-chapter-25.9-org-mode t)
(defvar leuven-chapter-25.10-tex-mode t)
(defvar leuven-chapter-26-programs t)
(defvar leuven-chapter-27-building t)
(defvar leuven-chapter-28-maintaining t)
(defvar leuven-chapter-29-abbrevs t)
(defvar leuven-chapter-30-dired t)
(defvar leuven-chapter-31-calendar-diary t)
(defvar leuven-chapter-32-sending-mail t)
(defvar leuven-chapter-34-gnus t)
(defvar leuven-chapter-35-document-view t)
(defvar leuven-chapter-36-shell t)
(defvar leuven-chapter-37-emacs-server t)
(defvar leuven-chapter-38-printing t)
(defvar leuven-chapter-39-sorting t)
(defvar leuven-chapter-42-saving-emacs-sessions t)
(defvar leuven-chapter-45-hyperlinking t)
(defvar leuven-chapter-46-amusements t)
(defvar leuven-chapter-47-packages t)
(defvar leuven-chapter-48-customization t)
(defvar leuven-chapter-AppG-ms-dos t)
(defvar leuven-chapter-XX-emacs-display t)
(defvar leuven-chapter-99-debugging t)
#+end_src

#+begin_src emacs-lisp
(defvar leuven--load-times-list nil
  "List of chapters and time to load them.")

(defmacro leuven--chapter (chapterid chaptername &rest body)
  "Wrap Lisp expressions as CHAPTERNAME, evaluated only when CHAPTERID is not
  nil. Save execution times in the global list `leuven--load-times-list'."
  `(when ,chapterid
     (let (before-chapter-time
           this-chapter-time)
       (when leuven-load-verbose
         (message "** %s" ,chaptername))
       (setq before-chapter-time (float-time))
       (setq leuven--before-section-time (float-time)) ;; init section time
       (progn ,@body)
       (leuven--section (concat "[" ,chaptername " ends here]") 'end-of-chapter) ;; add fake closing section
       (setq this-chapter-time
             (format "%.3f" (- (float-time) before-chapter-time)))
       (add-to-list 'leuven--load-times-list
                    (concat "| " ,chaptername " "
                            "| " this-chapter-time " |")))))

(defvar leuven--before-section-time
  "Value of `float-time' before loading some section.")

(defun leuven--section (sectionname &optional end-of-chapter)
  "Output time taken since last saved time (in global variable
  `leuven--before-section-time')."
  (let ((this-section-time (- (float-time)
                              leuven--before-section-time)))
    (when leuven-load-verbose
      (when (not (equal this-section-time 0.000))
        (message "    Section time: %.3f s" this-section-time))
      (unless end-of-chapter (message "*** %s" sectionname)))
    ;; for next one
    (setq leuven--before-section-time (float-time))))
#+end_src

* Environment

#+begin_src emacs-lisp :tangle no
(list system-configuration system-type window-system)
#+end_src

#+results:
| i386-mingw-nt5.1.2600 | windows-nt | w32 |

- =system-type= ::
     =darwin=, =gnu/linux=, =cygwin=

- =system-configuration= ::
     =i686-pc-linux-gnu=, =i686-pc-cygwin=

- =window-system= ::
     =nil=, =w32=, =x=, =mac=. Use =(display-graphic-p)= in conditions

#+begin_src emacs-lisp
;;* Environment

(leuven--chapter leuven-chapter-0-environment "0 Environment"

;;** Type of OS

  (leuven--section "Type of OS")

  (defconst running-ms-windows
    (eq system-type 'windows-nt)
    "Running a native Microsoft Windows version of Emacs.")

  (defconst running-cygwin
    (eq system-type 'cygwin)
    "Running a Cygwin version of Emacs.")

  (defconst running-gnu-linux
    (eq system-type 'gnu/linux)
    "Running a GNU/Linux version of Emacs.")

  (defmacro MSWindows (&rest body)
    (list 'if running-ms-windows
          (cons 'progn body)))

  (defmacro GNULinux (&rest body)
    (list 'if running-gnu-linux
          (cons 'progn body)))

;;** Window system

  (leuven--section "Window system")

  (defconst running-x-window
    (eq window-system 'x)
    "Running X Window System.")

  (defmacro XWindow (&rest body)
    "Execute any number of forms if running X Window System."
    (list 'if running-x-window
          (cons 'progn body)))

;;** MS Windows

  ;; FIXME The path is not correct under Cygwin Emacs (gsprint.exe not found)
  (defconst windows-program-files-dir   ; sys-path
    (if running-ms-windows
        (file-name-as-directory (getenv "PROGRAMFILES"))
      "/usr/local/bin/")
    "Defines the default Windows Program Files folder.")

;;** Emacs version

  (leuven--section "Emacs version")

  (defconst running-gnu-emacs
    (string-match "GNU Emacs" (version))
    "Running GNU Emacs.")

  (defconst running-xemacs
    (string-match "XEmacs" (version))
    "Running XEmacs.")

  (defmacro GNUEmacs (&rest body)
    "Execute any number of forms if running GNU Emacs."
    (list 'if running-gnu-emacs
          (cons 'progn body)))

  (defmacro GNUEmacs24 (&rest body)
    (list 'if (string-match "GNU Emacs 24" (version))
          (cons 'progn body)))

  (defmacro XEmacs (&rest body)
    "Execute any number of forms if running XEmacs."
    (list 'if running-xemacs
          (cons 'progn body)))
#+end_src

#+begin_src emacs-lisp
;;** Init

  (leuven--section "Init")

  (XEmacs
    ;; don't load init file from `~/.xemacs/init.el' (and don't offer its
    ;; migration)
    (setq load-home-init-file t))

  ;; ensure that the echo area is always visible during the early stage of
  ;; startup (useful in case of error)
  (modify-all-frames-parameters
   '((height . 32)))

) ;; chapter 0 ends here
#+end_src

* Loading Libraries of Lisp Code for Emacs

#+begin_src emacs-lisp
;;* Loading Libraries of Lisp Code for Emacs

(leuven--chapter leuven-chapter-0-loading-libraries "0 Loading Libraries"

  ;; You have to put the `load-path' stuff as early as you can...

  ;; This is a list of directories where Emacs Lisp libraries (`.el' and
  ;; `.elc' files) are installed.

  ;; The most important directories are the last!

  ;; load-path enhancement
  ;; TODO Check that added directories do have a trailing slash
  ;; The GNU Emacs FAQ includes a trailing slash in the instructions
  ;; on how to add directories to one's load path via .emacs [1]:
  ;; (add-to-list 'load-path "/dir/subdir/")
  ;; [1] See 5.17 here: http://www.gnu.org/software/emacs/emacs-faq.html
  (defun leuven-add-to-load-path (this-directory)
    "Add THIS-DIRECTORY at the beginning of the load-path, if it exists."
    (when (and this-directory
               (file-directory-p this-directory))
      ;; TODO Add warning if directory does not exist
      (let* ((this-directory (expand-file-name this-directory)))

        ;; directories containing a `.nosearch' file (such as
        ;; `auctex-11.87\style') should not made part of `load-path'.
        ;; TODO `RCS' and `CVS' directories should also be excluded.
        (unless (file-exists-p (concat this-directory "/.nosearch"))
          (add-to-list 'load-path this-directory)
          (when leuven-load-verbose
            (message "(Info) Added `%s' to `load-path'" this-directory))))))
#+end_src

#+begin_src emacs-lisp
  ;; wrapper around `eval-after-load' (added in GNU Emacs 24.4)
  (defmacro with-eval-after-load (mode &rest body)
    "`eval-after-load' MODE evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,mode
       '(progn
          (message "(Info)                                  Running code specific to `%s'..." ,mode)
          ,@body)))
#+end_src

** Library Search

#+begin_src emacs-lisp
  ;; remember this directory
  (defconst leuven--directory
    (file-name-directory (or load-file-name (buffer-file-name)))
    "Directory path of Emacs Leuven.")
#+end_src

=leuven-user-lisp-directory= is there so that you have an easy way of installing
your own Emacs add-ons (which may be specific to the version of Emacs you're
running). This keeps your local add-ons apart from distro supplied ones.

It also means you can do a complete re-install of Emacs (or even your Linux
distro) without impacting on stuff you have added by hand.

*************** TODO Specify variables using `defcustom'

#+begin_src emacs-lisp
  (defvar leuven-user-lisp-directory "~/.emacs.d/lisp/"
    "Directory containing personal additional Emacs Lisp packages.")

  (leuven-add-to-load-path leuven-user-lisp-directory)
#+end_src

Adding the right Lisp directories to your =load-path= must be the very *first
thing* in your =.emacs= file, before the first time packages are required, to
make sure that you're not picking up bits and pieces from older files (bundled
with Emacs, and loaded before the path to the *newest* versions are set).

Some Emacs modes are over 10K lines of code (e.g. nxml-mode, CEDET). Many
packages (e.g. Org, Gnus) make use of the =autoload= feature, so that you only
need to load a single file that define autoloaded functions.

#+begin_src emacs-lisp
;;*** Development code

  (defvar leuven-local-repos-directory "~/Public/Repositories/"
    "Directory containing additional Emacs Lisp public repositories.")

  (leuven-add-to-load-path
   (concat leuven-local-repos-directory "babel"))
  (leuven-add-to-load-path
   (concat leuven-local-repos-directory "emacs-bookmark-extension"))
#+end_src

Use =M-x list-load-path-shadows <RET>= to display a list of external Emacs Lisp
files that shadow Emacs builtins (listing potential load path problems).

#+begin_src emacs-lisp
  (defun leuven--file-exists-and-executable-p (file)
    "Make sure the file FILE exists and is executable."
    (if file
        (if (file-executable-p file)
            file
          (message "(warning) Can't find executable `%s'" file)
          ;; sleep 1.5 s so that you can see the warning
          (sit-for 1.5))
      (error "leuven--file-exists-and-executable-p: missing operand")))

) ;; chapter 0-loading-libraries ends here
#+end_src

* Emacs Lisp Packages

** Try-require

Ignore errors.

#+begin_src emacs-lisp
  (defvar leuven--missing-packages nil
    "List of packages that `try-require' or `locate-library' can't find.")

  (defadvice locate-library (around leuven-locate-library activate)
    "Locate Emacs library named LIBRARY and report time spent."
    (let ((filename (ad-get-arg 0))
          (find-file-time-start (float-time)))
      (if ad-do-it
          (when leuven-load-verbose
            (message "(Info)                                  Locating library %s... located (in %.3f s.)" filename
                     (- (float-time) find-file-time-start)))
        (add-to-list 'leuven--missing-packages filename 'append)
        (when leuven-load-verbose
          (message "(Info)                                  Locating library %s... missing (in %.3f s.)" filename
                     (- (float-time) find-file-time-start))))))

  ;; require a feature/library if available; if not, fail silently
  (defun try-require (feature)
    "Attempt to load a feature or library.

  Return true if the library given as argument is successfully loaded. If not,
  instead of an error, just add the package to a list of missing packages."
    (let (time-start)
      (condition-case err
          ;; protected form
          (progn
            (when leuven-load-verbose
              (message "(Info)                                  Trying to require `%s'..." feature))
            (if (stringp feature)
                (load-library feature)
              (setq time-start (float-time))
              (require feature))
            ;; return t (necessary for correct behavior in conditions,
            ;; when leuven-load-verbose is nil)
            t)
        ;; error handler
        (file-error ;; condition
         (progn
           (when leuven-load-verbose
             (message "(Info)                                  Trying to require `%s'... missing" feature))
           (add-to-list 'leuven--missing-packages feature 'append))
         nil))))
#+end_src

** The Package Menu Buffer

#+begin_src emacs-lisp
;;* 47 Emacs Lisp (info "(emacs)Packages")

(leuven--chapter leuven-chapter-47-packages "47 Emacs Lisp Packages"
#+end_src

To upgrade packages after running =package-list-packages=, type:

- =U= (/mark Upgradable packages/) and then
- =x= (/eXecute the installs and deletions/).

When it's done installing all the packages, you delete the obsolete packages
by hit =y= (/Yes/) when asked.

** Package Installation

In Marmalade the developers themselves do the packaging. In MELPA, packages
are generated programmatically from upstream Git-based sources.

#+begin_src emacs-lisp
;;** 47.2 Package Installation

  (leuven--section "47.2 Package Installation")

  ;; simple package system for GNU Emacs
  (GNUEmacs
    (when (try-require 'package)

      ;; archives from which to fetch
      (setq package-archives
            (append '(("org"       . "http://orgmode.org/elpa/")
                      ("melpa"     . "http://melpa.milkbox.net/packages/")
                      ("marmalade" . "http://marmalade-repo.org/packages/")
                      ;; ("ELPA"      . "http://tromey.com/elpa/")
                      )
                    package-archives))

      ;; load the latest version of all installed packages, and activate them
      ;; (= add ALL ELPA subdirs to `load-path' and load `<pkg>-autoloads.el'?)
      (package-initialize)

      ;; download the ELPA archive description if needed
      (unless package-archive-contents
        (package-refresh-contents))

      (defcustom leuven-packages
        '(auctex
          auto-complete
          bbdb
          calfw
          circe
          ;; dictionary
          ess
          fuzzy
          git-commit-mode
          ;; gnuplot-mode                  ; or gnuplot?
          graphviz-dot-mode
          helm
          idle-require
          interaction-log
          ;; jabber
          ledger-mode
          leuven-theme
          htmlize                       ; works with Org
          ;; org
          ;; org-mime                      ; from contrib
          pager
          ;; paredit
          rainbow-mode
          redshank
          tidy
          ;; w3m
          yasnippet)
        "A list of packages to ensure are installed at Emacs startup."
        :group 'emacs-leuven
        :type '(repeat (string)))

      ;; install all packages specified in `leuven-packages' which are not built-in nor
      ;; already installed (must be run after initializing `package-initialize')
      (dolist (pkg leuven-packages)
        (if (or (package-installed-p pkg)
                (locate-library (symbol-name pkg)))
            (message "(Info) Package `%s' built-in or already installed..." pkg)
          (if (yes-or-no-p (format "Install package `%s'? " pkg))
              (ignore-errors
                (package-install pkg))
            (message "Customize `leuven-packages' to ignore this package at next startup...")
            (sit-for 1.5))))

      ;; don't truncate package names in Emacs package list
      (add-hook 'package-menu-mode-hook
                (lambda ()
                  (setq tabulated-list-format
                        [("Package" 28 package-menu--name-predicate)
                         ("Version" 14 nil)
                         ("Status"  10 package-menu--status-predicate)
                         ("Description" 0 nil)])
                  (tabulated-list-init-header)))))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 47 ends here
#+end_src

** Check Org mode version

The following block checks for the Org mode version, and warns the user if not
equal to 8 or more.

Though, it does load the full Org mode right from the start...

#+begin_src emacs-lisp :tangle no
;; version info
(let ((org-install-dir (file-name-directory (locate-library "org-loaddefs")))
      (org-dir (file-name-directory (locate-library "org")))) ;; org.(el|elc)
  (message "Org mode version %s (org @ %s)"
           (org-version)
           (if (string= org-dir org-install-dir)
               org-install-dir
             (concat "mixed installation! " org-install-dir " and " org-dir)
             (sit-for 1.5))))

(unless (string-match "^8" (org-version))
  (message (concat "This version of Org mode is no longer supported. "
                   "Please upgrade to 8 or later"))
  (sit-for 1.5))
#+end_src

* Debugging

#+begin_src emacs-lisp
;;* Debugging

(leuven--chapter leuven-chapter-0-debugging "0 Debugging"

  ;; get the backtrace when uncaught errors occur
  (setq debug-on-error t) ;; will be unset at the end

  (XEmacs
    (setq stack-trace-on-error t))

  ;; hit `C-g' while it's frozen to get an ELisp backtrace
  (setq debug-on-quit nil)

) ;; chapter 0 ends here
#+end_src

#+begin_src emacs-lisp
  (defadvice find-file (around leuven-find-file activate)
    "Open the file named FILENAME and report time spent."
    (let ((filename (ad-get-arg 0))
          (find-file-time-start (float-time)))
      (message "(Info) Finding file %s..." filename)
      ad-do-it
      (message "(Info) Found file %s in %.2f s." filename
               (- (float-time) find-file-time-start))))
#+end_src

#+begin_src emacs-lisp
  ;; make loaded files give a message
  (when leuven-load-verbose
    (GNUEmacs
      (defadvice load (around leuven-load activate)
        "Execute a file of Lisp code named FILE and report time spent."
        (let ((filename (ad-get-arg 0))
              (find-file-time-start (float-time)))
          (message "(Info)                                  Loading %s..." filename)
          ad-do-it
          (message "(Info)                                  Loaded %s in %.3f s." filename
                   (- (float-time) find-file-time-start))))

      (defadvice require (around leuven-require activate)
        "Leave a trace of packages being loaded."
        (let* ((feature (ad-get-arg 0))
               (require-depth (or (and (boundp 'require-depth) require-depth)
                                  0))
               (prefix (concat (make-string (* 2 require-depth) ? ) "+-> ")))
          (cond ((featurep feature)
                 (message "(Info) %sRequiring `%s'... already loaded"
                          prefix feature)
                 ;; in the case `ad-do-it' is not called, you have to set the
                 ;; return value yourself!
                 (setq ad-return-value feature))
                (t
                 (let ((time-start))
                   (message "(Info) %sRequiring `%s'... %s"
                            prefix feature
                            (locate-library (symbol-name feature)))
                   (setq time-start (float-time))
                   (let ((require-depth (1+ require-depth)))
                     ad-do-it)
                   (message "(Info) %sRequiring `%s'... loaded in %.3f s"
                            prefix feature
                            (- (float-time) time-start)))))))))
#+end_src

#+begin_src emacs-lisp
  (if (try-require 'idle-require)

      (progn
        ;; idle time in seconds after which autoload functions will be loaded
        (setq idle-require-idle-delay 5)

        ;; time in seconds between automatically loaded functions
        (setq idle-require-load-break 2))

    ;; fail-safe for `idle-require'
    (defun idle-require (feature &optional file noerror)
      (try-require feature)))

  (add-hook 'after-init-hook
            (lambda ()
              (when (fboundp 'idle-require-mode)
                ;; starts loading
                (idle-require-mode 1))))
#+end_src

* The Organization of the Screen

#+begin_src emacs-lisp
;;* 1 The Organization of the (info "(emacs)Screen")

(leuven--chapter leuven-chapter-1-screen "1 The Organization of the Screen"
#+end_src

** The Echo Area

#+begin_src emacs-lisp
;;** 1.2 The (info "(emacs)Echo Area")

  (leuven--section "1.2 (emacs) The Echo Area")

  ;; don't truncate the message log buffer when it becomes large
  (setq message-log-max t)
#+end_src

#+begin_src emacs-lisp
) ;; chapter 1 ends here
#+end_src

* Exiting Emacs

#+begin_src emacs-lisp
;;* 6 (info "(emacs)Exiting") Emacs

(leuven--chapter leuven-chapter-6-exiting "6 Exiting Emacs"

  ;; quit with Alt + F4
  (global-set-key
    (kbd "<M-f4>") 'save-buffers-kill-terminal)

) ;; chapter 6 ends here
#+end_src

* Basic Editing Commands

#+begin_src emacs-lisp
;;* 7 (info "(emacs)Basic") Editing Commands

(leuven--chapter leuven-chapter-7-basic "7 Basic Editing Commands"
#+end_src

** Inserting Text

#+begin_src emacs-lisp
;;** 7.1 (info "(emacs)Inserting Text")

  (leuven--section "7.1 (emacs)Inserting Text")

  ;; enter characters by their code in octal (for `C-q NNN <RET>')
  (setq read-quoted-char-radix 8) ;; 16 for hexadecimal (for Unicode char)
#+end_src

** Moving Point Location

- M-r ::
     =move-to-window-line=

#+begin_src emacs-lisp
;;** 7.2 (info "(emacs)Moving Point") Location

  (leuven--section "7.2 (emacs)Moving Point Location")

  ;; don't add newlines to end of buffer when scrolling
  (setq next-line-add-newlines nil)

  ;; move point to a given line number (XEmacs default)
  (GNUEmacs
    (global-set-key
      (kbd "M-g") 'goto-line))

  ;; print the current buffer line number
  (global-set-key
    (kbd "M-G") 'what-line)
#+end_src

** Basic Undoing Changes

#+begin_src emacs-lisp
;;** 7.4 (info "(emacs)Basic Undo")ing Changes

  (leuven--section "7.4 (emacs)Basic Undoing Changes")

  ;; undo some previous changes
  (global-set-key
    (kbd "<f11>") 'undo)

  ;; redo the most recent undo
  (when (locate-library "redo")
    (autoload 'redo "redo" "Redo the the most recent undo." t)
    (global-set-key
      (kbd "<S-f11>") 'redo))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 7 ends here
#+end_src

* The Minibuffer

#+begin_src emacs-lisp
;;* 8 The (info "(emacs)Minibuffer")

(leuven--chapter leuven-chapter-8-minibuffer "8 The Minibuffer"

  ;; how long to display an echo-area message when the minibuffer is active
  (setq minibuffer-message-timeout 0.5)
#+end_src

** Editing in the Minibuffer

If the output is short enough to display in the echo area (which is determined
by the variables =resize-mini-windows= and =max-mini-window-height=), it is shown
in echo area.

#+begin_src emacs-lisp
;;** 8.3 (info "(emacs)Minibuffer Edit")ing

  (leuven--section "8.3 (emacs)Minibuffer Editing")

  ;; minibuffer and echo area windows resize vertically as necessary to fit
  ;; the text displayed in them
  (setq resize-mini-windows t)
#+end_src

** Completion

#+begin_src emacs-lisp
;;** 8.4 (info "(emacs)Completion")

  (leuven--section "8.4 (emacs)Completion")

  ;; don't consider case significant in completion (GNU Emacs default)
  (XEmacs
    (setq completion-ignore-case t))

  ;; ignore case when reading a file name
  (setq read-file-name-completion-ignore-case t)

  ;; ignore case when reading a buffer name
  (setq read-buffer-completion-ignore-case t)
#+end_src

#+begin_src emacs-lisp
  ;; provide the same facility of `ls --color' inside Emacs
  (when (locate-library "dircolors")
    (autoload 'dircolors "dircolors" nil t)
    (add-hook 'completion-list-mode-hook 'dircolors))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 8 ends here
#+end_src

* Help

In general, the following functions are very interesting for finding useful
functions and documentation.

- apropos-documentation (=C-h d=) ::
     *Show symbols whose documentation contains matches for PATTERN.*

- describe-function (=C-h f=) ::
     Used with TAB completion to show documentation of functions.

- elisp-index-search (=C-h E= in Emacs Leuven) ::
     Look up documentation on broad ELisp topics (in the indices of the Emacs
     Lisp Reference Manual).

- info-lookup-symbol (=C-h S=, or =C-f1= in Emacs Leuven) ::
     *Bring the relevant section from the manual, which describes the topic in
     more detail.*

With all prefix keys, if you follow them with =C-h= (=h= for help), a list of key
bindings in that prefix map is displayed. This is automatic and is one of the
self-documenting features of Emacs.

Try, for example =C-x C-h= or =C-c C-x C-h= to see what it does. I do use it to
remind myself of rarely used rectangle commands: =C-x r C-h=.

FYI, =catman= create the database files that are used by =apropos= or =man -k=.

Note about PHP documentation lookup -- PHP Mode has a nice feature to lookup
the function's definition in PHP's manual in your web browser (=M-x
php-search-documentation= or =C-c C-f=). You can combine it with Emacs-w3m to get
the relevant manual page without leaving Emacs.

#+begin_src emacs-lisp
;;* 10 (info "(emacs)Help")

(leuven--chapter leuven-chapter-10-help "10 Help"
#+end_src

*Close* the help buffer by pressing =Q=.

** Help Summary

#+begin_src emacs-lisp
;;** 10.1 (info "(emacs)Help Summary")

  (leuven--section "10.1 (emacs)Help Summary")

  ;; find convenient unbound keystrokes (undefined key bindings)
  (autoload 'describe-unbound-keys "unbound"
    "Display a list of unbound keystrokes of complexity no greater than MAX." t)

  ;; avoid the description of all minor modes
  (defun describe-major-mode ()
    "Describe only `major-mode'."
    (interactive)
    (describe-function major-mode))

  ;; look up subject in (the indices of the) ELisp manual
  (global-set-key
    (kbd "C-h E") 'elisp-index-search)
#+end_src

** Apropos

You can ask what pertains to a given topic by typing =M-x apropos <RET> pattern
<RET>=.

#+begin_src emacs-lisp
;;** 10.4 (info "(emacs)Apropos")

  (leuven--section "10.4 (emacs)Apropos")

  (with-eval-after-load "apropos"

    ;; check all variables and non-interactive functions as well
    (setq apropos-do-all t))

  ;; show variables whose name matches the pattern
  (GNUEmacs
    (global-set-key
      (kbd "C-h A") 'apropos-variable))
#+end_src

** Misc Help Commands

The =*Messages*= buffer is called the " *Message-Log*" on XEmacs (note the initial
space). To display the message log, execute the command =M-x show-message-log=.

=update-info-dir=

The utility =install-info= is used to maintain the =info/dir= file.

=C-h K= goes to the node in the Emacs manual describing the command bound to a
key.

In a manual, these key bindings will make your life easier:

- =^= ::
     Move "up" from this node.

- =]= ::
     Go forward one node, considering all nodes as forming one sequence.

- =l= ::
     Move back in history to the last node you were at.

- =L= ::
     Go to menu of visited nodes.

- =i= ::
     *Search for a topic in this manual's Index* and go to index entry.

- s ::
     *Search for a regexp* and select node it's found in.

#+begin_src emacs-lisp
;;** 10.8 (info "(emacs)Misc Help")

  (leuven--section "10.8 (emacs)Misc Help")

  ;; enter Info documentation browser
  (global-set-key
    (kbd "<f1>") 'info)

  ;; display symbol definitions, as found in the relevant manual
  ;; (for AWK, C, ELisp, LaTeX, M4, Makefile, Sh and other languages that have
  ;; documentation in Info)
  (global-set-key
    (kbd "<C-f1>") 'info-lookup-symbol)

  (with-eval-after-load "info"
    ;; Don't play with `Info-directory-list', it's not intended to be
    ;; settable by the user. When `info' is called, this variable is
    ;; populated from:
    ;; 1. the `INFOPATH' environment variable and/or
    ;; 2. the `Info-default-directory-list' variable -- non-existent
    ;;    directories will be removed when copied to `Info-directory-list'

    ;; list of additional directories to search for Info documentation
    ;; files (in the order they are listed)
    (setq Info-default-directory-list
          ;; FIXME `Info-additional-directory-list' does not work
          (cond (running-ms-windows
                 ;; EmacsW32 doesn't see `INFOPATH'...
                 `(
                   ,(expand-file-name
                     (concat (file-name-directory (locate-library "org"))
                             "../doc/"))
                   ,(expand-file-name (concat leuven-local-repos-directory "gnus/texi/"))
                   "c:/cygwin/usr/share/info/"
                   ,@Info-default-directory-list))
                (t
                 ;; best to set the `INFOPATH' environment variable
                 ;; (outside of Emacs, in the same shell from which you
                 ;; invoke Emacs)
                 nil)))
#+end_src

~Info+~ fontifies entries for reference items (functions, macros, commands,
special forms, constants, options, other variables), and that includes their
parameters, even those on continuation lines.

#+begin_src emacs-lisp
    (GNUEmacs
      ;; with `info+.el', you can merge an Info node with its subnodes
      ;; into the same buffer, by calling `Info-merge-subnodes' (bound to
      ;; `+')
      (try-require 'info+-XXX))  ;; error finding dir file
#+end_src

#+begin_src emacs-lisp
    ;; some info related functions
    ;; (to insert links such as `(info "(message)Insertion Variables")')
    (when (locate-library "rs-info")
      (autoload 'rs-info-insert-current-node "rs-info"
        "Insert reference to current Info node using STYPE in buffer." t)
      (autoload 'rs-info-boxquote "rs-info"
        "Yank text (from an info node), box it and use current info node as title." t)
      (autoload 'rs-info-reload "rs-info"
        "Reload current info node." t)
      (autoload 'rs-info-insert-node-for-variable "rs-info"
        "Insert a custom style info node for the top level form at point." t)
      (defalias 'boxquote-info 'rs-info-boxquote))
    )
#+end_src

#+begin_src emacs-lisp
  ;; get a Unix manual page of the item under point
  (global-set-key
    (kbd "<S-f1>") 'man-follow)

  (with-eval-after-load "man"
    ;; make the manpage the current buffer in the current window
    (setq Man-notify-method 'pushy))

  ;; alias man to woman
  (defalias 'man 'woman)

  ;; decode and browse Unix man-pages "W.o. (without) Man"
  (with-eval-after-load "woman"
    (defalias 'man 'woman))

) ;; chapter 10 ends here
#+end_src

* Killing and Moving Text

#+begin_src emacs-lisp
;;* 12 (info "(emacs)Killing") and Moving Text

(leuven--chapter leuven-chapter-12-killing "12 Killing and Moving Text"
#+end_src

** Deletion and Killing

#+begin_src emacs-lisp
;;** 12.1 (info "(emacs)Deletion and Killing")

  (leuven--section "12.1 (emacs)Deletion and Killing")

  (GNUEmacs
;; old ([2012-09-07 Fri] remove "compile" after "activate")

    ;; add the ability to copy or cut the current line without marking it
    ;; (no active region) -- idea stolen from SlickEdit
    (defadvice kill-ring-save (before leuven-slick-copy activate)
      "When called interactively with no active region, copy the current
    line instead."
      (interactive
       (if (use-region-p) (list (region-beginning) (region-end))
         (message "Copied the current line")
         (list (line-beginning-position)
               (line-beginning-position 2)))))

    (defadvice kill-region (before leuven-slick-cut activate)
      "When called interactively with no active region, kill the current
    line instead."
      (interactive
       (if (use-region-p) (list (region-beginning) (region-end))
         (list (line-beginning-position)
               (line-beginning-position 2))))))

;; new

    ;; (defadvice kill-ring-save (around leuven-slick-copy activate)
    ;;   "When called interactively with no active region, copy a single line instead."
    ;;   (if (or (use-region-p) (not (called-interactively-p)))
    ;;       ad-do-it
    ;;     (kill-new (buffer-substring (line-beginning-position)
    ;;                                 (line-beginning-position 2)))
    ;;     (message "Copied line")))
    ;;
    ;; (defadvice kill-region (around leuven-slick-cut activate)
    ;;   "When called interactively with no active region, kill a single line instead."
    ;;   (if (or (use-region-p) (not (called-interactively-p)))
    ;;       ad-do-it
    ;;     (kill-new (filter-buffer-substring (line-beginning-position)
    ;;                                        (line-beginning-position 2) t))))
    ;;
    ;; (defun yank-line (string)
    ;;   "Insert STRING above the current line."
    ;;   (beginning-of-line)
    ;;   (unless (= (elt string (1- (length string))) ?\n)
    ;;     (save-excursion (insert "\n")))
    ;;   (insert string))

;; XXX perf 2.00 s requiring bytecomp and warnings...
#+end_src

** Yanking

#+begin_src emacs-lisp
;;** 12.2 (info "(emacs)Yanking")

  (leuven--section "12.2 (emacs)Yanking")

  ;; auto-indentation of pasted code in the listed programming modes (fall
  ;; back to default, non-indented yanking by preceding the yanking
  ;; command `C-y' with `C-u')
  (dolist (command '(yank yank-pop))
    (eval `(defadvice ,command (after leuven-indent-region activate)
             (and (not current-prefix-arg)
                  (derived-mode-p 'prog-mode)
                  (let ((mark-even-if-inactive transient-mark-mode))
                    (indent-region (region-beginning) (region-end) nil))))))
#+end_src

*** Yanking Earlier Kills

Interactively insert items from kill ring with =M-x helm-show-kill-ring= (see
[[id:59418189-b87e-45a2-b128-5cbdc8a16430][Helm]]).

** Cutting and Pasting on Graphical Displays

#+begin_src emacs-lisp
;;** 12.3 (info "(emacs)Cut and Paste")

  (leuven--section "12.3 (emacs)Cut and Paste on Graphical Displays")

  ;; copy/paste with Gnome desktop
  (GNUEmacs
    ;; ;; cutting and pasting uses the clipboard
    ;; (setq x-select-enable-clipboard t) ;; default in Emacs 24

    ;; make cut, copy and paste (keys and menu bar items) use the clipboard
    (menu-bar-enable-clipboard))
#+end_src

** Rectangles

Use =C-x r t STRING <RET>= to replace each line of a region-rectangle with a
given string.

To kill the text of the region-rectangle, use =C-x r k= (=kill-rectangle=).

=kill-rectangle= and =yank-rectangle= (=C-x r y=) can also be very useful for
shifting cells up/down within a column of an Org table while leaving remaining
columns intact.

** CUA Bindings

CUA mode sets up key bindings used in many other applications (=C-x=, =C-c=, =C-v=
and =C-z=).

The =C-x= and =C-c= keys only do cut and copy when the region is active, so in
most cases, they do not conflict with the normal function of these prefix
keys.

If you really need to perform a command which starts with one of the prefix
keys even when the region is active, you have three options:

- press the prefix key twice very quickly (within 0.2 seconds),
- press the prefix key and the following key within 0.2 seconds, or
- use the Shift key with the prefix key, i.e. =C-S-x= or =C-S-c=.

You can customize =cua-enable-cua-keys= to completely disable the CUA bindings,
or =cua-prefix-override-inhibit-delay= to change the prefix fallback behavior.

CUA mode also provides enhanced rectangle support with visible rectangle
highlighting. Check out [[http://www.vimeo.com/1168225?pg=embed&sec=1168225][Emacs Column Editing on Vimeo]].

- =<C-RET>= runs the command =cua-set-rectangle-mark=
- =M-n= runs the command =cua-sequence-rectangle=

#+begin_src emacs-lisp
) ;; chapter 12 ends here
#+end_src

* Registers

#+begin_src emacs-lisp
;;* 13 (info "(emacs)Registers")

(leuven--chapter leuven-chapter-13-registers "13 Registers"

  ;; ;; Enable position saving through shortcuts.
  ;; ;; Save current position with  Ctrl-F1 Ctrl-F2 Ctrl-F3 and Ctrl-F4
  ;; (global-set-key [C-f1] (lambda () (interactive) (point-to-register ?1)))
  ;; (global-set-key [C-f2] (lambda () (interactive) (point-to-register ?2)))
  ;; (global-set-key [C-f3] (lambda () (interactive) (point-to-register ?3)))
  ;; (global-set-key [C-f4] (lambda () (interactive) (point-to-register ?4)))

  ;; (defun jump-to-register-other (reg)
  ;; (other-window 1)
  ;; (jump-to-register reg)
  ;; (hilit-recenter (/ (window-height) 2)))

  ;; (defun jump-to-register-here (reg)
  ;; (jump-to-register reg)
  ;; (hilit-recenter (/ (window-height) 2)))

  ;; ;; Move to saved position with F1 F2 F3 and F4
  ;; (global-set-key [f1] (lambda () (interactive) (jump-to-register-here ?1)))
  ;; (global-set-key [f2] (lambda () (interactive) (jump-to-register-here ?2)))
  ;; (global-set-key [f3] (lambda () (interactive) (jump-to-register-here ?3)))
  ;; (global-set-key [f4] (lambda () (interactive) (jump-to-register-here ?4)))
#+end_src

Jump between configuration files

#+begin_src emacs-lisp :tangle no
(global-set-key (kbd "C-j") 'jump-to-register)

(set-register ?a (cons 'file "/sudo::/etc/apt/sources.list"))
(set-register ?b (cons 'file "~/News/KILL"))
(set-register ?C (cons 'file "/sudo::/etc/default/console-setup"))
(set-register ?c (cons 'file "~/.irssi/config"))
(set-register ?d (cons 'file "~/.emacs-dired"))
; etc.
#+end_src

** Bookmarks

Bookmarks are *persistent* and they have *names*; not /markers/. Bookmarked
positions can also be *relocated* (found) if they move slightly because of text
changes.

To navigate to a bookmark (linking to a file or directory), just press =C-x r
b=. You'll be prompted for the bookmark name, and it will open that file or
directory.

#+begin_src emacs-lisp
;;** 13.7 (info "(emacs)Bookmarks")

  (leuven--section "13.7 (emacs)Bookmarks")

  (with-eval-after-load "bookmark"

    ;; where to save the bookmarks
    (setq bookmark-default-file "~/.emacs.d/bookmarks.bmk")
    ;;! a .txt extension would load Org at the time bookmark is required!

    ;; each command that sets a bookmark will also save your bookmarks
    (setq bookmark-save-flag 1))
#+end_src

Visible bookmarks in buffer.

*Bookmark+* offers everything that =bm.el= offers, and quite a bit more.

#+begin_src emacs-lisp
  ;; extensions to standard library `bookmark.el'
  (with-eval-after-load "bookmark-XXX" ;; XXX here does not work!?

    (try-require 'bookmark+++XXX)

    ;; bookmarks to automatically highlight when jumped to
    (setq bmkp-auto-light-when-jump 'any-bookmark)

    ;; we will often be going back and forth between using Bookmark+ and
    ;; using vanilla Emacs
    (setq bmkp-propertize-bookmark-names-flag nil))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 13 ends here
#+end_src

* Controlling the Display

#+begin_src emacs-lisp
;;* 14 Controlling the (info "(emacs)Display")

(leuven--chapter leuven-chapter-14-display "14 Controlling the Display"
#+end_src

** Scrolling

#+begin_src emacs-lisp
;;** 14.1 (info "(emacs)Scrolling")

  (leuven--section "14.1 (emacs)Scrolling")

  ;; keep screen position of point when scrolling
  (setq scroll-preserve-screen-position t)

  ;; better scrolling in Emacs (doing a <PageDown> followed by a <PageUp> will
  ;; place the point at the same place)
  (when (locate-library "pager")
    (autoload 'pager-page-up "pager"
      "Like scroll-down, but moves a fixed amount of lines." t)
    (autoload 'pager-page-down "pager"
      "Like scroll-up, but moves a fixed amount of lines." t)

    (global-set-key
      (kbd "<prior>") 'pager-page-up)
    (global-set-key
      (kbd "<next>") 'pager-page-down))
#+end_src

** Automatic Scrolling

"Smooth" (civilized) scrolling.

#+begin_src emacs-lisp
;;** 14.3 (info "(emacs)Auto Scrolling")

  (leuven--section "14.3 (emacs)Auto Scrolling")

  ;; redisplay will never recenter point
  (setq scroll-conservatively 10000)    ; always scroll a line at a time

  ;; ;; scroll one line at a time
  ;; (setq scroll-step 1)                  ; XXX should be on?

  ;; number of lines of margin at the top and bottom of a window
  (setq scroll-margin 3)                ; also for `isearch-forward'

  ;; scrolling down looks much better
  (setq auto-window-vscroll nil)
#+end_src

** Narrowing

- =C-x n n= ::
     Narrow down to between point and mark

- =C-x n w= ::
     Widen to make the entire buffer accessible again

- =C-x n d= ::
     Narrow down to the current /defun/

#+begin_src emacs-lisp
;;** 14.5 (info "(emacs)Narrowing")

  (leuven--section "14.5 (emacs)Narrowing")

  ;; enable the use of the command `narrow-to-region' without confirmation
  (put 'narrow-to-region 'disabled nil)
#+end_src

** Font Lock mode

#+begin_src emacs-lisp
;;** 14.12 (info "(emacs)Font Lock")

  (leuven--section "14.12 (emacs)Font Lock")

  (XEmacs
    ;; stop showing that annoying progress bar when fontifying
    (setq progress-feedback-use-echo-area nil)

    ;; enable Font Lock mode
    (font-lock-mode))
#+end_src

All text-based major modes run =text-mode-hook=, and all programming language
modes run =prog-mode-hook=, prior to running their own mode hooks.

#+begin_src emacs-lisp
  ;; highlight FIXME notes
  (defvar leuven-highlight-keywords
    "\\(TODO\\|FIXME\\|XXX\\|BUG\\|[Ee]rror\\|ERROR\\|[Ww]arning\\|WARNING\\)"
    "Patterns to highlight.")

  (defvar leuven-highlight-keywords-in-org
    "\\(FIXME\\|XXX\\|BUG\\|[Ee]rror\\|[Ww]arning\\|WARNING\\)"
    "Patterns to highlight (for Org mode only, to ensure no conflict with the
  Org mode TODO keyword).")

  (defface leuven-highlight-face
    '((t (:foreground "#CC0000" :background "#FFFF88")))
    "Face for making FIXME and other warnings stand out.")

  ;; set up highlighting of special patterns for proper selected major modes
  ;; only
  (dolist (mode '(fundamental-mode
                  text-mode))
    (font-lock-add-keywords mode
     `((,leuven-highlight-keywords 1 'leuven-highlight-face prepend))))

  ;; set up highlighting of special patterns for Org mode only
  (dolist (mode '(org-mode))
    (font-lock-add-keywords mode
     `((,leuven-highlight-keywords-in-org 1 'leuven-highlight-face prepend))))

  ;; add fontification patterns (even in comments) to a selected major
  ;; mode *and* all major modes derived from it
  (defun leuven--highlight-special-patterns ()
    (interactive)
    (font-lock-add-keywords nil ;; in the current buffer
     `((,leuven-highlight-keywords 1 'leuven-highlight-face prepend))))
  ;; FIXME                    0                    t

  ;; set up highlighting of special patterns for selected major modes *and*
  ;; all major modes derived from them
  (dolist (hook '(prog-mode-hook
                  ;; text-mode-hook ;; avoid Org
                  css-mode-hook ;; [parent: fundamental]
                  latex-mode-hook
                  shell-mode-hook ;; [parent: fundamental] (works in *shell* buffers!)
                  ssh-config-mode-hook))
    (add-hook hook 'leuven--highlight-special-patterns))
#+end_src

For FIXME to be highlighted in Org tables as well, use:

#+begin_src emacs-lisp :tangle no
  (defun fp-fontify-fixme ()
    (font-lock-add-keywords
     nil '(("\\<FIXME\\>" 0 font-lock-warning-face t)) t))
                                                       ^!!!
#+end_src

#+begin_src emacs-lisp
  ;; just-in-time fontification
  (with-eval-after-load "jit-lock"

    ;; stealth fontification should show status messages
    (setq jit-lock-stealth-verbose t))
#+end_src

#+begin_src emacs-lisp
  ;; colorize color names in buffers
  (GNUEmacs
    (when (locate-library "rainbow-mode")
      (autoload 'rainbow-mode "rainbow-mode"
        "Colorize strings that represent colors." t)))
#+end_src

** Interactive Highlighting

#+begin_src emacs-lisp
;;** 14.13 (info "(emacs)Highlight Interactively") by Matching

  (leuven--section "14.13 (emacs)Highlight Interactively by Matching")
#+end_src

You can use *Hi Lock* (part of Emacs since version 21) to highlight a regexp
(identical tokens) throughout a buffer.

- =M-x hi-lock-mode <RET>= ::
     Enable or disable Hi Lock mode.

- =C-x w h REGEXP <RET> <RET>= ::
     Highlight text that matches REGEXP.

- =C-x w l REGEXP <RET> <RET>= ::
     Highlight entire lines containing a match for REGEXP.

- =C-x w r REGEXP <RET>= ::
     Unhighlight REGEXP.

It is complementary to the features of the library *Highlight*:

- =hlt-highlight-regexp-region= ::
     Highlight a REGEXP throughout the region.

- =hlt-unhighlight-region= ::
     Unhighlight the region.

Comparison:

- Hi Lock uses text properties, Highlight can use either text properties or
  overlays (= default, see option =hlt-use-overlays-flag=). When overlays are
  used, copying and pasting text will not also paste the highlighting.

- Hi Lock highlights new text as you type it.

- Highlight lets you navigate among highlights:

  + =C-S-n= ::
       =hlt-next-highlight=.

  + =C-S-p= ::
       =hlt-previous-highlight=.

#+begin_src emacs-lisp
  (GNUEmacs
    (autoload 'hlt-highlight-regexp-region "highlight"
      "Highlight regular expression REGEXP in region." t)

    (defun leuven-hlt-highlight-current-word ()
      "Highlight the word that point is on throughout the buffer."
      (interactive)
      (let ((cword (current-word t)))
        (when cword
          (save-excursion
            (hlt-highlight-regexp-region (point-min) (point-max)
                                         (regexp-quote cword))))))

    ;; emulation of Vim's `*' search
    (global-set-key
      (kbd "C-*") 'leuven-hlt-highlight-current-word)

    (with-eval-after-load "highlight"
      (global-set-key
        (kbd "C-S-p") 'hlt-previous-highlight)
      (global-set-key
        (kbd "C-S-n") 'hlt-next-highlight)))
#+end_src

*************** TODO Improve word highlighting
- Use =highlight-symbol= which chooses rainbow colors automatically and makes it
  much easier to follow some key variables through a block of code.
- Use =C-*= to *unlight* if already highlighted.
*************** END

** Displaying Boundaries

#+begin_src emacs-lisp
;;** 14.15 (info "(emacs)Displaying Boundaries")

  (leuven--section "14.15 (emacs)Displaying Boundaries")

  ;; visually indicate buffer boundaries and scrolling
  (setq indicate-buffer-boundaries t)
#+end_src

** Useless Whitespace

#+begin_src emacs-lisp
;;** 14.16 (info "(emacs)Useless Whitespace")

  (leuven--section "14.16 (emacs)Useless Whitespace")

  ;; highlight trailing whitespaces in all modes
  (setq-default show-trailing-whitespace t)

  ;; delete all the trailing whitespaces and TABs across the current
  ;; buffer
  (defun leuven-delete-trailing-whitespaces-and-untabify ()
    "Delete all the trailing white spaces, and convert all TABs
  to multiple spaces across the current buffer."
    (interactive "*")
    (delete-trailing-whitespace)
    (untabify (point-min) (point-max)))

  ;; ensure that your files have no trailing whitespace
  (add-hook 'before-save-hook
            (lambda ()
              ;; except for Message mode where "-- " is the signature separator
              ;; (for when using emacsclient to compose emails and doing C-x #)
              (unless (eq major-mode 'message-mode)
                (delete-trailing-whitespace))))

  ;; visually indicate empty lines after the buffer end
  (setq-default indicate-empty-lines t)

  ;; ;; control highlighting of non-ASCII space and hyphen chars, using the
  ;; ;; `nobreak-space' or `escape-glyph' face respectively
  ;; (setq nobreak-char-display t) ;; default
#+end_src

When Whitespace mode is on, it takes care of highlighting some special
characters over the default mechanism of =nobreak-char-display= and
=show-trailing-whitespace=.

#+begin_src emacs-lisp
  (GNUEmacs
    ;; whitespace mode
    (add-hook 'text-mode-hook
              (lambda ()
                (whitespace-mode 1)))

    (add-hook 'prog-mode-hook
              (lambda ()
                (whitespace-mode 1)))

    (with-eval-after-load "whitespace"

      ;; which kind of blank is visualized
      (setq whitespace-style
            '(face trailing tabs
              ;; lines-tail
              indentation::space space-mark tab-mark))

      ;; column beyond which the line is highlighted
      (setq whitespace-line-column 80)

      ;; mappings for displaying characters
      (setq whitespace-display-mappings
            '((space-mark ?\xA0 [?\u00B7] [?.]) ;; hard space - centered dot
              (tab-mark ?\t [?\u00BB ?\t] [?\\ ?\t]))) ;; tab - left quote mark
      ))
#+end_src

Example:
VPATH=		/home/jt/src/cygwin/cygwin-packages/1.7/python-2.6.8-2/python-2.6.8-2/src/Python-2.6.8
LDLAST=
SGI_ABI=
PYTHON_OBJS=	\
		Python/pythonrun.o \
                Python/random.o \
		Python/structmember.o

#+begin_src emacs-lisp
  ;; ;; show zero-width spaces
  ;; (font-lock-add-keywords nil
  ;;  `((,(format "\\(%c\\)" ?\u200b) ; #\ZERO_WIDTH_SPACE
  ;;     (1 (progn (compose-region (match-beginning 1) (match-end 1)
  ;;                               ?\u2b1b ; #\BLACK_LARGE_SQUARE
  ;;                               'decompose-region)
  ;;               nil)))))
#+end_src

** Selective Display

Emacs has the ability to hide lines indented more than a given number of
columns. You can use this to get an overview of a part of a program.

To hide lines with at least 1 column of indentation, type =C-1 C-x $=. It gives
a quick overview any source file.

To make all lines visible again, type =C-x $= with no argument.

See also *Outline Mode* for another way to hide part of the text in a buffer.

** Optional Mode Line Features

#+begin_src emacs-lisp
;;** 14.18 (info "(emacs)Optional Mode Line") Features

  (leuven--section "14.18 (emacs)Optional Mode Line Features")

  ;; show the line number in each mode line
  (line-number-mode 1)

  ;; show the column number in each mode line
  (column-number-mode 1)

  ;; use inactive face for mode line in non-selected windows
  (setq mode-line-in-non-selected-windows t)
#+end_src

** How Text Is Displayed

#+begin_src emacs-lisp
;;** 14.19 How (info "(emacs)Text Display")ed

  (leuven--section "14.19 (emacs)How Text Displayed")

  (defun leuven-dos2unix ()
    "Convert a plain text file in DOS format to Unix format."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (search-forward "\r" nil t)
        (replace-match ""))))

  (defun leuven-unix2dos ()
    "Convert a plain text file in Unix format to DOS format."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (search-forward "\n" nil t)
        (replace-match "\r\n"))))
#+end_src

** Displaying the Cursor

#+begin_src emacs-lisp
;;** 14.20 The (info "(emacs)Cursor Display")

  (leuven--section "14.20 (emacs)The Cursor Display")

  ;; cursor of the selected window blinks
  (XEmacs
    (blink-cursor-mode))

  (GNUEmacs
    (defvar leuven-default-cursor-color "black"
      "Default cursor color.")

    ;; using cursor color to indicate some modes (read-only, overwrite and
    ;; insert modes)
    (defun leuven--set-cursor-color-according-to-mode ()
      "Change cursor color according to some minor modes."
      (let ((color (if buffer-read-only
                       "purple1"
                     (if overwrite-mode
                         "red"
                       ;; insert mode
                       leuven-default-cursor-color))))
        (set-cursor-color color)))

    (add-hook 'post-command-hook 'leuven--set-cursor-color-according-to-mode))
#+end_src

** Truncation of Lines

#+begin_src emacs-lisp
;;** 14.21 (info "(emacs)Line Truncation")

  (leuven--section "14.21 (emacs)Line Truncation")

  ;; switch wrap mode from "wrap long lines to next screen line" (continued
  ;; line) to "non-wrap", or vice-versa
  (global-set-key
    (kbd "C-c t") 'toggle-truncate-lines)

  ;; respect the value of `truncate-lines' in all windows less than the
  ;; full width of the frame
  (setq truncate-partial-width-windows nil)
#+end_src

** Customization of Display

#+begin_src emacs-lisp
;;** 14.23 (info "(emacs)Display Custom")ization

  (leuven--section "14.23 (emacs)Display Customization")

  ;; echo what I'm typing *immediately*
  (setq echo-keystrokes 0.1)
#+end_src

Display pressed keyboard shortcuts on screen during presentations or
screencasts.

#+begin_src emacs-lisp
  ;; exhaustive log of interactions with Emacs (display keystrokes, etc.)
  (with-eval-after-load "interaction-log"

    ;; ;; maximum number of lines to keep in the *Emacs Log* buffer
    ;; (setq ilog-log-max 10)

    ;; enable logging of keys, commands, file loads and messages
    (interaction-log-mode 1)

    ;; hotkey for showing the log buffer
    (global-set-key
      (kbd "C-h C-l")
      (lambda ()
        (interactive)
        (display-buffer ilog-buffer-name))))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 14 ends here
#+end_src

* Searching and Replacement

#+begin_src emacs-lisp
;;* 15 (info "(emacs)Search")ing and Replacement

(leuven--chapter leuven-chapter-15-search "15 Searching and Replacement"
#+end_src

** Incremental Search

Have a look at the "Standard Isearch Keys" on
http://www.emacswiki.org/emacs/IncrementalSearch

Isearch has a binding which deletes all the non-matching characters from the
search string: =C-g= (not a very intuitive binding, because it's usually
associated with aborting operations, not with correcting things).

If you hit =M-e= (to edit the search string), the cursor is moved to the
mismatch position.

Since Emacs 24.3:
- =M-s _= starts a symbol (identifier) incremental search.
- =M-s _= in Isearch toggles symbol search mode.
- =M-s c= in Isearch toggles search case-sensitivity.

#+begin_src emacs-lisp
;;** 15.1 (info "(emacs)Incremental Search")

  (leuven--section "15.1 (emacs)Incremental Search")

  ;; FIXME Error when selecting search string from kill ring (`M-p')
  ;; ;; always exit searches at the beginning of the expression found
  ;; (add-hook 'isearch-mode-end-hook 'isearch-goto-match-beginning)
  ;;
  ;; (defun isearch-goto-match-beginning ()
  ;;   "Use with isearch hook to end search at first char of match."
  ;;   (when isearch-forward (goto-char isearch-other-end)))

  (GNUEmacs
    ;; incremental search will open the contents
    (setq search-invisible 'open) ;; XXX

    ;; re-hide an invisible match right away
    (setq isearch-hide-immediately nil)) ;; XXX

  ;; scrolling commands are allowed during incremental search (without
  ;; canceling Isearch mode)
  (setq isearch-allow-scroll t)

  (GNUEmacs
    ;; fuzzy matching utilities (a must-have)
    (when (locate-library "fuzzy")

      (add-hook 'isearch-mode-hook
                (lambda ()
                  (require 'fuzzy)))

      (with-eval-after-load "fuzzy"
       (turn-on-fuzzy-isearch))))
#+end_src

You have to *quote the form you are passing to =eval-after-load=*, otherwise, the
form is evaluated on the spot.

** Regexp Search

Emacs uses basic regular expressions, which means that the extended regexp
operators have to be escaped. This means you have to use =\(=, =\|=, and =\)=
instead of =(=, =|=, and =)=.

You can build regexps with visual feedback by using:
- =M-x re-builder= or
- =M-x regex-tool= (by John Wiegley)

Optimize regexps with =regexp-opt.el=.

#+begin_src emacs-lisp
;;** 15.5 (info "(emacs)Regexp Search")

  (leuven--section "15.4 (emacs)Regexp Search")
#+end_src

#+begin_src emacs-lisp :tangle no
  ;; use regexps by default (allows searching across line breaks)
  (global-set-key
    (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key
    (kbd "C-r") 'isearch-backward-regexp)

  ;; shift the meaning of `C-M-s/r'
  (global-set-key
    (kbd "C-M-s") 'isearch-forward)
  (global-set-key
    (kbd "C-M-r") 'isearch-backward)
#+end_src

*** IELM                                                             :noexport:

In IELM, list the input line, followed by the first nine substrings matches,
to debug regexp searches (in IELM)

Example:

#+begin_example
ELISP> (save-excursion (set-buffer "BUFFER")
                       (re-search-forward "REGEXP" nil t)
                       (leuven--buffer-matched-strings))
#+end_example

#+begin_src emacs-lisp
  (defun leuven--buffer-matched-strings ()
    (interactive)
    (mapcar 'leuven--buffer-matched-string-nth '(0 1 2 3 4 5 6 7 8 9)))

  (defun leuven--buffer-matched-string-nth (n)
    "Return the Nth pattern-matched string from the current buffer."
    (if (and (match-beginning n) (match-end n))
        (if (> (match-end n) (match-beginning n))
            (buffer-substring (match-beginning n) (match-end n))
          "")
      nil))
#+end_src

** Search Case

#+begin_src emacs-lisp
;;** 15.9 (info "(emacs)Search Case")

  (leuven--section "15.8 (emacs)Search Case")

  ;; searches should ignore case by default (in all buffers that do not
  ;; override this)
  (setq-default case-fold-search t)
#+end_src

** Replacement Commands

Pass the string or the regexp directly to =query-replace=, so you can't mangle
it on the way, by pressing =M-%= while at the =I-search:= prompt.

** Other Search-and-Loop Commands

=M-x flush-lines= (or =delete-matching-lines=) deletes each line that contains a
match for REGEXP.

#+begin_src emacs-lisp
;;** 15.11 (info "(emacs)Other Repeating Search") Commands

  (leuven--section "15.10 (emacs)Other Repeating Search Commands")

  (defun leuven--isearch-occur ()
    "Invoke `occur' from within isearch."
    (interactive)
    (let ((case-fold-search isearch-case-fold-search))
      (occur
       (if isearch-regexp
           isearch-string
         (regexp-quote isearch-string)))))

  ;; activate `occur' easily while at the `I-search:' prompt
  (define-key isearch-mode-map
    (kbd "C-o") 'leuven--isearch-occur)

  ;; activate `occur' easily globally
  (global-set-key
    (kbd "C-o") 'occur)                 ; [default: "M-s o"]
#+end_src

Occur Edit mode applies edits made in =*Occur*= buffers to the original buffers.
It is bound to =e= in Occur mode.

*** Multi-buffer occur

*************** TODO Have a look at http://www.emacswiki.org/emacs/color-moccur.el for searching regexp in buffer

#+begin_src emacs-lisp
  (when (locate-library "color-moccur")

    ;; multi-buffer occur (grep) mode
    (mapc (function
           (lambda (x)
             (autoload x "color-moccur" nil t)))
          '(moccur
            dmoccur
            dired-do-moccur
            Buffer-menu-moccur
            grep-buffers
            search-buffers
            occur-by-moccur
            isearch-moccur
            moccur-grep
            moccur-grep-find)))

  ;; multi-buffer occur (grep) mode
  (with-eval-after-load "color-moccur"

    ;; input word splited by space
    (setq moccur-split-word t))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 15 ends here
#+end_src

* Commands for Fixing Typos

#+begin_src emacs-lisp
;;* 16 Commands for (info "(emacs)Fixit") Typos

(leuven--chapter leuven-chapter-16-fixit "16 Commands for Fixing Typos"
#+end_src

** Checking and Correcting Spelling

*************** Install [[http://ftp.gnu.org/gnu/aspell/w32/Aspell-0-50-3-3-Setup.exe][GNU Aspell 0.50.3]] on Windows (more dictionaries than Cygwin Aspell)
- Install [[http://ftp.gnu.org/gnu/aspell/w32/Aspell-en-0.50-2-3.exe][Aspell English dictionary-0.50-2]]
- Add =C:\Program Files (x86)\Aspell\bin= to the System =PATH=
*************** END

GNU *Aspell* is better than *Ispell*:

- It does recognize words with apostrophes (l'avion)... but it is slower.

- It can handle UTF-8 documents far better than Ispell can.

See [[https://github.com/rolandwalker/flyspell-lazy][Flyspell-lazy]] if you are experiencing performance issues with Emacs'
built-in =flyspell-mode=.

When spellchecking a buffer, the =A= command accepts an incorrect word, and adds
it to the *file word list* (=ispell-add-per-file-word-list=).

#+begin_src emacs-lisp
;;** 16.4 Checking and Correcting (info "(emacs)Spelling")

  (leuven--section "16.4 (emacs)Checking and Correcting Spelling")

  ;; spelling checker program
  (setq ispell-program-name ;; XXX undefined
        (or (executable-find "aspell")
            (executable-find "ispell")
            ;; nil                         ; [default: "ispell"]
            ))

  ;; check if `ispell-program-name' seems correct
  (defun ispell-check-program-name ()
    "Ensure that `ispell-program-name' is defined and non-nil."
    (interactive)
    (and (boundp 'ispell-program-name)
         ispell-program-name))

  (when (ispell-check-program-name)

    (defun ispell-region-or-buffer ()
      "Interactively check the current region or buffer for spelling errors."
      (interactive)
      (if mark-active
          (if (< (mark) (point))
              (ispell-region (mark) (point))
              (ispell-region (point) (mark)))
          (ispell-buffer)))

    ;; key bindings (or `C-c i' prefix key binding?)
    (global-set-key
      (kbd "C-$") 'ispell-region-or-buffer)
    (global-set-key
      (kbd "C-M-$") 'ispell-change-dictionary)

    ;; ;; default dictionary to use (if `ispell-local-dictionary' is nil, that is
    ;; ;; if there is no local dictionary to use in the buffer)
    ;; (setq ispell-dictionary "american")

    ;; enable on-the-fly spell checking
    (add-hook 'text-mode-hook
              (lambda ()
                (flyspell-mode 1)))

    ;; prevent flyspell from finding mistakes in the code, which is pretty cool
    (add-hook 'prog-mode-hook
              (lambda ()
                ;; `ispell-comments-and-strings'
                (flyspell-prog-mode)))

    (with-eval-after-load "ispell"

     ;; save the personal dictionary without confirmation
     (setq ispell-silently-savep t)
#+end_src

#+begin_src emacs-lisp
     ;; extensions and extra switches to pass to the `ispell' program
     (cond
#+end_src

Tell =aspell= to speed up, though this reduces somewhat the quality of its
suggestions. According to the =aspell= documentation:

- "ultra" is the fastest suggestion mode, which is still twice as slow as
  =ispell=.

- If your machine is fast enough, a better option might be to try "fast" mode,
  which is twice as slow as "ultra", but more accurate.

- The "normal" mode, which is the =aspell= default, is even more accurate, but
  is reportedly 10 times slower than "fast" mode.

Use the =-C= option which will ConsiderCamelCaseToBeCorrect.

#+begin_src emacs-lisp
      ((string-match "aspell" ispell-program-name)
       (setq ispell-extra-args '("--sug-mode=ultra" "-C"))
       (setq ispell-really-aspell t)
       (setq ispell-really-hunspell nil))
#+end_src

#+begin_src emacs-lisp
      ((string-match "ispell" ispell-program-name)
       (setq ispell-extra-args '())
       (setq ispell-really-aspell nil)
       (setq ispell-really-hunspell nil)))
#+end_src

#+begin_src emacs-lisp :tangle no
     ;; ;; solve the problem of words separated by `-' flagged as
     ;; ;; erroneous by removing the `-' from the value of otherchars
     ;; (if (fboundp 'ispell-get-decoded-string)
     ;;     (defun ispell-get-otherchars ()
     ;;       (replace-regexp-in-string "-" "" (ispell-get-decoded-string 3))))
#+end_src

Add language indicator.

#+begin_src emacs-lisp
     (setq-default mode-line-format
                   (cons
                    '(:eval
                      (let ((dict (and (featurep 'ispell)
                                       (or ispell-local-dictionary
                                           ispell-dictionary))))
                        (and dict
                             (propertize (concat " [" (substring dict 0 2) "]")
                                         'face 'mode-line-highlight))))
                    (default-value 'mode-line-format)))
#+end_src

#+begin_src emacs-lisp
     )
#+end_src

=flyspell-auto-correct-word= is bound to =C-.=. Press it one time to correct the
word under the cursor. If several spellings are possible, they appear in the
minibuffer. Just keep hitting =C-.= to replace the word with the successive
suggestions.

=flyspell-goto-next-error= is bound to "C-,". Press it to go to the next
previously detected error.

=flyspell-correct-word-before-point= is bound to =C-c $=. Press it to *pop up a menu*
of possible corrections for misspelled word before point.

#+begin_src emacs-lisp
    ;; don't use `M-TAB' to auto-correct the current word (only use `C-.')
    (setq flyspell-use-meta-tab nil)
    ;; FIXME M-TAB is still bound to `flyspell-auto-correct-word' when this
    ;; chunk of code is placed within (with-eval-after-load "flyspell"...)

    (with-eval-after-load "flyspell"

     ;; don't consider that a word repeated twice is an error
     (setq flyspell-mark-duplications-flag nil)

     ;; fix the "enabling flyspell mode gave an error" bug
     (setq flyspell-issue-welcome-flag nil)

     ;; ;; don't print messages for every word (when checking the entire buffer)
     ;; ;; as it causes a (small) slowdown
     ;; (setq flyspell-issue-message-flag nil)

     ;; dash character (`-') is considered as a word delimiter
     (setq-default flyspell-consider-dash-as-word-delimiter-flag t)
     ;; '("francais" "deutsch8" "norsk")

     ;; spell-check your XHTML (by adding `nxml-text-face' to the list of
     ;; faces corresponding to text in programming-mode buffers)
     (add-to-list 'flyspell-prog-text-faces 'nxml-text-face)

     (defun leuven-flyspell-toggle-dictionary ()
       "Toggle the local dictionary between French and US English."
       (interactive)
       (let ((dict (or ispell-local-dictionary
                       ispell-dictionary)))
         (setq dict (if (string= dict "francais") "american" "francais"))
         (message "Switched to %S" dict)
         (sit-for 0.5)
         (ispell-change-dictionary dict)
         (force-mode-line-update)
         (when flyspell-mode
           ;; (flyspell-delete-all-overlays)
           ;; if above is executed, the advised `org-mode-flyspell-verify'
           ;; won't work anymore
           (flyspell-buffer))))

     ;; key binding
     (global-set-key
       (kbd "C-$") 'flyspell-buffer)
     (global-set-key
       (kbd "C-M-$") 'leuven-flyspell-toggle-dictionary)))
#+end_src

*************** TODO Have a look at `diction' (style and grammar for English)

#+begin_src emacs-lisp
  (when (locate-library "dictionary-init")

     ;; ;; autoloads
     ;; (load-library "dictionary-init")

     (autoload 'dictionary-search "dictionary"
       "Ask for a word and search it in all dictionaries." t)
     (autoload 'dictionary-match-words "dictionary"
       "Ask for a word and search all matching words in the dictionaries." t)
     (autoload 'dictionary-lookup-definition "dictionary"
       "Unconditionally lookup the word at point." t)

     (autoload 'dictionary "dictionary"
       "Create a new dictionary buffer." t)
     (autoload 'dictionary-mouse-popup-matching-words "dictionary"
       "Display entries matching the word at the cursor." t)
     (autoload 'dictionary-popup-matching-words "dictionary"
       "Display entries matching the word at the point." t)
     (autoload 'dictionary-tooltip-mode "dictionary"
       "Display tooltips for the current word." t)
     (unless (boundp 'running-xemacs)
       (autoload 'global-dictionary-tooltip-mode "dictionary"
         "Enable/disable dictionary-tooltip-mode for all buffers." t))

     (global-set-key
       (kbd "C-c d l") 'dictionary-lookup-definition)
     (global-set-key
       (kbd "C-c d s") 'dictionary-search)
     (global-set-key
       (kbd "C-c d m") 'dictionary-match-words)

     (with-eval-after-load "dictionary"

      (global-dictionary-tooltip-mode 1)

      ;; ;; server contacted for searching the dictionary
      ;; (setq dictionary-server "localhost")

      ;; ;; connect via a HTTP proxy (using the CONNECT command)
      ;; (setq dictionary-use-http-proxy t)
      ;;
      ;; ;; name of the HTTP proxy to use
      ;; (setq dictionary-proxy-server "hellman") ; XXX
      ;;
      ;; ;; port of the proxy server
      ;; (setq dictionary-proxy-port 8080) ; XXX

      ;; use proxy
      (setq url-proxy-services
            ;;! Emacs expects just hostname and port in `url-proxy-services',
            ;;! NOT prefixed with "http://"
            `(("http"     . ,(getenv "http_proxy"))
              ("ftp"      . ,(getenv "http_proxy"))
              ("no_proxy" . "^.*example.com")))
              ;; disable proxy for some hosts
     ))
#+end_src

#+begin_src emacs-lisp
  ;; XXX excellent!
  (defun leuven-answers-define ()
    "Look up the word under cursor in a browser."
    (interactive)
    (browse-url
     (concat "http://www.answers.com/main/ntquery?s=" (find-tag-default))))

  (defun leuven-lookup-word-definition-in-w3m ()
    "Look up the word's definition in a emacs-w3m.

  If a region is active (a phrase), lookup that phrase."
    (interactive)
    (let (word
          url)
      (setq word
            (if (use-region-p)
                (buffer-substring-no-properties (region-beginning)
                                                (region-end))
              (find-tag-default)))
      (setq word (replace-regexp-in-string " " "%20" word))
      (setq url (concat "http://www.answers.com/main/ntquery?s=" word))
      (w3m-browse-url url)))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 16 ends here
#+end_src

* Keyboard Macros

#+begin_src emacs-lisp
;;* 17 (info "(emacs)Keyboard Macros")

(leuven--chapter leuven-chapter-17-keyboard-macros "17 Keyboard Macros"
#+end_src

** Basic Use

- =<S-f8>= ::
     Start recording your keyboard macro.

- =<S-f8>= again ::
     Stop recording it.

- =<f8>= ::
     Call the keyboard macro.

If you want to check the result each time before repeating, type =<f8> e e...=.

If you want to repeat only N times, type =C-u N <f8>=.

If you want to repeat forever or until error, type =C-u 0 <f8>=.

#+begin_src emacs-lisp
;;** 17.1 (info "(emacs)Basic Keyboard Macro") Use

  (leuven--section "17.1 (emacs)Basic Keyboard Macro Use")

  (defun leuven-kmacro-turn-on-recording ()
    "Start recording a keyboard macro and toggle functionality of key binding."
    (interactive)
    (global-set-key
      (kbd "<S-f8>") 'leuven-kmacro-turn-off-recording)
    (kmacro-start-macro nil))

  (defun leuven-kmacro-turn-off-recording ()
    "Stop recording a keyboard macro and toggle functionality of key binding."
    (interactive)
    (global-set-key
      (kbd "<S-f8>") 'leuven-kmacro-turn-on-recording)
    (kmacro-end-macro nil))

  ;; start/stop recording a keyboard macro
  (global-set-key
    (kbd "<S-f8>") 'leuven-kmacro-turn-on-recording)

  ;; execute the most recent keyboard macro
  (global-set-key
    (kbd "<f8>") 'kmacro-call-macro)
#+end_src

** Naming and Saving Keyboard Macros

- =<C-f8>= ::
     Give the keyboard macro a name (to invoke it under that name).

Assign the last macro to a free key binding of your choice with
=kmacro-bind-to-key= (bound to =C-x C-k b=).

To save a named keyboard macro (with its key binding) for future use, switch to
your ~.emacs~ buffer, and run =C-u M-x insert-kbd-macro= (if you leave out the =C-u=,
then it will just insert the macro definition without the =global-set-key=
sequence).

#+begin_src emacs-lisp
;;** 17.5 Name and (info "(emacs)Save Keyboard Macro")s

  (leuven--section "17.5 (emacs)Name and Save Keyboard Macros")

  ;; assign a name to the last keyboard macro defined
  (global-set-key
    (kbd "<C-f8>") 'kmacro-name-last-macro)
#+end_src

#+begin_src emacs-lisp
) ;; chapter 17 ends here
#+end_src

* Files Handling

#+begin_src emacs-lisp
;;* 18 (info "(emacs)Files") Handling

(leuven--chapter leuven-chapter-18-files "18 Files Handling"
#+end_src

** Visiting Files

#+begin_src emacs-lisp
;;** 18.2 (info "(emacs)Visiting") Files

  (leuven--section "18.2 (emacs)Visiting Files")

  ;; visit a file
  (global-set-key
    (kbd "<f3>") 'find-file)
#+end_src

** Saving Files

#+begin_src emacs-lisp
;;** 18.3 (info "(emacs)Saving") Files

  (leuven--section "18.3 (emacs)Saving Files")

  ;; make your changes permanent
  (global-set-key
    (kbd "<f2>") 'save-buffer)

  ;; ensure a file ends in a newline when it is saved
  (setq require-final-newline t)
  ;; TODO Do this only for text and Fundamental modes, because I could
  ;; edit binary files (see `mode-require-final-newline')

  ;; directory used for temporary files
  (XEmacs
    (setq temporary-file-directory
          (or (file-name-as-directory (getenv "TEMP"))
              "/tmp/")))

  ;; update time stamps every time you save a buffer
  (add-hook 'before-save-hook 'time-stamp)

  ;; maintain last change time stamps (`Time-stamp: <>' occurring within
  ;; the first 8 lines) in files edited by Emacs
  (with-eval-after-load "time-stamp"

   ;; format of the string inserted by `M-x time-stamp':
   ;; `YYYY-MM-DD Weekday HH:MM' (see `system-time-locale' for non-numeric
   ;; formatted items of time)
   (setq-default time-stamp-format "%:y-%02m-%02d %3a %02H:%02M"))

  (GNUEmacs
    ;; update the copyright notice in current buffer
    (add-hook 'before-save-hook 'copyright-update))
#+end_src

For Org buffers, add an enhanced version of =save-buffer= which does:

1. Save buffer (updating dynamic blocks and tables)
2. Execute the code blocks, and save another time
3. Tangle code blocks, if any to be tangled
4. Export to HTML and PDF, if such files already exist
5. Call =send-patch=?

Notes:
- Use the asynchronous export (if possible, so that I don't loose time, or let
  it open to the value of that var)?
- Different behaviors can be obtained with =C-u= (or =C-u C-u=)

Why not adding a recursive functionality as well (in Emacs Lisp too), to be
launched from Dired?

#+begin_src emacs-lisp
  (defun org-save-buffer-and-do-related ()
    "Save buffer, execute/tangle code blocks, and export to HTML/PDF."
    (interactive)
    (let* ((orgfile (buffer-file-name))
           (base-name (file-name-base orgfile))
           (htmlfile (concat base-name ".html"))
           (pdffile (concat base-name ".pdf")))
      (save-buffer)                     ; see other commands in `before-save-hook':
                                        ; `org-update-all-dblocks'
                                        ; `org-table-iterate-buffer-tables'
      (when (derived-mode-p 'org-mode)
        (org-babel-execute-buffer)
        (let ((before-save-hook nil))
          (save-buffer))
        (org-babel-tangle)
        (when (file-exists-p htmlfile)
          (if (file-newer-than-file-p orgfile htmlfile)
              (org-html-export-to-html)
            (message "HTML is up to date with Org file")))
        (when (file-exists-p pdffile)
          (if (file-newer-than-file-p orgfile pdffile)
              (org-latex-export-to-pdf)
            (message "PDF is up to date with Org file")))
        (beep))))

  (global-set-key
    (kbd "<S-f2>") 'org-save-buffer-and-do-related)

  (global-set-key
    (kbd "C-x C-S-s") 'org-save-buffer-and-do-related)
#+end_src

** Reverting a Buffer

#+begin_src emacs-lisp
;;** 18.4 (info "(emacs)Reverting") a Buffer

  (leuven--section "18.4 (emacs)Reverting a Buffer")

  ;; replace current buffer text with the text of the visited file on disk
  (defun leuven-revert-buffer-without-query ()
    "Unconditionally revert current buffer."
    (interactive)
    (revert-buffer t t)                 ; ignore-auto(-save), noconfirm
    (message "Buffer is up to date with file on disk"))

  ;; key binding
  (global-set-key
    (kbd "<C-f12>") 'leuven-revert-buffer-without-query)
#+end_src

** Auto-Saving: Protection Against Disasters

How to get Emacs to auto-save to your local disk (=#file#=).

#+begin_src emacs-lisp
;;** 18.6 (info "(emacs)Auto Save"): Protection Against Disasters

  (leuven--section "18.6 (emacs)Auto Save: Protection Against Disasters")

  ;; auto-save every 100 input events
  (setq auto-save-interval 100)

  ;; auto-save after 10 seconds idle time
  (setq auto-save-timeout 10)

  ;; save backup files (i.e., `foo~' or `foo.~i~') in one common directory
  ;; (instead of in the local directory)
  (GNUEmacs
    ;; filenames matching a regexp are backed up in the corresponding
    ;; directory
    (setq backup-directory-alist
          ;; Emacs will `make-directory' it, if necessary
          '((".*" . "~/.emacs.d/backups/")))) ;; regexp => directory mappings

  (XEmacs
    (when (try-require 'backup-dir)
      ;; FIXME Use a `set' construction, with `make-local-variable'
      (make-variable-buffer-local 'backup-inhibited)
      (setq bkup-backup-directory-info
            '((t "~/.saves" ok-create full-path prepend-name)))))

  ;; always use copying to create backup files (don't clobber symlinks)
  (setq backup-by-copying t)

  ;; make numbered backups
  (setq version-control t)

  ;; ;; number of oldest versions to keep when a new numbered backup is made
  ;; (setq kept-old-versions 0) ;; 2

  ;; number of newest versions to keep when a new numbered backup is made
  (setq kept-new-versions 20) ;; 2

  ;; delete excess backup versions silently
  (setq delete-old-versions t)
#+end_src

Disable backups and auto-save only in the current buffer with =M-x
sensitive-mode=:

#+begin_src emacs-lisp
  (define-minor-mode sensitive-mode
    "For sensitive files like password lists.
  It disables backup creation and auto saving in the current buffer.

  With no argument, this command toggles the mode. Non-null
  prefix argument turns on the mode. Null prefix argument
  turns off the mode."
    nil ;; initial value
    " Sensitive" ;; indicator for the mode line
    nil ;; minor mode bindings
    (if (symbol-value sensitive-mode)
        (progn
          ;; disable backups
          (set (make-local-variable 'backup-inhibited) t)
          ;; disable auto-save
          (if auto-save-default
              (auto-save-mode -1)))
      ;; resort to default value of backup-inhibited
      (kill-local-variable 'backup-inhibited)
      ;; resort to default auto save setting
      (if auto-save-default
          (auto-save-mode 1))))
#+end_src

Make the message "/FILENAME has auto save data/" unmissable:

#+begin_src emacs-lisp
  (defface recover-this-file
    '((t (:weight bold :background "#FF3F3F")))
    "Face for buffers visiting files with auto save data."
    :group 'files)

  (defvar leuven--recover-this-file nil
    "If non-nil, an overlay indicating that the visited file has auto save data.")

  (defun leuven--recover-this-file ()
    (let ((warn (not buffer-read-only)))
      (when (and warn
                 ;; no need to warn if buffer is auto-saved under the name of
                 ;; the visited file
                 (not (and buffer-file-name
                           auto-save-visited-file-name))
                 (file-newer-than-file-p (or buffer-auto-save-file-name
                                             (make-auto-save-file-name))
                                         buffer-file-name))
        (set (make-local-variable 'leuven--recover-this-file)
             (make-overlay (point-min) (point-max)))
        (overlay-put leuven--recover-this-file
                     'face 'recover-this-file))))

  (add-hook 'find-file-hook 'leuven--recover-this-file)
#+end_src

** Comparing Files

#+begin_src emacs-lisp
;;** 18.9 (info "(emacs)Comparing Files")

  (leuven--section "18.9 (emacs)Comparing Files")

  ;; default to unified diffs
  (setq diff-switches "-u")

  ;; compare text in current window with text in next window
  (global-set-key
    (kbd "C-=") 'compare-windows)
#+end_src

You can use =M-x smerge-mode= to edit a file with conflict markers (output from
the =diff3= program). Smerge does not automatically select regions but provides
convenient key bindings to navigate between conflicts and to choose the A or B
variant.

** Diff Mode

In Diff mode, I can *select a hunk and apply it (in reverse)*. Nice following
=C-x v == to show what's changed, and decide to reverse a change.

#+begin_src emacs-lisp
;;** 18.10 (info "(emacs)Diff Mode")

  (leuven--section "18.10 (emacs)Diff Mode")

  ;; extensions to `diff-mode' ("*Diff*" buffer is highlighted differently)
  (try-require 'diff-mode-)
  ;; this library should be loaded *before* library `diff-mode'

  ;; mode for viewing/editing context diffs
  (with-eval-after-load "diff-mode"

    ;; highlight the changes with better granularity
    (defun leuven--diff-make-fine-diffs ()
      "Enable Diff Auto Refine mode."
      (interactive)
      (let (diff-auto-refine-mode)
        (condition-case nil
            (save-excursion
              (goto-char (point-min))
              (while (not (eobp))
                (diff-hunk-next)
                (diff-refine-hunk)))
          (error nil))
        (run-at-time 0.0 nil
                     (lambda ()
                       (if (eq major-mode 'diff-mode)
                           ;; put back the cursor only if still in a diff buffer
                           ;; after the delay
                           (goto-char (point-min)))))))

    (defun leuven--diff-make-fine-diffs-if-necessary ()
      "Auto-refine only the regions of 14,000 bytes or less."
      ;; check for auto-refine limit
      (unless (> (buffer-size) 14000)
        (leuven--diff-make-fine-diffs)))

    (add-hook 'diff-mode-hook
              'leuven--diff-make-fine-diffs-if-necessary))
#+end_src

To compare 2 text files, you can also use Ediff if the following command
works.

: M-: (executable-find "diff") RET

In Ediff, press:

- =?= to get help

- =|= to change from vertical window layout to horizontal window layout, and
  vice versa

- =a= or =b= key to merge the code from A to B or from B to A

- =ra= or =rb= to revert your change

#+begin_src emacs-lisp
  ;; ;; ediff, a comprehensive visual interface to diff & patch
  ;; ;; setup for Ediff's menus and autoloads
  ;; (try-require 'ediff-hook)
  ;; already loaded (by Emacs?)

  (with-eval-after-load "ediff"

    ;; skip over difference regions that differ only in white space and line
    ;; breaks
    ;; (setq-default ediff-ignore-similar-regions  t)
    ;; XXX Make another key binding (than `E') with that value in a let-bind

    ;; sometimes grab the mouse and put it in the control frame
    (setq ediff-grab-mouse 'maybe)

    ;; do everything in one frame
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)

    ;; split the window (horizontally or vertically) depending on the frame
    ;; width
    (setq ediff-split-window-function
          (lambda (&optional arg)
            (if (> (frame-width) 160)
                (split-window-horizontally arg)
              (split-window-vertically
               arg)))))
#+end_src

For *comparing two directories*, you can use =ediff-directories= or [[http://meldmerge.org/][Meld]].

=ediff-directories= combined with the key sequence "= h x" shows you only the
files which differ.

It is not recursive, but it gives you also subdirectory pairs to compare. Just
hit =RET= on such a pair.

As bonus, it even works for remote directories.

CAUTION -- =ediff-directories= does not list files in one directory with no
corresponding files in the other directory.

** Miscellaneous File Operations

#+begin_src emacs-lisp
;;** 18.11 (info "(emacs)Misc File Ops")

  (leuven--section "18.11 (emacs)Misc File Ops")

  ;; use the system's Trash (when it is available)
  (setq delete-by-moving-to-trash t)
#+end_src

** Accessing Compressed Files

- Display the *contents* of the archive
- *View or edit* the actual files contained withing the archive

Using the Emacs Dired utility, you can compress or uncompress a file by
pressing =Z=.

*** On Windows                                                       :noexport:

On Windows, if you are trying to use =gunzip= to uncompress a file under Dired,
you will probably encounter errors.

The problem is due to that =gunzip= provided by Cygwin is not an executable
file. It is a *symbolic link to =gzip=*; you can verify this by =ls -l
/usr/bin/gunzip=.

Since *GNU Emacs does not understand Cygwin's symbolic links*, it cannot execute
=gunzip=. The solution is to replace =gunzip= with =gzip -d=.

#+begin_src sh :tangle ~/bin/gunzip :padline no
#!/bin/sh
# gunzip -- gunzip solution on Windows

PATH=${GZIP_BINDIR-'/usr/bin'}:$PATH
exec gzip -d "$@"

# gunzip ends here
#+end_src

** Auto Encryption

History:

1. mailcrypt

2. PGG

3. EasyPG (= epg) is a GnuPG interface for Emacs.

   It allows you to encrypt/decrypt files within Emacs. When you use =C-x C-f= to
   access an encrypted file, Emacs prompts you for the passphrase and then
   decrypts the file before displaying it. When you save the file, Emacs
   automatically encrypts it again with that same key.

   It has two aspects:

   - convenient tools which allow to use GnuPG from Emacs (EasyPG Assistant),
     and

   - a fully functional interface library to GnuPG (EasyPG Library).

*************** TODO Fetch the key automatically
Set the =keyserver= entry in the =~/.gnupg/gpg.conf= file properly.
*************** END

What is PGP/MIME, what is OpenPGP, and how Gnus handles them?
- PGP/MIME is a standard, which mml2015* implements using ep[ag]-*.
- OpenPGP is a standard, which ep[ag]-* implements.

#+begin_src emacs-lisp
  ;; the EasyPG Assistant, transparent file encryption
  (with-eval-after-load "epa-file"

    ;; stop EasyPG from asking for the recipient used for encrypting files
    (setq epa-file-encrypt-to "john@doe.com")
    ;; if no one is selected (""), symmetric encryption will always be
    ;; performed

    ;; cache passphrase for symmetric encryption (VERY important)
    (setq epa-file-cache-passphrase-for-symmetric-encryption t)
    ;; Not to sound paranoid. But if you want caching, it's recommended to
    ;; use *public-key encryption* instead of symmetric encryption.
    ;; `gpg-agent' is the preferred way to do this.

    ;; prompt for the password in the Emacs minibuffer (instead of using a
    ;; graphical password prompt for GPG)
    (setenv "GPG_AGENT_INFO" nil))
#+end_src

** Remote Files

#+begin_src emacs-lisp
;;** 18.14 (info "(emacs)Remote Files")

  (leuven--section "18.14 (emacs)Remote Files")
#+end_src

*** Ange-FTP

*************** TODO Check out why network share aren't accessible
I should be able to open //CAUCHY/fsd/...
*************** END

#+begin_src emacs-lisp
;;*** Ange-FTP

  (leuven--section "Ange-FTP")

  ;; transparent FTP support
  (with-eval-after-load "ange-ftp"

    ;; try to use passive mode in ftp, if the client program supports it
    (setq ange-ftp-try-passive-mode t)) ;; needed for Ubuntu
#+end_src

*** TRAMP

(other protocols than just FTP)

=/method:user@host:/path/file=

Examples:
- =C-x C-f /ssh:user@host:/home/user/.bashrc=
- =C-x C-f /plink:user@host:/home/user/.bashrc= (from Windows)
- =C-x C-f /sudo:root@localhost:/etc/group=

Also =M-x find-dired=, =rgrep=, =lgrep=, =compile -= properly work with TRAMP (run on
remote server and show result in your Emacs).

Note -- `sshfs' can give me the same functionality as TRAMP: it is like a
personal NFS (another mounted file system) over SSH. If you can SSH to a
server, you can probably do `sshfs'.

> I'm in shell mode, logged in on another machine over ssh, and I want to do
> some 'crontab -e' editing on that machine. But that will bring up a new
> editor, which is whatever you set in your EDITOR env variable, and both vi
> and emacs cannot be used in this dumb shell. How can I edit the crontab in
> my emacs session?

Create the crontab on the remote machine, open it using TRAMP from your
machine, edit and save and then reinstall it. That or simply enable X
forwarding so running emacs on the remote bring up Emacs gtk/x on your main
machine editing your cron file on the remote.

#+begin_src emacs-lisp
;;*** TRAMP - Transparent Remote Access, Multiple Protocols

  (leuven--section "TRAMP")

  (with-eval-after-load "tramp" ;; the autoloads are predefined

;;* 4 (info "(tramp)Configuration") of TRAMP for use

;;** 4.6 Selecting a (info "(tramp)Default Method")

    ;; default transfer method
    (setq tramp-default-method          ; [default: "scp"]
          (cond (running-ms-windows
                 ;; (issues with Cygwin `ssh' which does not cooperate
                 ;; with Emacs processes -> use `plink' from PuTTY, it
                 ;; definitely does work under Windows)
                 ;;
                 ;; `C-x C-f /plink:user@host:/some/directory/file'
                 "plink")
                (t
                 "ssh")))

    ;; You might try out the `rsync' method, which saves the remote
    ;; files quite a bit faster than SSH. It's based on SSH, so it
    ;; works the same, just saves faster.

    ;; ;; 2011-07-25 New test on Windows XP
    ;; (setq tramp-default-method "ssh")
    ;;
    ;; (nconc (cadr (assq 'tramp-login-args (assoc "ssh" tramp-methods)))
    ;;        '(("bash" "-i")))
    ;; (setcdr (assq 'tramp-remote-sh (assoc "ssh" tramp-methods))
    ;;         '("bash -i"))

;;** 4.9 Connecting to a remote host using (info "(tramp)Multi-hops")

    ;; new proxy system (introduced with Tramp 2.1, instead of the old
    ;; "multi-hop" filename syntax) to edit files on a remote server by
    ;; going via another server
    (when (boundp 'tramp-default-proxies-alist)
      (add-to-list 'tramp-default-proxies-alist
                   ;; "final host" "user" "proxy in the middle"
                   '("10.10.13.123" "\\`root\\'" "/ssh:%h:")))
    ;; Opening `/sudo:10.10.13.123:' would connect first `10.10.13.123'
    ;; via `ssh' under your account name, and perform `sudo -u root' on
    ;; that host afterwards. It is important to know that the given
    ;; method is applied on the host which has been reached so far. The
    ;; trick is to think from the end.

;;** 4.12 (info "(tramp)Password handling") for several connections

    ;; how many seconds passwords are cached
    (setq password-cache-expiry 60)     ; [default: 16]

;;** 4.15 (info "(tramp)Remote shell setup") hints

    ;; string used for end of line in rsh connections
    (setq tramp-rsh-end-of-line         ; [default: "\n"]
          (cond (running-ms-windows "\n")
                (t "\r")))

;;** 4.16 (info "(tramp)Auto-save and Backup") configuration

    ;; faster auto saves
    (setq tramp-auto-save-directory temporary-file-directory)
#+end_src

The usual way to debug Tramp is to set =tramp-verbose= to 6. This will produce a
debug buffer, which you can show at ~tramp-devel@gnu.org~.

The best way to report a Tramp bug is to call =M-x tramp-bug=; this prepares an
email, including several trace information for analysis.

#+begin_src emacs-lisp
;;* 9 How to Customize (info "(tramp)Traces and Profiles")

    ;; debugging Tramp
    (setq tramp-verbose 6) ;; [maximum: 10]

    ;; "turn off" the effect of `backup-directory-alist' for TRAMP
    ;; files
    (add-to-list 'backup-directory-alist
                 (cons tramp-file-name-regexp nil))

    ;; make Emacs beep after reading from or writing to the remote host
    (defadvice tramp-handle-write-region ;; XXX
      (after leuven-tramp-write-beep-advice activate)
      "Make Tramp beep after writing a file."
      (interactive)
      (beep))

    (defadvice tramp-handle-do-copy-or-rename-file ;; XXX
      (after leuven-tramp-copy-beep-advice activate)
      "Make Tramp beep after copying a file."
      (interactive)
      (beep))

    (defadvice tramp-handle-insert-file-contents
      (after leuven-tramp-insert-beep-advice activate)
      "Make Tramp beep after inserting contents of a file."
      (interactive)
      (beep))
#+end_src

*** TEST Find file as root

You can just do =C-x C-f /sudo:user@localhost:/foo/bar/baz.txt <RET>=.

Because I'm lazy, I have a hack (from Tassilo Horn): if I try to open a file
for which I don't have permissions for, I'm queried if I want to open it as
root using the =sudo= tramp method.

#+begin_src emacs-lisp
    (defun leuven-find-file-sudo-header-warning ()
      "*Display a warning in header line of the current buffer."
      (let* ((warning "WARNING: EDITING FILE WITH ROOT PRIVILEGES!")
             (space (+ 6 (- (frame-width) (length warning))))
             (bracket (make-string (/ space 2) ?-))
             (warning (concat bracket warning bracket)))
        (setq header-line-format
              (propertize warning 'face 'header-line))))

    (defun leuven-find-file-sudo (filename)
      "Open FILENAME with root privileges."
      (interactive "F")
      (set-buffer (find-file (concat "/sudo::" filename)))
      (leuven-find-file-sudo-header-warning))

    ;; ;; XXX already an existing defadvice around find-file!!
    ;; (defadvice find-file (around leuven-find-file activate)
    ;;   "Open FILENAME using tramp's sudo method if it's read-only."
    ;;   (if (and (file-exists-p (ad-get-arg 0))
    ;;            (not (file-writable-p (ad-get-arg 0)))
    ;;            (not (file-remote-p (ad-get-arg 0)))
    ;;            (y-or-n-p (concat "File "
    ;;                              (ad-get-arg 0)
    ;;                              " is read-only.  Open it as root? ")))
    ;;       (leuven-find-file-sudo (ad-get-arg 0))
    ;;     ad-do-it))

    )
#+end_src

** Convenience Features for Finding Files

#+begin_src emacs-lisp
;;** 18.17 (info "(emacs)File Conveniences")

  (leuven--section "18.17 (emacs)File Conveniences")

  ;; filenames excluded from the recent list
  ;;! has to be set before your require recentf
  (setq recentf-exclude
        '(
          "~$" ;; Emacs (and others) backup
          "\\.log$" ;; LaTeX
          "\\.toc$" ;; LaTeX
          "\\.aux$" ;; LaTeX
          "/tmp/"
          ))

  ;; setup a menu of recently opened files
  (GNUEmacs
    (idle-require 'recentf))

  (with-eval-after-load "recentf"

    ;; maximum number of items that will be saved
    (setq recentf-max-saved-items 100)

    ;; file to save the recent list into
    (setq recentf-save-file "~/.emacs.d/.recentf")

    ;; (when using Tramp) turn off the cleanup feature of `recentf'
    (setq recentf-auto-cleanup 'never) ;; disable before we start recentf!

    ;; save file names relative to my current home directory
    (setq recentf-filename-handlers '(abbreviate-file-name))

    ;; enable `recentf' mode
    (recentf-mode 1))
#+end_src

*** FFAP

#+begin_src emacs-lisp
  (leuven--section "FFAP")

  ;; visit a file
  (global-set-key
    (kbd "<f3>") 'find-file-at-point)

  ;; find file (or URL) at point
  (with-eval-after-load "ffap"

    ;; function called to fetch an URL
    (setq ffap-url-fetcher 'browse-url))
    ;; could be `browse-url-emacs' or `w3m-browse-url'
#+end_src

*** Helm
    :PROPERTIES:
    :ID:       59418189-b87e-45a2-b128-5cbdc8a16430
    :END:

For Helm documentation, see the [[https://github.com/emacs-helm/helm/wiki][Emacs-helm wiki]] and the
[[https://github.com/thierryvolpiatto/emacs-tv-config/blob/master/init-helm-thierry.el][configuration of Thierry Volpiatto]]!

In Helm, generally, look at the mode-line, you will see =C-c ? help=, it is your
friend.

- Narrow the list by typing some patterns (multiple patterns are
  space-delimited string),

- Select an element with =<Up>= / =<Down>= / =<PageUp>= / =<PageDown>= / =C-p= / =C-n= /
  =C-v= / =M-v=,

- Choose with =<RET>=.

- With =C-z= contents of selected candidate are displayed without quitting helm
  session.

To go back to the *previous element* of the minibuffer history, use =M-p=.

Locate for *Windows* users: you have to install [[http://www.voidtools.com/download.php][Everything]] with his command line
interface.

Switch to =*Helm Log*= buffer with =M-x helm-open-last-log=.

#+begin_src emacs-lisp
  (GNUEmacs

    (leuven--section "Helm")

    ;; open Helm (QuickSilver-like candidate-selection framework)
    (when (try-require 'helm-config)

      ;; sort locate results by full path
      (when running-ms-windows
        (setq helm-locate-command "es -s %s %s"))

      (global-set-key
        (kbd "<f3>") 'helm-for-files)

      (global-set-key
        (kbd "M-x") 'helm-M-x)

      ;; buffers only
      (global-set-key
        (kbd "C-x b") 'helm-buffers-list)

      ;; awesome wearing a hat
      (global-set-key
        (kbd "<f4>") 'helm-org-headlines)
      ;; (or `helm-imenu', better than `org-toc')

      (global-set-key
        (kbd "C-c o") 'helm-occur)

      (global-set-key
        (kbd "C-x r l") 'helm-bookmarks)

      ;; install from https://github.com/thierryvolpiatto/emacs-bmk-ext
      (global-set-key
        (kbd "C-x r b") 'helm-bookmark-ext)

      ;; prefix key for all Helm commands in the global map
      (setq helm-command-prefix-key "C-c C-f") ;; `C-x c'?

      ;; use the *current window* (no popup) to show the candidates
      (setq helm-full-frame nil)

      ;; always display `helm-buffer' in current window
      (setq helm-split-window-default-side 'same)

      (defface leuven-separator-face
        '((t (:weight bold :foreground "slate gray")))
        "Face used to display state NEW.")

      ;; candidates separator of `multiline' source
      (setq helm-candidate-separator
            (propertize "--separator-------------------------------"
                        'face 'leuven-separator-face))

      ;; suppress displaying sources which are out of screen at first
      (setq helm-quick-update t)

      ;; time that the user has to be idle for, before candidates from
      ;; DELAYED sources are collected
      (setq helm-idle-delay 0.1)
      ;; useful for sources involving heavy operations, so that
      ;; candidates from the source are not retrieved unnecessarily if
      ;; the user keeps typing

      ;; time that the user has to be idle for, before ALL candidates
      ;; are collected (>= `helm-idle-delay')
      (setq helm-input-idle-delay 0.1)
      ;; also effective for NON-DELAYED sources

      ;; do not show more candidates than this limit from individual
      ;; sources
      (setq helm-candidate-number-limit 100) ;; more than one screen page

      ;; ;; don't save history information to file
      ;; (remove-hook 'kill-emacs-hook 'helm-c-adaptive-save-history)

      ;; don't show only basename of candidates in `helm-find-files'
      (setq helm-ff-transformer-show-only-basename nil)

      ;; don't truncate buffer names
      (setq helm-buffer-max-length nil)

      ;; allow to call M-x R with helm-M-x without waiting for 2+ chars
      (setq helm-M-x-requires-pattern 0)

      (defun helm-toggle-debug ()
        "Toggle Helm debug on/off."
        (interactive)
        (setq helm-debug (not helm-debug))
        (message "Helm debug %s" (if helm-debug
                                     "enabled"
                                   "disabled")))))
#+end_src

- =volatile= means your candidates are recomputed each time you enter a character
  in pattern (cached candidates are not reused). Async sources are by essence
  volatile.

- =delayed= means your candidates are computed after =helm-input-idle-delay=
  seconds.

- =no-matchplugin= means to not use the multi regexp matching provided by
  ~helm-match-plugin.el~.

*** Image mode

*************** TODO auto-image-file-mode in find-file-hook for performance reasons!?

#+begin_src emacs-lisp
  (leuven--section "Image mode")

  ;; show image files as images (not as semi-random bits)
  (GNUEmacs
    (add-hook 'find-file-hook
              (lambda ()
                (auto-image-file-mode 1))))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 18 ends here
#+end_src

* Using Multiple Buffers

#+begin_src emacs-lisp
;;* 19 Using Multiple (info "(emacs)Buffers")

(leuven--chapter leuven-chapter-19-buffers "19 Using Multiple Buffers"
#+end_src

** Creating and Selecting Buffers

#+begin_src emacs-lisp
;;** 19.1 Creating and (info "(emacs)Select Buffer")

  (leuven--section "19.1 (emacs)Select Buffer")

  (defun switch-or-start (function buffer)
    "If the BUFFER is current, bury it. If there is a buffer with that
  name, switch to it; otherwise, invoke the FUNCTION."
    (if (equal (buffer-name (current-buffer)) buffer)
        (bury-buffer)
      (if (get-buffer buffer)
          (switch-to-buffer buffer)
        (funcall function))))

  (defun switch-or-find-file (file)
    "If the FILE is current, bury it. If there is a buffer with that
  name, switch to it; otherwise, open it."
    (when (file-exists-p file)
      (if (and (buffer-file-name)
               (string= (expand-file-name file)
                        (expand-file-name (buffer-file-name))))
          (bury-buffer)
        (find-file file))))
#+end_src

** Listing Existing Buffers

- The =C= (current) column has a =.= for the buffer from which you came.
- The =R= (read-only) column has a =%= if the buffer is read-only.
- The =M= (modified) column has a =*= if it is modified.

#+begin_src emacs-lisp
;;** 19.2 (info "(emacs)List Buffers")

  (leuven--section "19.2 (emacs)List Buffers")

  ;; rebind `C-x C-b'
  (global-set-key
    (kbd "C-x C-b") 'electric-buffer-list)
  ;; `buffer-menu' moves point in the window which lists your buffers
  ;; `electric-buffer-list' pops up a buffer describing the set of buffers

  ;; operate on buffers like Dired
  (global-set-key
    (kbd "C-x C-b") 'ibuffer)

  (with-eval-after-load "ibuffer"

    ;; completely replaces `list-buffer'
    (defalias 'ibuffer-list-buffers 'list-buffer)

    ;; don't show the names of filter groups which are empty
    (setq ibuffer-show-empty-filter-groups nil)

    ;; filtering groups
    (setq ibuffer-saved-filter-groups
          '(("default"
             ("Chat"
              (mode . circe-mode))
             ("Org"
              (or
               (mode . diary-mode)
               (mode . org-mode)
               (mode . org-agenda-mode)))
             ("LaTeX"
              (or
               (mode . latex-mode)
               (mode . LaTeX-mode)
               (mode . bibtex-mode)
               (mode . reftex-mode)))
             ("Gnus & News"
              (or
               (mode . message-mode)
               (mode . bbdb-mode)
               (mode . mail-mode)
               (mode . gnus-group-mode)
               (mode . gnus-summary-mode)
               (mode . gnus-article-mode)
               (name . "^\\(\\.bbdb\\|dot-bbdb\\)$")
               (name . "^\\.newsrc-dribble$")
               (mode . newsticker-mode)))
             ("Files"
              (filename . ".*"))
             ("Dired"
              (mode . dired-mode))
             ("Shell"
              (mode . shell-mode))
             ("Version Control"
              (or
               (mode . svn-status-mode)
               (mode . svn-log-edit-mode)
               (name . "^\\*svn-")
               (name . "^\\*vc\\*$")
               (name . "^\\*Annotate")
               (name . "^\\*git-")
               (name . "^\\*vc-")))
             ("Emacs"
              (or
               (name . "^\\*scratch\\*$")
               (name . "^\\*Messages\\*$")
               (name . "^TAGS\\(<[0-9]+>\\)?$")
               (name . "^\\*Occur\\*$")
               (name . "^\\*grep\\*$")
               (name . "^\\*Compile-Log\\*$")
               (name . "^\\*Backtrace\\*$")
               (name . "^\\*Process List\\*$")
               (name . "^\\*gud\\*$")
               (name . "^\\*Kill Ring\\*$")
               (name . "^\\*Completions\\*$")
               (name . "^\\*tramp")
               (name . "^\\*compilation\\*$")))
             ("Emacs Source"
              (mode . emacs-lisp-mode))
             ("Documentation"
              (or
               (mode . Info-mode)
               (mode . apropos-mode)
               (mode . woman-mode)
               (mode . help-mode)
               (mode . Man-mode))))))

    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-switch-to-saved-filter-groups "default")))

    ;; order the groups so the order is: [Default], [agenda], [emacs]
    (defadvice ibuffer-generate-filter-groups
      (after leuven-reverse-ibuffer-groups activate)
      (setq ad-return-value (nreverse ad-return-value))))
#+end_src

** Killing Buffers

#+begin_src emacs-lisp
;;** 19.4 (info "(emacs)Kill Buffer")

  (leuven--section "19.4 (emacs)Kill Buffer")

  ;; kill buffer without confirmation (if not modified)
  (defun leuven-kill-this-buffer-without-query ()
    "Kill the current buffer without confirmation (if not modified)."
    (interactive)
    (kill-buffer nil))

  ;; key binding
  (global-set-key
    (kbd "<S-f12>") 'leuven-kill-this-buffer-without-query)
#+end_src

** Operating on Several Buffers

#+begin_src emacs-lisp
;;** 19.5 (info "(emacs)Several Buffers")

  (leuven--section "19.5 (emacs)Several Buffers")

  ;; put the current buffer at the end of the list of all buffers
  (global-set-key
    (kbd "<f12>") 'bury-buffer)

  ;; ;; put the current buffer at the end of the list of all buffers
  ;; (global-set-key
  ;;   (kbd "<S-f12>") 'bury-buffer) ;; TEMP Use this (instead of f12) when GDB'ing Emacs
#+end_src

** Convenience Features and Customization of Buffer Handling

#+begin_src emacs-lisp
;;** 19.7 (info "(emacs)Buffer Convenience") and Customization of Buffer Handling

  (leuven--section "19.7 (emacs)Buffer Convenience and Customization of Buffer Handling")

  ;; unique buffer names dependent on file name
  (try-require 'uniquify)

  (with-eval-after-load "uniquify"

    ;; style used for uniquifying buffer names with parts of directory
    ;; name
    (setq uniquify-buffer-name-style 'forward)

    ;; distinguish directories by adding extra separator
    (setq uniquify-trailing-separator-p t))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 19 ends here
#+end_src

* Multiple Windows

#+begin_src emacs-lisp
;;* 20 Multiple (info "(emacs)Windows")

(leuven--chapter leuven-chapter-20-windows "20 Multiple Windows"
#+end_src

** Concepts of Emacs Windows

#+begin_src emacs-lisp
;;** 20.1 (info "(emacs)Basic Window")

  (leuven--section "20.1 (emacs)Basic Window")

  ;; turn off this horrible tab thingy in XEmacs
  (XEmacs
    (when (boundp 'default-gutter-visible-p)
      (set-specifier default-gutter-visible-p nil)))
#+end_src

** Using Other Windows

#+begin_src emacs-lisp
;;** 20.3 (info "(emacs)Other Window")

  (leuven--section "20.3 (emacs)Other Window")

  ;; cycle through all windows on current frame
  (global-set-key
    (kbd "<f6>") 'other-window)

  ;; reverse operation of `C-x o' (or `f6')
  (global-set-key
    (kbd "<S-f6>")
    (lambda ()
      (interactive)
      (other-window -1)))
#+end_src

** Deleting and Rearranging Windows

#+begin_src emacs-lisp
;;** 20.5 (info "(emacs)Change Window")

  (leuven--section "20.5 (emacs)Change Window")

  ;; delete all windows in the selected frame except the selected window
  (global-set-key
    (kbd "<f5>") 'delete-other-windows)

  ;; enlarge or shrink windows more easily than with `C-x {', `C-x }' and the
  ;; like
  (global-set-key
    (kbd "<C-S-up>") 'enlarge-window)
  (global-set-key
    (kbd "<C-S-down>") 'shrink-window)
  (global-set-key
    (kbd "<C-S-left>") 'enlarge-window-horizontally)
  (global-set-key
    (kbd "<C-S-right>") 'shrink-window-horizontally)

  ;; make all visible windows the same height (approximately)
  (global-set-key
    (kbd "<C-f6>") 'balance-windows)

  ;; swap 2 windows
  (defun leuven-swap-windows ()
    "If you have 2 windows, swap them."
    (interactive)
    (cond ((not (= (count-windows) 2))
           (message "You need exactly 2 windows to swap them."))
          (t
           (let* ((wind-1 (first (window-list)))
                  (wind-2 (second (window-list)))
                  (buf-1 (window-buffer wind-1))
                  (buf-2 (window-buffer wind-2))
                  (start-1 (window-start wind-1))
                  (start-2 (window-start wind-2)))
             (set-window-buffer wind-1 buf-2)
             (set-window-buffer wind-2 buf-1)
             (set-window-start wind-1 start-2)
             (set-window-start wind-2 start-1)))))

  (global-set-key
    (kbd "C-c ~") 'leuven-swap-windows)

  (defun leuven-toggle-window-split ()
    "Toggle between vertical and horizontal split.

  Vertical split shows more of each line, horizontal split shows more lines.
  This code only works for frames with exactly two windows."
    (interactive)
    (cond ((not (= (count-windows) 2))
           (message "You need exactly 2 windows to toggle the window split."))
          (t
           (let* ((this-win-buffer (window-buffer))
                  (next-win-buffer (window-buffer (next-window)))
                  (this-win-edges (window-edges (selected-window)))
                  (next-win-edges (window-edges (next-window)))
                  (this-win-2nd (not (and (<= (car this-win-edges)
                                              (car next-win-edges))
                                          (<= (cadr this-win-edges)
                                              (cadr next-win-edges)))))
                  (splitter
                   (if (= (car this-win-edges)
                          (car (window-edges (next-window))))
                       'split-window-horizontally
                     'split-window-vertically)))
             (delete-other-windows)
             (let ((first-win (selected-window)))
               (funcall splitter)
               (if this-win-2nd (other-window 1))
               (set-window-buffer (selected-window) this-win-buffer)
               (set-window-buffer (next-window) next-win-buffer)
               (select-window first-win)
               (if this-win-2nd (other-window 1)))))))

  (global-set-key
    (kbd "C-c |") 'leuven-toggle-window-split)
#+end_src

** Displaying a Buffer in a Window

Splits screen vertically if the width of the window is large enough.

See
http://stackoverflow.com/questions/1381794/too-many-split-screens-opening-in-emacs
for alternative code...

See as well =split-window-preferred-function=.

#+begin_src emacs-lisp
;;** 20.6 (info "(emacs)Displaying Buffers")

  (leuven--section "20.6 (emacs)Pop Up Window")

  ;; don't allow splitting windows vertically
  (setq split-height-threshold nil)

  ;; minimum width for splitting windows horizontally
  (setq split-width-threshold 160)
#+end_src

** Window Handling Convenience Features and Customization

Use =M-x scroll-all-mode= to scroll all visible windows together in parallel.

#+begin_src emacs-lisp
) ;; chapter 20 ends here
#+end_src

* Frames and Graphical Displays

#+begin_src emacs-lisp
;;* 21 (info "(emacs)Frames") and Graphical Displays

(leuven--chapter leuven-chapter-21-frames "21 Frames and Graphical Displays"
#+end_src

** Mouse Commands for Editing

#+begin_src emacs-lisp
;;** 21.1 (info "(emacs)Mouse Commands")

  (leuven--section "21.1 (emacs)Mouse Commands")

  ;; scroll one line at a time
  (setq mouse-wheel-scroll-amount
        '(1
          ((shift) . 1)))
#+end_src

** Creating Frames

#+begin_src emacs-lisp
;;** 21.5 (info "(emacs)Creating Frames")

  (leuven--section "21.5 (emacs)Creating Frames")
#+end_src

1. Resize the frame to the size you want
2. Enter =(frame-parameters)= in the =*scratch*= buffer
3. Evaluate the form: place the cursor after the closing paren, and type =C-j=,
   so that the output goes right into the =*scratch*= buffer

By putting customizations =default-frame-alist= in your init file, you can
control the appearance of *all the frames* Emacs creates, including the initial
one.

=initial-frame-alist= is just for overriding properties for the first frame.

#+begin_src emacs-lisp
  ;; put Emacs exactly where you want it, every time it starts up, by
  ;; auto-detecting the screen dimensions and computing where it should be
  (when (display-graphic-p)
    (GNUEmacs
      ;; list of default values for frame creation
      (add-to-list 'default-frame-alist
                   (cons 'height
                         (/ (- (x-display-pixel-height) 106)
                            (frame-char-height)))))

    ;; avoid Emacs hanging for a while (old hack from 2001)
    (add-to-list 'default-frame-alist
                 '(wait-for-wm . nil))

    ;; list of frame parameters for creating the initial frame
    (setq initial-frame-alist
          '((top . 0)
            (left . 0)))

    ;; default value of `vertical-scroll-bar' for buffers that don't
    ;; override it
    (setq default-vertical-scroll-bar 'right))

  (XEmacs
    (set-frame-width (buffer-dedicated-frame) 80)
    (set-frame-height (buffer-dedicated-frame) 42)
    (set-frame-position (buffer-dedicated-frame) 0 0))

  ;; title bar display of visible frames
  (setq frame-title-format
        (format "Emacs %s rev:%s pid:%d"
                emacs-version
                (ignore-errors
                  (replace-regexp-in-string " .*" "" emacs-bzr-version))
                (emacs-pid)))
#+end_src

#+begin_src emacs-lisp
  (defun detach-window ()
    "Close current window and re-open it in new frame."
    (interactive)
    (let ((current-buffer (window-buffer)))
      (delete-window)
      (select-frame (make-frame))
      (set-window-buffer (selected-window) current-buffer)))
#+end_src

** Frame Commands

#+begin_src emacs-lisp
;;** 21.6 (info "(emacs)Frame Commands")

  (leuven--section "21.6 (emacs)Frame Commands")

  (XWindow
   (defun toggle-full-screen ()
     "Toggle between full screen and partial screen display on X11."
     (interactive)
     ;; WM must support EWMH
     ;; http://standards.freedesktop.org/wm-spec/wm-spec-latest.html
     (x-send-client-message nil 0 nil "_NET_WM_STATE" 32
                            '(2 "_NET_WM_STATE_FULLSCREEN" 0)))

   (global-set-key
     (kbd "C-c z") 'toggle-full-screen))

  (GNUEmacs
    (when running-ms-windows
      (defun w32-maximize-frame ()
        "Maximize the current frame."
        (interactive)
        (w32-send-sys-command 61488)
        (global-set-key
          (kbd "C-c z") 'w32-restore-frame))

      (global-set-key
        (kbd "C-c z") 'w32-maximize-frame)

      (defun w32-restore-frame ()
        "Restore a minimized frame."
        (interactive)
        (w32-send-sys-command 61728)
        (global-set-key
          (kbd "C-c z") 'w32-maximize-frame))))
#+end_src

*************** TODO Try to use the name toggle-full-screen for Windows as well

See =(display-pixel-width)=:

#+begin_src emacs-lisp :tangle no
  ;; set the new height, allowing for title bars
  (setq lframe-width (- (/ (x-display-pixel-width) (frame-char-width)) 8))

  ;; set the new height, allowing for title bars
  (setq lframe-height (- (/ (x-display-pixel-height) (frame-char-height)) 5))
#+end_src

** Speedbar Frames

#+begin_src emacs-lisp
;;** 21.8 (info "(emacs)Speedbar")

  (leuven--section "21.8 (emacs)Speedbar Frames")

  ;; TODO don't bind F4 if already bound to helm... If helm not there, OK do it.
  ;; ;; jump to speedbar frame
  ;; (global-set-key (kbd "<f4>") 'speedbar-get-focus)

  ;; everything browser (into individual source files), or Dired on
  ;; steroids
  (with-eval-after-load "speedbar"

    ;; number of spaces used for indentation
    (setq speedbar-indentation-width 2)

    ;; add new extensions for speedbar tagging (allow to expand/collapse
    ;; sections, etc.) -- do this BEFORE firing up speedbar?
    (speedbar-add-supported-extension
     '(".bib" ".css" ".jpg" ".js" ".nw" ".org" ".php" ".png" ".tex" ".txt"
       ".w" "README"))

    ;; bind the arrow keys in the speedbar tree
    (define-key speedbar-key-map
      (kbd "<right>") 'speedbar-expand-line)
    (define-key speedbar-key-map
      (kbd "<left>") 'speedbar-contract-line)

    ;; parameters to use when creating the speedbar frame in Emacs
    (setq speedbar-frame-parameters '((width . 30)
                                      (height . 45)
                                      (foreground-color . "blue")
                                      (background-color . "white")))

    ;; speedbar in the current frame (vs in a new frame)
    (when (locate-library "sr-speedbar")
      (autoload 'sr-speedbar-toggle "sr-speedbar" nil t)
      ;; TODO don't bind F4 if already bound to helm... If helm not there, OK do it.
      ;; (global-set-key (kbd "<f4>") 'sr-speedbar-toggle)
      ))
#+end_src

** Tool Bars

#+begin_src emacs-lisp
;;** 21.15 (info "(emacs)Tool Bars")

  (leuven--section "21.15 (emacs)Tool Bars")

  ;; turn tool bar off
  (when (display-graphic-p)
    (GNUEmacs
      (tool-bar-mode -1))
    (XEmacs
      (set-specifier default-toolbar-visible-p nil)))
#+end_src

** Using Dialog Boxes

#+begin_src emacs-lisp
;;** 21.16 Using (info "(emacs)Dialog Boxes")

  (leuven--section "21.16 (emacs)Using Dialog Boxes")

  ;; don't use dialog boxes to ask questions
  (setq use-dialog-box nil)

  ;; don't use a file dialog to ask for files
  (setq use-file-dialog nil)
#+end_src

** Tooltips

#+begin_src emacs-lisp
;;** 21.17 (info "(emacs)Tooltips")

  (leuven--section "21.17 (emacs)Tooltips")

  ;; use the echo area for help and GUD tooltips
  (setq tooltip-use-echo-area t)
#+end_src

#+begin_src emacs-lisp
) ;; chapter 21 ends here
#+end_src

* International Character Set Support

#+begin_src emacs-lisp
;;* 22 (info "(emacs)International") Character Set Support

(leuven--chapter leuven-chapter-22-international "22 International Character Set Support"
#+end_src

For any user who needs symbols that are not in the 7-bit ASCII set, our
recommendation is to move to Unicode UTF-8. That is the only encoding that is
the same across all platforms and operating systems that support it.

To open (or save) a file in UTF-8, you can press =C-x <RET> c utf-8 <RET>=
(=universal-coding-system-argument=) before the =C-x C-f= (or =C-x C-s=).

To help you find all the chars you need to replace by escape sequences, you
can use =C-u C-s [^[:ascii:]]=.

To check your locale settings, you can have a look to what Emacs produce (in a
mail buffer) under "Important settings" when you type
=M-x report-emacs-bug <RET> foo <RET>=:

*Important settings*:
- value of =$LC_ALL=: =nil=
- value of =$LC_COLLATE=: =nil=
- value of =$LC_CTYPE=: =nil=
- value of =$LC_MESSAGES=: =nil=
- value of =$LC_MONETARY=: =nil=
- value of =$LC_NUMERIC=: =nil=
- value of =$LC_TIME=: =nil=
- value of =$LANG=: =en_US.UTF-8=
- value of =$XMODIFIERS=: =nil=
- =locale-coding-system=: =utf-8-unix=
- =default-enable-multibyte-characters=: =t=

** Language Environments

#+begin_src emacs-lisp
;;** 22.3 (info "(emacs)Language Environments")

  (leuven--section "22.3 (emacs)Language Environments")

  ;; specify your character-set locale
  (setenv "LANG" "en_US.utf8")          ; for svn not to report warnings

  ;; system locale to use for formatting time values
  (setq system-time-locale "C")         ; make sure that the weekdays in the
                                        ; time stamps of your Org mode files
                                        ; and in the agenda appear in English

  ;; (setq system-time-locale (getenv "LANG"))
  ;;                                       ; for weekdays in your locale settings
#+end_src

One could use:
- =LC_ALL=,
- =LC_COLLATE=C= (or =LC_COLLATE=POSIX=),
- =LC_CTYPE=,
- =LC_ALL= or
- =LANG=

but this won't work for a Windows binary (well for the Cygwin version of
Emacs).

** Input Methods

=M-x describe-coding-system <RET> <RET>=

To see all the non-ASCII characters you can type with the =C-x 8= prefix, type
=C-x 8 C-h=.

#+begin_src emacs-lisp
;;** 22.4 (info "(emacs)Input Methods")

  (leuven--section "22.4 (emacs)Input Methods")

  ;; get 8-bit characters in terminal mode (Cygwin Emacs)
  (set-input-mode (car (current-input-mode))
                  (nth 1 (current-input-mode))
                  0)
#+end_src

** Recognizing Coding Systems

In GNU Emacs, when you specify the coding explicitly in the file, that
overrides =file-coding-system-alist=.

XXX Declare PDF files as binary

#+begin_src emacs-lisp
;;** 22.7 (info "(emacs)Recognize Coding") Systems

  (leuven--section "22.7 (emacs)Recognize Coding Systems")

  ;; default coding system (for new files),
  ;; also moved to the front of the priority list for automatic detection
  (GNUEmacs
   (prefer-coding-system 'utf-8-unix))  ; Unix flavor for code blocks executed
                                        ; via Org-Babel
#+end_src

** Specifying a File's Coding System

#+begin_src emacs-lisp
;;** 22.8 (info "(emacs)Specify Coding") System of a File

  (leuven--section "22.8 (emacs)Specify Coding System of a File")

  (GNUEmacs
    ;; to copy and paste to and from Emacs through the clipboard (with
    ;; coding system conversion)
    (cond (running-ms-windows
           (set-selection-coding-system 'compound-text-with-extensions))
          (t
           (set-selection-coding-system 'utf-8))))
#+end_src

** Bidirectional Editing

#+begin_src emacs-lisp :tangle no
;;** 22.20 (info "(emacs)Bidirectional Editing")

  (leuven--section "22.20 (emacs)Bidirectional Editing")

  ;; faster scrolling (if you never expect to have to display bidirectional
  ;; scripts, like Arabic)
  (setq-default bidi-paragraph-direction 'left-to-right)
#+end_src

#+begin_src emacs-lisp
) ;; chapter 22 ends here
#+end_src

* Major and Minor Modes

#+begin_src emacs-lisp
;;* 23 (info "(emacs)Modes")

(leuven--chapter leuven-chapter-23-major-and-minor-modes "23 Major and Minor Modes"
#+end_src

** How Major Modes are Chosen

See "Syntax of Regexps":
- \' matches end of string
- =$= matches end of line

#+begin_src emacs-lisp
;;** 23.3 (info "(emacs)Choosing Modes")

  (leuven--section "23.3 (emacs)Choosing File Modes")
#+end_src

*** Choice based on the file name

Instead of superseding the binding in =auto-mode-alist=, you can replace it
(brute force) with =(setcdr (rassq 'old-mode auto-mode-alist) 'new-mode)=.

#+begin_src emacs-lisp
  ;; list of filename patterns
  (setq auto-mode-alist
        (append '(("\\.log\\'"       . text-mode)
                  ;; ("\\.[tT]e[xX]\\'" . latex-mode)
                  ;; ("\\.cls\\'"       . LaTeX-mode)
                  ("\\.cgi\\'"       . perl-mode)
                  ;; ("[mM]akefile"     . makefile-mode)
                  (".ssh/config\\'"  . ssh-config-mode)
                  ("sshd?_config\\'" . ssh-config-mode)
                  ) auto-mode-alist))

  ;; major mode for fontifiying ssh config files
  (autoload 'ssh-config-mode "ssh-config-mode"
    "Major mode for fontifiying ssh config files." t)

  ;; ledger
  (add-to-list 'auto-mode-alist '("\\.dat\\'" . ledger-mode))

  ;; major mode for editing comma-separated value files
  (add-to-list 'auto-mode-alist '("\\.csv\\'" . csv-mode))
  (autoload 'csv-mode "csv-mode"
    "Major mode for editing comma-separated value files." t)
  (with-eval-after-load "csv-mode"
    ;; field separators: a list of *single-character* strings
    (setq csv-separators '("," ";")))
#+end_src

*** Choice based on the interpreter name

#+begin_src emacs-lisp
  ;; list of interpreters specified in the first line (starts with `#!')
  (push '("expect" . tcl-mode) interpreter-mode-alist)
#+end_src

*** Choice based on the text at the start of the buffer

For a list of buffer beginnings, see =magic-mode-alist=.

#+begin_src emacs-lisp
  ;; ;; load generic modes which support e.g. batch files
  ;; (try-require 'generic-x)
#+end_src

#+begin_src emacs-lisp
) ;; chapter 23 ends here
#+end_src

* Indentation

#+begin_src emacs-lisp
;;* 24 (info "(emacs)Indentation")

(leuven--chapter leuven-chapter-24-indentation "24 Indentation"
#+end_src

** Indentation Commands

- =M-m= ::
     =back-to-indentation=

- =C-M-\= ::
     runs the command =indent-region= (which does the job of the imaginary
     command =unsuck-html-layout= in =html-mode=)

#+begin_src emacs-lisp
;;** 24.1 (info "(emacs)Indentation Commands") and Techniques

  (leuven--section "24.1 (emacs)Indentation Commands and Techniques")

  (defun indent-whole-buffer ()
    (interactive)
    (save-excursion
      (mark-whole-buffer)
      (indent-for-tab-command)))
#+end_src

** Tabs vs. Spaces

#+begin_src emacs-lisp
;;** 24.3 TABs vs. (info "(emacs)Just Spaces")

  (leuven--section "24.3 TABs vs. (emacs)Just Spaces")

  ;; indentation can't insert TABs
  (setq-default indent-tabs-mode nil)
#+end_src

#+begin_src emacs-lisp
) ;; chapter 24 ends here
#+end_src

* Commands for Human Languages

#+begin_src emacs-lisp
;;* 25 Commands for (info "(emacs)Text") Human Languages

(leuven--chapter leuven-chapter-25-text "25 Commands for Human Languages"
#+end_src

** Words

#+begin_src emacs-lisp
;;** 25.1 (info "(emacs)Words")

  (leuven--section "25.1 (emacs)Words")

  ;; GNU Emacs default for killing back to the beginning of a word
  (XEmacs
    (global-set-key
      (kbd "<C-backspace>") 'backward-kill-word))
#+end_src

** Sentences

See =sentence-end= and =(sentence-end)=.

*************** TODO When changing the ispell language, change this var as well?

#+begin_src emacs-lisp
;;** 25.2 (info "(emacs)Sentences")

  (leuven--section "25.2 (emacs)Sentences")

  ;; a single space does end a sentence
  (setq-default sentence-end-double-space nil)
#+end_src

** Filling Text

#+begin_src emacs-lisp
;;** 25.5 (info "(emacs)Filling") Text

  (leuven--section "25.5 (emacs)Filling Text")

  ;; line-wrapping beyond that column (when pressing `M-q')
  (setq-default fill-column 79)

  ;; ;; `M-q' runs the command `fill-paragraph'. `C-u M-q' runs
  ;; ;; "unfill-paragraph"
  ;; (defun leuven-fill-paragraph (&optional arg)
  ;;   (interactive "P")
  ;;   (let ((fill-column (if arg
  ;;                          (point-max)
  ;;                        fill-column)))
  ;;     (fill-paragraph nil)))
  ;;
  ;; (global-set-key (kbd "M-q") 'leuven-fill-paragraph)


  ;; (add-hook 'fill-nobreak-predicate 'fill-french-nobreak-p)
  ;; (add-hook 'fill-nobreak-predicate 'fill-single-word-nobreak-p)

  ;; activate Auto Fill for all text mode buffers
  (add-hook 'text-mode-hook 'turn-on-auto-fill)

  ;; automatically fill comments (but not code) in programming modes
  (add-hook 'prog-mode-hook
            (lambda ()
              (auto-fill-mode 1)
              (set (make-local-variable 'fill-nobreak-predicate)
                   (lambda ()
                     (not (eq (get-text-property (point) 'face)
                              'font-lock-comment-face))))))
#+end_src

#+begin_src emacs-lisp
  (defun leuven-good-old-fill-paragraph ()
    (interactive)
    (let ((fill-paragraph-function nil)
          (adaptive-fill-function nil))
      (fill-paragraph)))
#+end_src

There are several *non-break space* characters:

- *No-break space*, required for French punctuation (before =:=).

- *No-break thin space*, known in Unicode as "Narrow No-Break Space", required
  for French punctuation (before =?=, =!= or =;=).

#+begin_src emacs-lisp
  ;; replace space by nobreak-space where it fits well
  (defun leuven--replace-space-before-colon ()
    "Replace space by nobreak-space in front of a colon."
    (interactive)
    (require 'org-element)
    (cond ((eq (char-before) ?\ ) ;; normal space
           (backward-delete-char 1)
           (cond ((equal mode-name "PDFLaTeX")
                  (insert "~:"))
                 ((equal mode-name "Org")
                  (if (member (org-element-type (org-element-at-point))
                              ;; list of exceptions
                              '(src-block keyword table dynamic-block))
                      (insert " :")
                    (insert ":")))
                 (t
                  (insert ":")))) ;; non-breaking space

          ;; remove nobreak-space if two colons are put one after the
          ;; other (for terms and definitions in Org)
          ((and (eq (char-before) ?\:)
                (eq (char-before (- (point) 1)) ?\))
           (backward-delete-char 2)
           (insert " ::")) ;; normal space

          (t
           (insert ":"))))

  (defun leuven--replace-space-before-question-mark ()
    "If any, replace space by nobreak-space in front of a question mark."
    (interactive)
    (if (eq (char-before) ?\ ) ; normal space
        (progn
          (backward-delete-char 1)
          (if (equal mode-name "PDFLaTeX")
              (insert "\,?")
            (insert "?"))) ; non-breaking space
      (insert "?")))

  (defun leuven--replace-space-before-exclamation-mark ()
    "If any, replace space by nobreak-space in front of an exclamation
  mark."
    (interactive)
    (if (eq (char-before) ?\ ) ; normal space
        (progn
          (backward-delete-char 1)
          (if (equal mode-name "PDFLaTeX")
              (insert "\,!")
            (insert "!"))) ; non-breaking space
      (insert "!")))

  (defun leuven--replace-space-before-semi-colon ()
    "If any, replace space by nobreak-space in front of a semi-colon."
    (interactive)
    (require 'org-element)
    (if (eq (char-before) ?\ ) ; normal space
        (progn
          (backward-delete-char 1)
          (cond ((equal mode-name "PDFLaTeX")
                 (insert "\,;"))
                ((equal mode-name "Org")
                 (if (member (org-element-type (org-element-at-point))
                             ;; list of exceptions
                             '(src-block))
                     (insert " ;")
                   (insert ";")))
                (t
                 (insert ";")))) ; non-breaking space
      (insert ";")))

  (defun leuven--replace-double-double-quote ()
    "Replace two following double quotes by French quotes with nobreak-spaces."
    (interactive)
    (if (eq (char-before) ?\")
        (progn
          (backward-delete-char 1)
          (insert "")
          (backward-char 2))
      (insert "\"")))

  ;; French typography
  (defun leuven--nobreak-keys ()
    "If any, replace space in front of colons, question marks, exclamation
  marks, etc. to avoid line break problems."
    (interactive)
    (local-set-key ":" 'leuven--replace-space-before-colon)
    (local-set-key "?" 'leuven--replace-space-before-question-mark)
    (local-set-key "!" 'leuven--replace-space-before-exclamation-mark)
    (local-set-key ";" 'leuven--replace-space-before-semi-colon)
    (local-set-key "\"" 'leuven--replace-double-double-quote))

  (add-hook 'text-mode-hook 'leuven--nobreak-keys)
  (add-hook 'message-mode-hook 'leuven--nobreak-keys)
#+end_src

#+begin_src emacs-lisp
  (defun insert-one-quote-or-two ()
    (interactive)
    (cond
     ((or (bolp) (not (looking-back "'")))
      ;; insert just one '
      (self-insert-command 1))
     ((save-excursion
        (backward-char)
        ;; Skip symbol backwards.
        (and (not (zerop (skip-syntax-backward "w_")))
             (not (looking-back "`"))
             (or (insert-and-inherit "`") t))))
     (t
      ;; insert `' around following symbol
      (delete-backward-char 1)
      (unless (looking-back "`") (insert-and-inherit "`"))
      (save-excursion
        (skip-syntax-forward "w_")
        (unless (looking-at "'") (insert-and-inherit "'"))))))

  (global-set-key
   [39] 'insert-one-quote-or-two)
#+end_src

** Case Conversion Commands

#+begin_src emacs-lisp
;;** 25.6 (info "(emacs)Case") Conversion Commands

  (leuven--section "25.6 (emacs)Case Conversion Commands")

  ;; enable the use of the commands `downcase-region' and `upcase-region'
  ;; without confirmation
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src

** Outline Mode
   :PROPERTIES:
   :ID:       42ad895e-c049-4710-a877-5014a7f6acfc
   :END:

Outline is line-oriented and does not distinguish end-of-block.

#+begin_src emacs-lisp
;;** 25.8 (info "(emacs)Outline Mode")

  (leuven--section "25.8 (emacs)Outline Mode")
#+end_src

*** outline-minor-mode

Though Outline minor mode has NOTHING to do with folding of code as such, some
people have the following code in their =ruby-mode-hook= to enable code folding
using =outline-minor-mode= + =outline-magic=.

#+begin_example
(outline-minor-mode 1)
(set (make-local-variable 'outline-regexp) "^[ \t]*\\(?:def\\|class\\|module\\)\\|^[ \t]*###==")
#+end_example

~outline-minor-mode.el~ is also used to collapse Lisp code (i.e., to see in the
buffer just the definition of a function instead of the whole body).

See also the library [[id:a36b1dbd-1d05-4ff2-b19a-167e50c4f1f7][hs-minor-mode]].

You can use =org-cycle= in other modes, with =outline-minor-mode=.

#+begin_src emacs-lisp
  ;; outline mode commands for Emacs
  (with-eval-after-load "outline"

    ;; bind the outline minor mode functions to an easy to remember prefix
    ;; key (more accessible than the horrible prefix `C-c @')
    (setq outline-minor-mode-prefix (kbd "C-c C-o")) ;; like in nXML mode

    ;; ;; make other `outline-minor-mode' files (LaTeX, etc.) feel the Org
    ;; ;; mode outline navigation (written by Carsten Dominik)
    ;; (when (try-require 'outline-magic)
    ;;   (add-hook 'outline-minor-mode-hook
    ;;             (lambda ()
    ;;               (define-key outline-minor-mode-map
    ;;                 (kbd "<S-tab>") 'outline-cycle)
    ;;               (define-key outline-minor-mode-map
    ;;                 (kbd "<M-left>") 'outline-promote)
    ;;               (define-key outline-minor-mode-map
    ;;                 (kbd "<M-right>") 'outline-demote)
    ;;               (define-key outline-minor-mode-map
    ;;                 (kbd "<M-up>") 'outline-move-subtree-up)
    ;;               (define-key outline-minor-mode-map
    ;;                 (kbd "<M-down>") 'outline-move-subtree-down))))

    ;; ;; extra support for outline minor mode
    ;; (try-require 'out-xtra)


    ;; Org-style folding for a `.emacs' (and much more)

    ;; FIXME This should be in an `eval-after-load' of Org, so that
    ;; `org-level-N' are defined when used

    (defun leuven--outline-regexp ()
      "Calculate the outline regexp for the current mode."
      (let ((comment-starter (replace-regexp-in-string
                              "[[:space:]]+" "" comment-start)))
        (when (string= comment-start ";")
          (setq comment-starter ";;"))
        ;; (concat "^" comment-starter "\\*+")))
        (concat "^" comment-starter "[*]+ ")))

    ;; fontify the whole line for headings (with a background color)
    (setq org-fontify-whole-heading-line t)

    (defun leuven--outline-minor-mode-hook ()
      (interactive)
      (setq outline-regexp (leuven--outline-regexp))
      (let* ((org-fontify-whole-headline-regexp "") ; "\n?")
             (heading-1-regexp
              (concat (substring outline-regexp 0 -1)
                      "\\{1\\} \\(.*" org-fontify-whole-headline-regexp "\\)"))
             (heading-2-regexp
              (concat (substring outline-regexp 0 -1)
                      "\\{2\\} \\(.*" org-fontify-whole-headline-regexp "\\)"))
             (heading-3-regexp
              (concat (substring outline-regexp 0 -1)
                      "\\{3\\} \\(.*" org-fontify-whole-headline-regexp "\\)"))
             (heading-4-regexp
              (concat (substring outline-regexp 0 -1)
                      "\\{4,\\} \\(.*" org-fontify-whole-headline-regexp "\\)")))
        (font-lock-add-keywords nil
         `((,heading-1-regexp 1 'org-level-1 t)
           (,heading-2-regexp 1 'org-level-2 t)
           (,heading-3-regexp 1 'org-level-3 t)
           (,heading-4-regexp 1 'org-level-4 t)))))

    (add-hook 'outline-minor-mode-hook
              'leuven--outline-minor-mode-hook)

    ;; Add the following as the top line of your `.emacs':
    ;;
    ;; ; -*- mode: emacs-lisp; eval: (outline-minor-mode 1); -*-
    ;;
    ;; Now you can add `;;' and `;;*', etc. as headings in your `.emacs'
    ;; and cycle using `<S-tab>', `<M-left>' and `<M-right>' will collapse
    ;; or expand all headings respectively. I am guessing you mean to make
    ;; segments such as `;; SHORTCUTS' and `;; VARIABLES', this will do
    ;; that, but not too much more.
    )
#+end_src

For Elisp, Stefan Monnier additionally uses:

#+begin_src emacs-lisp
    (add-hook 'outline-minor-mode-hook
              (lambda ()
                (when (and outline-minor-mode (derived-mode-p 'emacs-lisp-mode))
                  (hide-sublevels 1000))))
#+end_src

which starts outline-minor-mode by hiding all the bodies of functions. He also
uses =reveal-mode= which automatically unhides the bodies when you try to move
the cursor into them (so you don't need to remember the key sequences to use
for opening/closing elements).

*** org-global-cycle + outline-magic

The visibility-cycling features are written in a way that they are independent
of the outline setup. The following setup provides standard Org mode
functionality (headline folding and unfolding) in =outline-minor-mode= on
=<C-tab>= and =<S-tab>=. We use =<C-tab>= instead of =<tab>=, because =<tab>= usually
has mode-specific tasks.

Note that for =<C-tab>= to work, the cursor needs to be on a headline (the line
where the ellipsis shows).

#+begin_src emacs-lisp
  ;; (add-hook 'outline-minor-mode-hook
  ;;   (lambda ()
  ;;     (define-key outline-minor-mode-map [(control tab)] 'org-cycle)
  ;;     (define-key outline-minor-mode-map [(shift tab)] 'org-global-cycle))) ;; backtab?
#+end_src

Now doing

    M-x find-library RET ox.el RET

    S-TAB (one or more times)

will give you a give quick overview of all the function names.

Or check out ~outline-magic.el~, which does this and also provides promotion and
demotion functionality.

*** org

#+begin_src emacs-lisp
  (global-set-key
    (kbd "<S-tab>") 'org-cycle) ; that works (but on level 1+)
  ;; TODO Look at org-cycle-global and local below, they work better, but
  ;; still on level 1+
  ;; TODO Replace it by a function which alternatively does `hide-body' and
  ;; `show-all'
#+end_src

*** org-struct-mode

> Experienced users use outline-minor-mode - It takes time to getting used to
> it.

You can also use =orgstruct-mode=, a minor mode that comes with =org-mode=.

=org-global-cycle= (!= =org-cycle-global=) now works fine in buffers using
=orgstruct-mode=.

As for handling "large" files, I use this:

#+begin_src emacs-lisp
  ;; from Bastien

  ;; XXX 2010-06-21 Conflicts with outline-minor-mode bindings
  ;; add a hook to use `orgstruct-mode' in Emacs Lisp buffers
  (add-hook 'emacs-lisp-mode-hook 'orgstruct-mode)

  (defun org-cycle-global ()
    (interactive)
    (org-cycle t))

  (global-set-key ;; ok on Elisp, not on LaTeX
    (kbd "C-M-]") 'org-cycle-global) ;; <S-tab>?

  ;; (defun org-cycle-local ()
  ;;   (interactive)
  ;;   (save-excursion
  ;;     (move-beginning-of-line nil)
  ;;     (org-cycle)))

  (defun org-cycle-local ()
    (interactive)
    (ignore-errors
      (end-of-defun)
      (beginning-of-defun))
    (org-cycle))

  (global-set-key ;; ok on Elisp, not on LaTeX
    (kbd "M-]") 'org-cycle-local)

;; C-M-] and M-] fold the whole buffer or the current defun.
#+end_src

I made a video to demonstrate it quickly: [[https://vimeo.com/55570133][navigating-emacs]].

This helps me survive in files like ~org.el~ and ~org-agenda.el~.

*** fold-dwim-org

#+begin_src emacs-lisp
  ;; unified user interface for Emacs folding modes, bound to Org
  ;; key-strokes
  (GNUEmacs
    (try-require 'fold-dwim-org-XXX))
#+end_src

#+begin_src emacs-lisp
  ;; 25.8.2
  (global-set-key
    (kbd "<M-f6>") 'visible-mode)
#+end_src

** Boxquote

Use Unicode characters.

#+begin_src emacs-lisp
;;** (info "(emacs-goodies-el)boxquote")

  (leuven--section "(emacs-goodies-el)boxquote")

  (when (locate-library "boxquote")

    ;; quote text with a semi-box
    (autoload 'boxquote-region "boxquote"
      "Draw a box around the left hand side of a region bounding START and END." t)

    (with-eval-after-load "boxquote"
      (setq boxquote-top-and-tail "")
      (setq boxquote-title-format " %s")
      (setq boxquote-top-corner    "  ")
      (setq boxquote-side          "   ")
      (setq boxquote-bottom-corner "  ")))
#+end_src

In Gnus, you can mark some region with enclosing tags by pressing =C-c M-m=
(=message-mark-inserted-region=) or by clicking on =<menu-bar> <Message> <Insert
Region Marked>=.

#+begin_example
--8<---------------cut here---------------start------------->8---
...
...
...
--8<---------------cut here---------------end--------------->8---
#+end_example

** Phonetic

#+begin_src emacs-lisp
;;** (info "phonetic")

  (leuven--section "phonetic")

  ;; phonetic spelling
  (when (locate-library "phonetic")
    (autoload 'phonetize-region "phonetic"
      "Translate the region according to the phonetic alphabet." t))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 25 ends here
#+end_src

* Org Mode (Getting Things Done)
  :PROPERTIES:
  :ID:       737b836b-ac1f-4120-94ca-c9e0282268f0
  :END:

- 40 variables most frequently customized in Org
  http://orgmode.org/worg/org-configs/org-customization-survey.html

- Org config examples
  http://repo.or.cz/w/Worg.git/tree/HEAD:/org-configs

#+begin_src emacs-lisp
;;* 25.9 Org Mode

;; (info "(org)Top") outline-based notes management and organizer

(leuven--chapter leuven-chapter-25.9-org-mode "25.9 Getting Things Done (with Org mode)"
#+end_src

After all the configuration has been done, you can easily manage your daily
work and tasks with Org mode.

#+begin_src emacs-lisp
;;* 1 (info "(org)Introduction")

;;** 1.2 (info "(org)Installation")

  ;; autoload functions
  (GNUEmacs
    (unless (try-require 'org-loaddefs)
      (try-require 'org-install)))      ; obsolete since Emacs 24.3

  ;; getting started
  (GNUEmacs
    (add-to-list 'auto-mode-alist '("\\.txt\\'" . org-mode))
    (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
    (add-to-list 'auto-mode-alist '("\\.org_archive\\'" . org-mode)))

  (define-key global-map
    (kbd "C-c l") 'org-store-link)
  (define-key global-map
    (kbd "C-c c") 'org-capture)
  (define-key global-map
    (kbd "C-c b") 'org-switchb)
  (define-key global-map
    (kbd "C-c a") 'org-agenda)

  ;; using links outside Org
  (global-set-key
    (kbd "C-c L") 'org-insert-link-global)
  (global-set-key
    (kbd "C-c o") 'org-open-at-point-global)

  ;; display the Org mode manual in Info mode
  (define-key global-map
    (kbd "C-h o") 'org-info)
#+end_src

These variables need to be set before Org mode is loaded.

#+begin_src emacs-lisp
  ;; These variables need to be set before org.el is loaded...

  ;; face to be used by `font-lock' for highlighting in Org mode Emacs
  ;; buffers, and tags to be used to convert emphasis fontifiers for HTML
  ;; export
  (setq org-emphasis-alist ;; remove the strike-through emphasis
        '(("*" bold "<b>" "</b>")
          ("/" italic "<i>" "</i>")
          ("_" underline "<span style=\"text-decoration:underline;\">" "</span>")
          ("=" org-code "<code>" "</code>" verbatim)
          ("~" org-verbatim "<code>" "</code>" verbatim)))

  ;; (setq org-emphasis-alist
  ;;       '(("&" (:weight ultra-bold :foreground "#000000" :background "#FBFF00"))
  ;;         ;; ("?" (:box t))
  ;;         ("^" (:weight ultra-bold :foreground "#393D90"))
  ;;         ("!" (:weight ultra-bold :foreground "#B40000")) ;; = alert in some Wikis
  ;;         ("*" bold "<b>" "</b>")
  ;;         ("/" italic "<i>" "</i>")
  ;;         ("_" underline "<span style=\"text-decoration:underline;\">" "</span>")
  ;;         ("=" org-code "<code>" "</code>" verbatim)
  ;;         ("~" org-verbatim "<code>" "</code>" verbatim)))

  ;; single character alphabetical bullets are allowed
  (setq org-list-allow-alphabetical t)
#+end_src

If you use =org-emphasis-alist= to do simple highlighting, you should better use
[[http://www.emacswiki.org/emacs/AddKeywords][font-lock-add-keywords]].

#+begin_src emacs-lisp
  ;; libraries that should (always) be loaded along with `org.el'
  ;; (loaded when opening the first Org file)
  (setq org-modules nil)
#+end_src

Original value was:
- =org-bbdb=
- =org-bibtex=
- =org-docview=
- =org-gnus=
- =org-info=
- =org-jsinfo=
- =org-irc=
- =org-mew=
- =org-mhe=
- =org-rmail=
- =org-vm=
- =org-w3m=
- =org-wl=

When you have =org-id= in =org-modules=, unique *ID's* are generated when you link
to a task (using =org-id-get-create=) --- instead of links containing *headline
text*.

ID's are saved in =~/.emacs.d/.org-id-locations= on my system (see
=org-id-locations-file=).

#+begin_src emacs-lisp
  ;; globally unique ID for Org mode entries (see `org-store-link')
  ;; (takes care of automatically creating unique targets for internal
  ;; links, see `C-h v org-id-link-to-org-use-id <RET>')
  (add-to-list 'org-modules 'org-id)
#+end_src

#+begin_src emacs-lisp
  ;; support for links to Gnus groups and messages from within Org mode
  (add-to-list 'org-modules 'org-gnus)
#+end_src

#+begin_src emacs-lisp
  ;; habit tracking code for Org mode
  (add-to-list 'org-modules 'org-habit)
#+end_src

#+begin_src emacs-lisp
  ;; make sure to turn `org-info' on in order to link to info nodes
  (add-to-list 'org-modules 'org-info)
#+end_src

*************** TODO Look at other modules
- =org-eval=
- =org-eval-light=
- =org-exp-bibtex=
- =org-exp-blocks= (supported by the new exporter out of the box)
- =org-man=
- =org-mouse=
- =org-mtags=
- =org-panel=
- =org-R=
*************** END

#+begin_src emacs-lisp
  ;; Unhiding edited areas
  ;;??? I like the idea of clustering undo but find it disconcerting
  (setf org-self-insert-cluster-for-undo nil) ;; XXX undefined
  ;; somebody, I think Carsten, suggested this, and it might work for
  ;; you, but for some reason I commented it out. I don't remember what
  ;; the reason was. Maybe speed.
  (defadvice undo (after leuven-org-undo-reveal activate)
    "Make point and context visible after an undo command in Org mode."
    (message "Using adviced undo") (sit-for 1)
    (and (derived-mode-p 'org-mode)
         (org-reveal)))
  ;;(ad-unadvise 'undo)
#+end_src

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              ;; (local-set-key
              ;;  (kbd "M-n") 'outline-next-visible-heading)
              ;; (local-set-key
              ;;  (kbd "M-p") 'outline-previous-visible-heading)

              ;; ;; create a binding for `org-show-subtree'
              ;; (org-defkey org-mode-map
              ;;             (kbd "C-c C-S-s") 'org-show-subtree)
              ;; (org-defkey org-mode-map
              ;;             (kbd "C-c s") 'org-show-subtree)

              (local-set-key
                (kbd "C-c h") 'hide-other)

              ;; table
              (local-set-key
               (kbd "C-M-w") 'org-table-copy-region)
              (local-set-key
               (kbd "C-M-y") 'org-table-paste-rectangle)
              (local-set-key
               (kbd "C-M-l") 'org-table-sort-lines)))
#+end_src

*** Activation

#+begin_src emacs-lisp
  (with-eval-after-load "org"
    (message "... Org Introduction")

;;** 1.3 (info "(org)Activation")

    (leuven--section "1.3 (org)Activation")

    ;; insert the first line setting Org mode in empty files
    (setq org-insert-mode-line-in-empty-file t))
#+end_src

** Document Structure

#+begin_src emacs-lisp
;;* 2 (info "(org)Document Structure")

  ;; ellipsis to use in the Org mode outline
  (with-eval-after-load "org"
    (message "... Org Document Structure")

    ;; improve display of the ellipsis
    (set-face-attribute 'org-ellipsis nil
                        :box '(:line-width 1 :color "#999999")
                        :foreground "#999999" :background "#FFF8C0"
                        :underline nil)

    (setq org-ellipsis
          (if (char-displayable-p ?\u25B7) ;; white right-pointing triangle
              ;; this test takes ~ 0.40s; hence, wrapped in eval-after-load
              " \u25B7" ;; string
            'org-ellipsis))) ;; face

  ;; <RET> follows links (except in tables)
  (setq org-return-follows-link t)

  ;; blank lines
  (setq org-blank-before-new-entry
        '(
          ;; insert  a blank line before new heading
          (heading . t)

          ;; try to make an intelligent decision whether to insert a
          ;; blank line or not before a new item
          (plain-list-item . auto)))
#+end_src

*** Headlines

=C-e= goes *right before* the end of the invisible region and =TAB= will unfold as
expected, both in a folded subtree or in a folded drawer.

#+begin_src emacs-lisp
;;** (info "(org)Headlines")

  (leuven--section "2.2 (org)Headlines")

  ;; ;; `C-a' and `C-e' behave specially in headlines and items
  (setq org-special-ctrl-a/e 'reversed)
#+end_src

The package =org-inlinetask.el= (for *tasks independent of outline hierarchy*)
installs the key binding =C-c C-x t= to insert a new *inline task*.

#+begin_src emacs-lisp
  (with-eval-after-load "org"
    (message "... Org Headlines")

    ;; insert an inline task (independent of outline hierarchy)
    (when (try-require 'org-inlinetask) ;; needed

      ;; initial state (TODO keyword) of inline tasks
      (setq org-inlinetask-default-state "TODO")

      ;; (defun org-html-format-inlinetask (todo type priority name tags
      ;;                                    contents)
      ;;   "Format an inline task element for HTML export."
      ;;   (let ((full-title
      ;;          (concat
      ;;           (when todo
      ;;             (format "\\textbf{\\textsf{\\textsc{%s}}} " todo))
      ;;           (when priority (format "\\framebox{\\#%c} " priority))
      ;;           title
      ;;           (when tags (format "\\hfill{}\\textsc{%s}" tags)))))
      ;;     (format (concat "<div class=\"inlinetask\">\n"
      ;;                     "  <b>%s</b><br/>\n"
      ;;                     "  %s\n"
      ;;                     "</div>")
      ;;             full-title
      ;;             contents)))

      ;; template for inline tasks in LaTeX exporter
      (defun org-latex-format-inlinetask (todo type priority name tags contents)
        "Format an inline task element for LaTeX export."
        (let* ((tags-string (format ":%s:" (mapconcat 'identity tags ":")))
               (opt-color
                (if tags
                    (cond ((string-match ":info:" tags-string)
                           "color=yellow!40")
                          ((string-match ":warning:" tags-string)
                           "color=orange!40")
                          ((string-match ":error:" tags-string)
                           "color=red!40")
                          (t ""))
                  ""))
               (full-title
                (concat
                 (when todo
                   (format "{\\color{red}\\textbf{\\textsf{\\textsc{%s}}}} " todo))
                 (when priority
                   (format "\\textsf{\\framebox{\\#%c}} " priority))
                 title
                 (when tags
                   (format "\\hfill{}:%s:"
                           (mapconcat 'identity tags ":")))))
               (opt-rule
                (if contents
                    "\\\\ \\rule[.3em]{\\textwidth}{0.2pt}\n"
                  ""))
               (opt-contents
                (or contents "")))
          ;; this requires the `todonotes' package
          (format (concat "\\todo[inline,caption={},%s]{\n"
                          "  %s\n"
                          "  %s"
                          "  %s"
                          "}")
                  opt-color
                  full-title
                  opt-rule
                  opt-contents)))

      ;; function called to format an inlinetask in LaTeX code
      (setq org-latex-format-inlinetask-function
            'org-latex-format-inlinetask))

    ) ;; eval-after-load "org" ends here
#+end_src

*************** TODO Have a solution for base article, report, book (w/o todonotes)

*** Visibility cycling

#+begin_src emacs-lisp
;;** (info "(org)Visibility cycling")

  (leuven--section "2.3 (org)Visibility cycling")

  ;; do not switch to OVERVIEW at startup
  (setq org-startup-folded nil)

  ;; inhibit startup when preparing agenda buffers -- agenda optimization
  (setq org-agenda-inhibit-startup t)
#+end_src

Display outline path in mode line:

#+begin_src emacs-lisp
  ;; (add-hook 'org-mode-hook
  ;;           (lambda()
  ;;             (add-to-list 'mode-line-format
  ;;                          '(:eval (org-propertize
  ;;                                   (org-display-outline-path nil t " / " t)
  ;;                                   'face 'mode-line-emphasis
  ;;                                   'help-echo "Outline path")) t)))
#+end_src

*************** TODO Fix Error during redisplay
(eval (org-propertize (org-display-outline-path nil t " / " t) (quote face) (quote mode-line-emphasis) (quote help-echo) "Outline path")) signaled (wrong-type-argument stringp nil)
*************** END

*** 2.4 Motion

#+begin_src emacs-lisp
;;** (info "(org)Motion")

  (leuven--section "2.4 (org)Motion")

  ;; outline-node based navigation similar to the behavior of paredit-mode in
  ;; Lisp files
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key
               (kbd "\C-\M-n") 'outline-next-visible-heading)
              (local-set-key
               (kbd "\C-\M-p") 'outline-previous-visible-heading)
              (local-set-key
               (kbd "\C-\M-u") 'outline-up-heading)))
#+end_src

Move through an Org file like =cd= on a file system with =org-goto=:
=C-c C-j /foo/bar/baz <RET>=

vs =C-u C-c C-j=

#+begin_src emacs-lisp
  ;; headlines in the current buffer are offered via completion
  ;; (interface also used by the `refile' command)
  (setq org-goto-interface 'outline-path-completion)
#+end_src

#+begin_src emacs-lisp
  ;; must be in eval-after-load "org"?
  ;; (define-key org-mode-map
  ;;   (kbd "C-c C-r") 'leuven-org-reveal)

  (defun leuven-org-reveal (&optional all-siblings)
    "For `C-u C-c C-r', it does the same as default org-mode --- shows all
  hidden siblings, and for `C-c C-r' --- all siblings of current level."
    (interactive "P")
    (if all-siblings
        (org-reveal t)
      (org-show-siblings)))
#+end_src

See also [[*Sparse%20trees][Sparse trees]] for behavior when revealing a location.

*** Structure editing

#+begin_src emacs-lisp
;;** (info "(org)Structure editing")

  (leuven--section "2.5 (org)Structure editing")

  ;; ;; FIXME Choose the right value!
  ;; (setq org-M-RET-may-split-line nil)
#+end_src

*** Sparse trees
    :PROPERTIES:
    :ID:       a9fe61b7-cdbd-478e-a4af-da9e122fb2d9
    :END:

#+begin_src emacs-lisp
;;** (info "(org)Sparse trees")

  (leuven--section "2.6 (org)Sparse trees")

  ;; show full hierarchy when revealing a location
  (setq org-show-hierarchy-above t)

  ;; don't show following heading when revealing a location
  (setq org-show-following-heading nil)

  ;; don't show all sibling headings when revealing a location
  (setq org-show-siblings nil)

  ;; show the entry below a headline when revealing a location
  (setq org-show-entry-below t)
  (setq org-show-entry-below '((org-goto . t)))
#+end_src

*** Plain lists

#+begin_src emacs-lisp
;;** (info "(org)Plain lists")

  (leuven--section "2.7 (org)Plain lists")

  ;; maximum indentation for the second line of a description list
  (setq org-description-max-indent 3)

  ;; don't make tab cycle visibility on plain list items
  (setq org-cycle-include-plain-lists nil)

  ;; an empty line does not end all plain list levels
  (setq org-empty-line-terminates-plain-lists nil)
#+end_src

*** Footnotes

#+begin_src emacs-lisp
;;** (info "(org)Footnotes")

  (leuven--section "2.10 (org)Footnotes")

  ;; use `C-c C-x f' to add a footnote, to go back to the message
  ;; *and* to go to a footnote
  (global-set-key
    (kbd "C-c C-x f") 'org-footnote-action)
#+end_src

** Tables

See [[http://orgmode.org/worg/org-tutorials/org-spreadsheet-intro.html][Org as a spreadsheet system: a short introduction]].

#+begin_src emacs-lisp
;;* 3 (info "(org)Tables")

  (setq org-table-use-standard-references 'from)

;;** 3.1 The (info "(org)Built-in table editor")

  (leuven--section "3.1 The (org)Built-in table editor")

  ;; default export parameters for `org-table-export'
  (setq org-table-export-default-format "orgtbl-to-csv")

;;** 3.5 (info "(org)The spreadsheet")

  (leuven--section "3.5 (org)The spreadsheet")

  ;; FIXME Only set `calc-internal-prec' to 12 [default: 8]
  (setq org-calc-default-modes
        '(calc-internal-prec 12
          calc-float-format  (float 12)
          calc-angle-mode    deg
          calc-prefer-frac   nil
          calc-symbolic-mode nil
          calc-date-format (YYYY "-" MM "-" DD " " Www (" " hh ":" mm))
          calc-display-working-message t))
#+end_src

To *update all tables* in a file, use =org-table-recalculate-buffer-tables= if the
dependencies are only backwards.

If you have dependencies in both directions, to iterate all tables in a file,
in order to converge table-to-table dependencies, use
=org-table-iterate-buffer-tables=.

** Hyperlinks

#+begin_src emacs-lisp
;;* 4 (info "(org)Hyperlinks")
#+end_src

*** External links

#+begin_src emacs-lisp
  (with-eval-after-load "org"
    (message "... Hyperlinks")

    ;; open non-existing files
    (setq org-open-non-existing-files t)

    ;; function and arguments to call for following `mailto' links
    (setq org-link-mailto-program '(compose-mail "%a" "%s")))
#+end_src

#+begin_src emacs-lisp
  ;; support for links to Gnus groups and messages from within Org mode
  (with-eval-after-load "org-gnus"

    ;; create web links to Google groups or Gmane (instead of Gnus
    ;; messages)
    (setq org-gnus-prefer-web-links t))
#+end_src

*** Handling links

#+begin_src emacs-lisp
  ;; global identifiers for Org-mode entries
  (with-eval-after-load "org-id"

    ;; storing a link to an Org file will use entry IDs
    (setq org-id-link-to-org-use-id
          'create-if-interactive-and-no-custom-id))
#+end_src

PDF viewer? See =org-file-apps=. Just change to your favorite viewer. And make
sure that you're calling =org-return= to open (it's bound to =C-m=).

If I inline an image in an Org file, I can toggle its display with =C-c C-x C-v=
and resize it to a specific width.

#+begin_src emacs-lisp
  (with-eval-after-load "org"
    (message "... Handling links")

    ;; 4.4 show inline images when loading a new Org file
    (setq org-startup-with-inline-images t)

    ;; 4.4 try to get the width from an #+ATTR.* keyword and fall back on the
    ;; original width if none is found
    (setq org-image-actual-width nil)
#+end_src

*** Link abbreviations

Link abbreviations provide a quick way of linking to resources that are
frequently referenced, so that you can type just the key term instead of the
complete URL.

Here is an example: every time you need to use
http://www.google.com/search?q=searchterms, you can just type
=[[google:searchterms]]= or =[[google:searchterms][description]]= instead.

#+begin_src emacs-lisp
    ;; shortcut links
    (setq org-link-abbrev-alist
          '(("cache" .
             "http://www.google.com/search?q=cache:%s")
            ("dictionary" .
             "http://www.dict.org/bin/Dict?Database=*&Form=Dict1&Strategy=*&Query=%s")
            ("google" .
             "http://www.google.com/search?q=%s")
            ("googlegroups" .
             "http://groups.google.com/groups?q=%s")
            ("googlemaps" .
             "http://maps.google.com/maps?q=%s")
            ("imdb" .
             "http://us.imdb.com/Title?%s")
            ("openstreetmap" .
             "http://nominatim.openstreetmap.org/search?q=%s&polygon=1")
            ("wpen" .
             "http://en.wikipedia.org/wiki/%s")
            ("wpfr" .
             "http://fr.wikipedia.org/wiki/%s"))))
#+end_src

** "TODO" Items

#+begin_src emacs-lisp
;;* 5 (info "(org)TODO Items")
#+end_src

*** Basic TODO functionality

#+begin_src emacs-lisp
;;** 5.1 (info "(org)TODO basics") functionality

  (leuven--section "5.1 (org)TODO basics functionality")

  ;; 5.1 select a TODO state and bypass any logging associated with that
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)

  ;; some commands act upon headlines in the active region
  (setq org-loop-over-headlines-in-active-region 'start-level)
#+end_src

*** Extended use of TODO keywords

We use statuses to *create a workflow* for tasks.

The statuses we use are a simple as possible to work well in the context of
work.

We use the following 4-letter status keywords:

- TODO :: Approved task, to be done.
- STRT :: Some progress has already been done on the task.
- DLGT :: Task delegated to someone else.
- WAIT :: Waiting for some external event to be able to work on the task.
- DFRD :: Task to be approved (and eventually done) in the future.
- DONE :: Task is completed.
- CANX :: Task is declined (but kept documented, instead of being deleted).

There is just 1 exception (made on purpose) to the 4-letter scheme:

- NEW :: Proposed task, idea or wish, *not approved yet*. Draft.

One could add a =CLSD= or =VRFD= state for bug fixes, for example, which need to be
verified before really closing the task.

#+begin_src emacs-lisp
;;** 5.2 Use of (info "(org)TODO extensions")

  (leuven--section "5.2 Use of (org)TODO extensions")

  ;; list of TODO entry keyword sequences and their interpretation (for
  ;; the different task states)
  (setq org-todo-keywords
        '((sequence "NEW(n!)"   ;; proposal
                    "TODO(t!)"  ;; open, not started
                    "STRT(s!)"  ;; in progress
                    "WAIT(w!)"  ;; on hold
                    "DLGT(l!)"  ;; assigned, feedback
                    "DFRD(f!)"  ;; someday, maybe, perhaps, may be undertaken in the future, wish
                    "|"
                    "DONE(d!)"  ;; completed, closed, resolved
                    "CANX(x!)") ;; wontfix, rejected
          (sequence "QTE(q!)" "QTD(Q!)" "|"
                    "APP(A!)" "EXP(E!)" "REJ(R!)")
          (sequence "OPENPO(O!)" "|"
                    "CLSDPO(C!)")))
#+end_src

=DFRD= is *not* a completion state (in order not to be struck through).

#+begin_src emacs-lisp
  (with-eval-after-load "org-faces"

    ;; faces for specific TODO keywords
    (setq org-todo-keyword-faces
          '(("NEW"  . leuven-org-created-kwd-face)
            ("TODO" . org-todo)
            ("STRT" . leuven-org-inprogress-kwd-face)
            ("DLGT" . leuven-org-delegated-kwd-face)
            ("WAIT" . leuven-org-delegated-kwd-face)
            ("DFRD" . leuven-org-deferred-kwd-face)
            ("DONE" . org-done)
            ("CANX" . org-done)

            ("QTE" . leuven-org-quote-kwd-face)
            ("QTD" . leuven-org-quoted-kwd-face)
            ("APP" . leuven-org-approved-kwd-face)
            ("EXP" . leuven-org-expired-kwd-face)
            ("REJ" . leuven-org-rejected-kwd-face)

            ("OPENPO" . leuven-org-openpo-kwd-face)
            ("CLSDPO" . leuven-org-closedpo-kwd-face)))

    ;; Org standard faces
    (set-face-attribute 'org-todo nil
                        :weight 'bold :box '(:line-width 1 :color "#D8ABA7")
                        :foreground "#D8ABA7" :background "#FFE6E4")

    (set-face-attribute 'org-done nil
                        :weight 'bold :box '(:line-width 1 :color "#BBBBBB")
                        :foreground "#BBBBBB" :background "#F0F0F0")

    ;; Org non-standard faces
    (defface leuven-org-created-kwd-face
      '((t (:weight normal :box (:line-width 1 :color "#EEE9C3")
            :foreground "#1A1A1A" :background "#FDFCD8")))
      "Face used to display state NEW.")
    (defface leuven-org-inprogress-kwd-face
      '((t (:weight bold :box (:line-width 1 :color "#D9D14A")
            :foreground "#D9D14A" :background "#FCFCDC")))
      "Face used to display state STRT.")
    (defface leuven-org-delegated-kwd-face
      '((t (:weight bold :box (:line-width 1 :color "#89C58F")
            :foreground "#89C58F" :background "#E2FEDE")))
      "Face used to display state DLGT or WAIT.")
    (defface leuven-org-deferred-kwd-face
      '((t (:weight bold :box (:line-width 1 :color "#9EB6D4")
            :foreground "#9EB6D4" :background "#E0EFFF")))
      "Face used to display state DFRD.")

    (defface leuven-org-quote-kwd-face
      '((t (:weight bold :box (:line-width 1 :color "#FC5158")
            :foreground "#FC5158" :background "#FED5D7")))
      "Face used to display .")
    (defface leuven-org-quoted-kwd-face
      '((t (:weight bold :box (:line-width 1 :color "#55BA80")
            :foreground "#55BA80" :background "#DFFFDF")))
      "Face used to display .")
    (defface leuven-org-approved-kwd-face
      '((t (:weight bold :box (:line-width 1 :color "#969696")
            :foreground "#969696" :background "#F2F2EE")))
      "Face used to display .")
    (defface leuven-org-expired-kwd-face
      '((t (:weight bold :box (:line-width 1 :color "#42B5FF")
            :foreground "#42B5FF" :background "#D3EEFF")))
      "Face used to display state EXPIRED.")
    (defface leuven-org-rejected-kwd-face
      '((t (:weight bold :box (:line-width 1 :color "#42B5FF")
            :foreground "#42B5FF" :background "#D3EEFF")))
      "Face used to display state REJECTED.")

    (defface leuven-org-openpo-kwd-face
      '((t (:weight bold :box (:line-width 1 :color "#FC5158")
            :foreground "#FC5158" :background "#FED5D7")))
      "Face used to display OPEN purchase order.")
    (defface leuven-org-closedpo-kwd-face
      '((t (:weight bold :box (:line-width 1 :color "#969696")
            :foreground "#969696" :background "#F2F2EE")))
      "Face used to display CLOSED purchase order."))
#+end_src

#+begin_src emacs-lisp
  ;; block switching entries to DONE if
  ;; 1) there are undone child entries, or
  ;; 2) the parent has an `:ORDERED:' property and there are prior
  ;;    siblings not yet done
  (setq org-enforce-todo-dependencies t)
#+end_src

#+begin_src emacs-lisp
  ;; 5.2.7 don't dim blocked tasks in the agenda display -- agenda optimization
  (setq org-agenda-dim-blocked-tasks nil) ; XXX not sure about this one
#+end_src

#+begin_src emacs-lisp
  ;; block switching the parent to DONE if
  ;; there are unchecked checkboxes
  (setq org-enforce-todo-checkbox-dependencies t)
#+end_src

*** Progress logging

#+begin_src emacs-lisp
;;** 5.3 (info "(org)Progress logging")

  (leuven--section "5.3 (org)Progress logging")

  ;; 5.3.1 insert a CLOSED time stamp each time a TODO entry is marked DONE
  (setq org-log-done nil)

  ;; 5.3.2 the notes will be ordered according to time
  (setq org-log-states-order-reversed nil)

  ;; 5.3.2 insert state change notes and time stamps into a LOGBOOK drawer
  (setq org-log-into-drawer t) ;; should be the default

  ;; ~5.3.2 heading for state change added to entries
  (with-eval-after-load "org"
    (message "... Progress logging")

    (setcdr (assq 'state org-log-note-headings)
            "State %-12S  ->  %-12s %t"))
#+end_src

Warning! The docstring of =org-log-note-headings= mentions that "in fact, it is
*not a good idea to change the `state' entry*, because agenda log mode depends
on the format of these entries."

#+begin_src emacs-lisp
  (with-eval-after-load "org-habit"

    ;; show habits for future days
    (setq org-habit-show-habits-only-for-today nil)

    ;; use character "heavy check mark" to show completed days on which
    ;; a task was done
    (setq org-habit-completed-glyph ?\u2714)

    ;; use character "heavy quadruple dash vertical" to identify today
    (setq org-habit-today-glyph ?\u250B))
#+end_src

*** Breaking down tasks

#+begin_src emacs-lisp
;;** 5.5 (info "(org)Breaking down tasks")

  (leuven--section "5.5 (org)Breaking down tasks")

  ;; automatically change a TODO entry to DONE when all children are done
  (defun org-summary-todo (n-done n-not-done)
    "Switch entry to DONE when all subentries are done, to TODO otherwise."
    (let (org-log-done org-log-states) ;; turn off logging
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

  (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+end_src

** Tags

Context (place, time or particular resources for doing a task) and people are
something best implemented with tags.

By convention, *user-defined tags are written in lowercase*; built-in tags with
special meaning are written with all capitals.

=org-use-tag-inheritance= can be setup to a regular expression, for example so
that all tags starting with =@= or =#= will be excluded from inheritance with:

#+begin_example
(setq org-use-tag-inheritance "^[^@#]")
#+end_example

#+begin_src emacs-lisp
;;* 6 (info "(org)Tags")

  ;; column to which tags should be indented in a headline
  (setq org-tags-column -79)

  ;; 6.2 list of tags ("contexts") allowed in Org mode files
  (setq org-tag-alist '((:startgroup . nil)
                         ("home"       . ?h)
                         ("work"       . ?w)
                        (:endgroup . nil)
                        ("errands"     . ?e)
                        ("phone"       . ?p)
                        ("mail"        . ?m)

                        ("bank"        . ?b)
                        ("notbillable" . ?B)
                        ("now"         . ?N)
                        ;; ("reading" . ?r)
                        ;; ("proj" . ?P)

                        ("ARCHIVE"     . ?A)
                        ("crypt"       . ?C)
                        ("FLAGGED"     . ??)))

  ;; faces for specific tags
  (setq org-tag-faces
        '(("refile"
           (:slant italic
            :foreground "#FFFFFF" :background "#A48CC4"))
          ("home"
           (:slant italic
            :foreground "#5C88D3" :background "#BBDDFF"))
          ("work"
           (:slant italic
            :foreground "#5F7C43" :background "#C1D996"))
          ("FLAGGED"
           (:slant italic
            :foreground "#A28747" :background "#FFE88E"))
          ("now"
           (:slant italic
            :foreground "#000000" :background "#FFEA80"))
          ("notbillable"
           (:slant italic
            :foreground "#FFFFFF" :background "#989898"))))

  ;; 6.2 exit fast tag selection after first change (toggle this with `C-c')
  (setq org-fast-tag-selection-single-key t)
#+end_src

*************** TODO Extend the following function to take =filetags= into account

*************** TODO Check whether this function removes tags of DIRECT parent

#+begin_src emacs-lisp
  ;; remove redundant tags of headlines (from David Maus)
  (defun leuven--org-remove-redundant-tags ()
    "Remove redundant tags of headlines in current buffer.

  A tag is considered redundant if it is local to a headline and inherited by
  a parent headline."
    (interactive)
    (when (eq major-mode 'org-mode)
      (save-excursion
        (org-map-entries
         '(lambda ()
            (let ((alltags (split-string
                            (or (org-entry-get (point) "ALLTAGS") "")
                            ":"))
                  local inherited tag)
              (dolist (tag alltags)
                (if (get-text-property 0 'inherited tag)
                    (push tag inherited) (push tag local)))
              (dolist (tag local)
                (if (member tag inherited) (org-toggle-tag tag 'off)))))
         t nil))))

  ;; ;; always offer completion for all tags of all agenda files
  ;; (setq org-complete-tags-always-offer-all-agenda-tags t)
#+end_src

** Properties and Columns

By convention, *user-defined properties are capitalized*; built-in properties
with special meaning are written with all capitals.

#+begin_src emacs-lisp
;;* 7 (info "(org)Properties and Columns")

;;** 7.1 (info "(org)Property syntax")

  (leuven--section "7.1 (org)Property syntax")

  ;; list of property/value pairs that can be inherited by any entry
  (setq org-global-properties
        '(("Effort_ALL" .
           "0 0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 8:00"
           ;; "0d 1d 2d 3d 4d 5d 6d 7d 8d 10d"
           )))
#+end_src

** Dates and Times

#+begin_src emacs-lisp
;;* 8 (info "(org)Dates and Times")

  (leuven--section "8 (org)Dates and Times")

  ;; insinuate appt if Org mode is loaded
  (with-eval-after-load "org"
    (message "... Org Dates and Times")

    (try-require 'appt))
#+end_src

*** Creating time stamps

#+begin_src emacs-lisp
;;** 8.2 (info "(org)Creating timestamps")

  (leuven--section "8.2 (org)Creating time stamps")

  ;; prefer the future for incomplete dates
  (setq org-read-date-prefer-future 'time)

  ;; ;; advise `org-read-date' to bury the calendar buffer after selecting
  ;; ;; a date, so it is out of the way
  ;; (defadvice org-read-date
  ;;   (after leuven-bury-calendar-after-org-read-date
  ;;          (&optional with-time to-time from-string prompt
  ;;          default-time default-input) protect)
  ;;   "Bury the *Calendar* buffer after reading a date."
  ;;   (bury-buffer "*Calendar*"))
  ;; (ad-activate 'org-read-date)

  ;; number of minutes to round time stamps to
  (setq org-time-stamp-rounding-minutes '(1 1))
#+end_src

*** Deadlines and scheduling

#+begin_src emacs-lisp
;;** 8.3 (info "(org)Deadlines and scheduling")

  (leuven--section "8.3 (org)Deadlines and scheduling")
#+end_src

#+begin_src emacs-lisp
  ;; information to record when the scheduling date is modified
  (setq org-log-reschedule nil)

  ;; information to record when the deadline date is modified
  (setq org-log-redeadline 'time)
#+end_src

**** Inserting deadline/schedule

Schedule it with =C-c C-s=:

- RET ::
     Today.

- +1d RET ::
     Tomorrow.

- +1w RET ::
     Next week.

- +4w RET ::
     Next "month".

Remove scheduling date with =C-u C-c C-s=.

#+begin_src emacs-lisp
  ;; number of days before expiration during which a deadline becomes active
  (setq org-deadline-warning-days 7)

  ;; skip deadline prewarning (up to 7 days before the actual deadline)
  ;; when entry is also scheduled
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 7)

  ;; don't show deadlines when the corresponding item is done
  (setq org-agenda-skip-deadline-if-done t)

  ;; skip scheduling line if same entry shows because of deadline
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)

  ;; don't show scheduled items in agenda when they are done
  (setq org-agenda-skip-scheduled-if-done t)

  ;; ~8.3 don't select item by time stamp or -range if it is DONE
  (setq org-agenda-skip-timestamp-if-done t)

  ;; ;; show all days between the first and the last date
  ;; (setq org-timeline-show-empty-dates t)
#+end_src

**** Repeated tasks

#+begin_src emacs-lisp
  ;; TODO state to which a repeater should return the repeating task
  (setq org-todo-repeat-to-state "TODO")
#+end_src

*** Clocking work time

#+begin_src emacs-lisp
;;** 8.4 (info "(org)Clocking work time")

  (leuven--section "8.4 (org)Clocking work time")

  (global-set-key
    (kbd "C-c C-x C-i") 'org-clock-in)
  (global-set-key
    (kbd "C-c C-x C-j") 'org-clock-goto)
  (global-set-key
    (kbd "C-c C-x C-o") 'org-clock-out)

  ;; the time clocking code for Org mode
  ;; (try-require 'org-clock)
  ;;! needed for trying to automatically re-clock at Emacs startup
  ;; Alternative: resume clocks when opening the first Org file

  (with-eval-after-load "org-clock"

    ;; 8.4 save both the running clock and the entire clock history when Emacs
    ;; is closed, and resume it next time Emacs is started up
    (setq org-clock-persist t)

    ;; 8.4 set up hooks for clock persistence
    (org-clock-persistence-insinuate)

    ;; resume clocking task on clock-in if the clock is open
    (setq org-clock-in-resume t)

    ;; number of clock tasks to remember in history: 1-9A-Z
    (setq org-clock-history-length 35)

    ;; 8.4.2 include the current clocking task time in clock reports
    (setq org-clock-report-include-clocking-task t)

    ;; 8.4.2 format string used when creating CLOCKSUM lines and when generating a
    ;; time duration (avoid showing days)
    (setq org-time-clocksum-format
          '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))

    ;; ;; 8.4.2 use fractional times
    ;; (setq org-time-clocksum-use-fractional t)

    ;; format string for the total time cells
    (setq org-clock-total-time-cell-format "%s")

    ;; format string for the file time cells
    (setq org-clock-file-time-cell-format "%s")

    (defun leuven-org-clock-in-interrupted-task ()
      "Clock back into the task that has been interrupted, if there is one."
      (interactive)
      (if (and (not org-clock-resolving-clocks-due-to-idleness)
               (marker-buffer org-clock-marker)
               (marker-buffer org-clock-interrupted-task))
          (org-with-point-at org-clock-interrupted-task
            (org-clock-in nil))
        (org-clock-out)))

    (global-set-key
      (kbd "C-c C-x C-q") 'leuven-org-clock-in-interrupted-task)

    ;; 8.4.3 resolve open clocks if the user is idle more than 120 minutes
    (setq org-clock-idle-time 120)

    (defun leuven--org-switch-to-started (kwd)
      "Switch task state to STRT.

    Skip normal headlines and capture tasks."
      (if (and kwd
               (not (string-equal kwd "STRT"))
               (not (and (boundp 'org-capture-mode) org-capture-mode)))
          "STRT"
        nil))

    ;; 8.4.3 set task to todo state STRT while clocking it
    (setq org-clock-in-switch-to-state 'leuven--org-switch-to-started)

    ;; clock won't be stopped when the clocked entry is marked DONE
    (setq org-clock-out-when-done nil)

    ;; time included for the mode line clock is all time clocked into this
    ;; task today
    (setq org-clock-modeline-total 'today)
    (setq org-clock-modeline-total 'all)

    ;; get an alert (notification) when your planned time is over
    (setq org-clock-sound "~/Public/Music/Sounds/alarm.wav")
    ;;! Use start-process to have an external program play the sound to
    ;;! avoid ignored keystrokes until after the sound plays (start-process
    ;;! "ding" nil "play" "~/Public/Music/Sounds/alarm.wav")

    ;; remove the clock line when the resulting time is 0:00
    (setq org-clock-out-remove-zero-time-clocks t)

    ;; ;; when clocking into a task with a clock entry which has not been
    ;; ;; closed, resume the clock from that point
    ;; (setq org-clock-in-resume t)

    ;; ask the user if they wish to clock out before killing Emacs
    (defun leuven--org-query-clock-out ()
      "Ask the user before clocking out.

    This is a useful function for adding to `kill-emacs-query-functions'."
      (if (and (featurep 'org-clock)
               (funcall 'org-clocking-p)
               (y-or-n-p "You are currently clocking time, clock out? "))
          (org-clock-out)
        t)) ;; only fails on keyboard quit or error

    (add-hook 'kill-emacs-query-functions 'leuven--org-query-clock-out)

    ) ;; with-eval-after-load "org-clock" ends here
#+end_src

*** Effort estimates

If you have an =Effort= property defined, the *estimated time* is also shown in
the mode line, against the *actual time* spent (reported through *time clocking*).

When clocking in, ask for a time estimate if the property is not yet defined.

#+begin_src emacs-lisp
;;** 8.5 (info "(org)Effort estimates")

  (leuven--section "8.5 (org)Effort estimates")

  ;; add an effort estimate on the fly when clocking in
  (defun leuven--org-ask-effort ()
    "Ask for an effort estimate when clocking in."
    (unless (org-entry-get (point) "Effort")
      (let ((effort
             (completing-read
              "Estimated time (H:MM): "
              (org-entry-get-multivalued-property (point) "Effort"))))
        (unless (equal effort "")
          (org-set-property "Effort" effort)))))

  (add-hook 'org-clock-in-prepare-hook
            'leuven--org-ask-effort)
#+end_src

** Capture - Refile - Archive

*** Capture

The ultimate capture tool.

*************** TODO Look at =:kill-buffer=

#+begin_src emacs-lisp
;;* 9 (info "(org)Capture - Refile - Archive")

  (leuven--section "9.1 (org)Capture")

  ;; 9.1.2 directory with Org files
  (setq org-directory
        (directory-file-name ;; this function removes the final slash
         (cond ((file-directory-p "~/org/") "~/org/")
               (t "~/"))))

  ;; 9.1.2 default target for storing notes
  (setq org-default-notes-file
        (concat org-directory "/refile.org")) ;; Inbox for collecting
#+end_src

- Contacts
- Calendar
- Tasks
- Notes
- Journal

- Family
- Friends
- Future
- Graphics
- Languages
- Linux
- Magical Moments
- Networks
- Projects
- Traveling

%-escapes:

- %a ::
     Annotation (link)

- %i ::
     Initial content (selected text)

- %? ::
     Cursor position

- %^T ::
     Prompt for a date and time

- %^G ::
     Prompt for tags with completion on tags in all agenda files

- %t ::
     Time stamp (date only)

- %^{prompt} ::
     Prompt the user for a string

- %[file] ::
     Insert the contents of the file

- %U ::
     Inactive time stamp with date and time

Use =:jump-to-captured= to tell capture to jump to the note after storing it.

#+begin_src emacs-lisp
  ;; 9.1.2 templates for the creation of capture buffers

  ;; ("Receipt"   ?r "** %^{BriefDesc} %U %^g\n%?"   "~/Personal/finances.org")
  ;; ("Someday"   ?s "** %^{Someday Heading} %U\n%?\n"  "~/Personal/someday.org")

  ;; fast note taking in Org mode (the ultimate capture tool)
  (with-eval-after-load "org-capture"

    (add-to-list 'org-capture-templates
                 `("t" "Task" entry
                   (file+headline ,org-default-notes-file "Tasks")
                   "* NEW %^{Task}%?

%i"
                   :empty-lines 1) t)

    (add-to-list 'org-capture-templates
                 `("T" "Task in current file" entry
                   (file+headline
                    (buffer-file-name (org-capture-get :original-buffer))
                    "Tasks")
                   "* TODO %?
  %U %a %n"
                   :prepend t) t)

    (add-to-list 'org-capture-templates
                 `("a" "Appt" entry
                   (file+headline ,org-default-notes-file "Calendar")
                   "* %^{Appointment}%?
%^T

%i"
                   :empty-lines 1) t)
                   ;; TODO Prompt only for date, not time...
#+end_src

**** TODO Ask for refile location

Find a location for refiling on capture.

#+begin_src emacs-lisp
    (add-to-list 'org-capture-templates
                 `("Z" "Refile me!" entry
                   (function leuven-find-location)
                   "** TODO Put this in some other file\n\n"
                   :prepend t) t)

    (defun leuven-find-location ()
      "Find my Inbox file and some headline in the current buffer."
      (find-file "~/org/refile.org")
      (goto-char (point-min))
      (helm-org-headlines)
      (org-forward-heading-same-level 1))
#+end_src

**** Email-to-Org

Instantly *create tasks* and notes *from emails*.

The items item will be linked back to the the emails.

The following rules will apply:

- Task creator ::
     Sender's email.

- Task assignee ::
     Recipient(s)' email.

- Task Name ::
     Subject.

- Files ::
     Attachment(s).

- Task Description ::
     Email body (or selected region).

Additional parameters can be included via the commands you use:

- Create a TODO Action ::
     Create a new action.

- Create a TODO Action Remind 3 ::
     Create a new action. Set reminder in 3 days.

- Create a TODO Action Due Date 7 ::
     Create a new action. Set due date in 7 days.

- Create a TODO Action of an existing Project ::
     Attach it to something that we're already working on.

- Create a WAIT Item ::
     Create a new "Waiting For" item.

- Create a DLGT Item ::
     Create a new "Assigned" item.

- Create a DFRD Item ::
     Create a new "Someday" item.

- Create a Reference Item ::
     Create a new "Reference" item.

#+begin_src emacs-lisp
    (add-to-list 'org-capture-templates
                 `("m" "Email processing...") t)

    (add-to-list 'org-capture-templates
                 `("mt" "Create a TODO Action + edit" entry
                   (file+headline "~/org/email.org" "Tasks") ;; #+FILETAGS: :mail:
                   "* TODO %:subject%? (from %:fromname)
   %:date-timestamp-inactive

#+begin_verse
%i
#+end_verse

From %a"
                   :empty-lines 1) t)

    (add-to-list 'org-capture-templates
                 `("mr" "Create a TODO Action Remind 3" entry
                   (file+headline "~/org/email.org" "Tasks") ;; #+FILETAGS: :mail:
                   "* TODO %:subject%? (from %:fromname)
   DEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+3d\") nil nil nil nil \" -0d\")
   %:date-timestamp-inactive

#+begin_verse
%i
#+end_verse

From %a"
                   :empty-lines 1 :immediate-finish t) t)
#+end_src

The property =:immediate-finish=, when set, immediately files the item without
further prompt (skipping =C-c C-c=); very handy for quick storing of emails.

#+begin_src emacs-lisp
    (add-to-list 'org-capture-templates
                 `("M" "mailtodo" entry
                   (file+datetree "~/org/mails.org")
                   "* TODO %^{Task} %^G
SCHEDULED: %t
- From :: %:from
- Subject :: %:subject
- Email :: %a
%?"
                   :kill-buffer t) t)
#+end_src

With the clock options, =org-capture= automatically clocks in. When pressing =C-c
C-c=, it clocks out.

#+begin_src emacs-lisp
    (add-to-list 'org-capture-templates
                 `("p" "Phone call" entry
                   (file+headline ,org-default-notes-file "Phone calls")
                   "* %?"
                   :empty-lines 1 :clock-in t :clock-resume t) t)

    (add-to-list 'org-capture-templates
                 `("i" "interruption" entry
                   (file ,org-default-notes-file)
                   "A TEMPLATE HERE"
                   :clock-in t :clock-resume t) t)
#+end_src

#+begin_src emacs-lisp
    ;; thought
    (add-to-list 'org-capture-templates
                 `("n" "Note" entry
                   (file+headline ,(concat org-directory "/notes.org") "Notes")
                   "* %^{Thought}%?

%i"
                   :empty-lines 1) t)

    ;; shopping list (stuff to buy)
    (add-to-list 'org-capture-templates
                 `("b" "Buy" checkitem
                   (file+headline ,org-default-notes-file "Shopping list")) t)

    ;; add a note to the currently clocked task
    (add-to-list 'org-capture-templates
                 `("c" "Clock sibling" entry
                   (clock)
                   "* %^{Title}
  %U
%a

%i") t)

    (add-to-list 'org-capture-templates
                 `("j" "Journal" entry
                   (file+datetree ,(concat org-directory "/journal.org"))
                   "* %T %?

  %U

%i

From %a"
                   ;; "* %^{Title}\n  :PROPERTIES:\n  :on: %T\n  :END:\n  %?\n  %x"
                   :empty-lines 1) t)

    (add-to-list 'org-capture-templates
                 `("S" "secure" entry
                   (file+datetree+prompt "~/git/notes/secure.org.gpg")
                   "* %(format-time-string \"%H:%M\") %^{Entry} %^G
%i%?") t)
#+end_src

#+begin_src emacs-lisp
    (defun leuven--org-capture-template (keys description file headline)
      "Create template for captured elements."
      `(,keys ,description entry
              (file+headline ,file ,headline)
              "* %^{Title}
   :PROPERTIES:
   :Created: %:date-timestamp-inactive
   :END:
   %?
   %i

   From %a"
              :empty-lines 1))

    ;; notes
    (add-to-list 'org-capture-templates
                 `("N" "Templates adding notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "Ne" "Emacs"
                  "~/org/notes/Notes-on-Emacs.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "No" "Org"
                  "~/org/notes/Notes-on-Org.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "NL" "Lisp"
                  "~/org/notes/Notes-on-Lisp.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "Ng" "Gnus"
                  "~/org/notes/Notes-on-Gnus.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "Nl" "LaTeX"
                  "~/org/notes/Notes-on-LaTeX.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "NT" "TikZ"
                  "~/org/notes/Notes-on-TikZ.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "Nb" "Beamer"
                  "~/org/notes/Notes-on-Beamer.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "NS" "StumpWM"
                  "~/org/notes/Notes-on-StumpWM.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "Nu" "Unix"
                  "~/org/notes/Notes-on-Unix.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "Nc" "Ledger"
                  "~/org/notes/Notes-on-Ledger.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "Nr" "RFID" "~/org/notes/Notes-on-RFID.txt" "Notes") t)
    (add-to-list 'org-capture-templates
                 (leuven--org-capture-template
                  "Ns" "Security"
                  "~/org/notes/Notes-on-Security.txt" "Notes") t)
#+end_src

#+begin_src emacs-lisp
    ;;          ("w" "org-protocol" entry
    ;;           (file ,org-default-notes-file)
    ;;           "* TODO Review %c
    ;; %U"
    ;;           :immediate-finish t :clock-in t :clock-resume t)

    ;; ("web-clippings" ?w
    ;;  "* %^{Title} %^g \n  :PROPERTIES:\n  :date: %^t\n  :link: %^{link}\n  :END:\n\n %x %?"
    ;;  "~/org/data.org" "Web Clippings")
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-capture-templates
                 `("w" "Default template" entry
                   ;; `org-protocol-default-template-key'
                   (file+headline ,(concat org-directory "/capture.org") "Notes")
                   "* %^{Title}%?
  %u

%i

From %c"
                   :empty-lines 1 :immediate-finish t) t)

    ;; default `org-capture-templates' key to use
    (setq org-protocol-default-template-key "w")
#+end_src

**** Capture from command line

#+begin_src emacs-lisp
    (defun make-capture-frame ()
      "Create a new frame and run `org-capture'."
      (interactive)
      (make-frame '((name . "capture")
                    (width . 80)
                    (height . 10)))
      (select-frame-by-name "capture")
      ;; ;; setup buffer to wrap
      ;; (setq truncate-lines nil
      ;;       word-wrap t)
      (org-capture))

    ;; make the frame contain a single window (by default, `org-capture'
    ;; splits the window)
    (add-hook 'org-capture-mode-hook 'delete-other-windows)

    (defadvice org-capture-finalize
      (after leuven-delete-capture-finalize-frame activate)
      "Advise org-capture-finalize to close the frame (if it is the capture frame)."
      (if (equal "capture" (frame-parameter nil 'name))
          (delete-frame)))

    (defadvice org-capture-destroy ;; XXX
      (after leuven-delete-capture-destroy-frame activate)
      "Advise capture-destroy to close the frame (if it is the capture frame)."
      (if (equal "capture" (frame-parameter nil 'name))
          (delete-frame)))

    ) ;; with-eval-after-load "org-capture" ends here
#+end_src

#+begin_src sh :tangle ~/bin/capture :shebang #!bin/sh
emacsclient -n -e '(make-capture-frame)'
#+end_src

*** Attachments

Use the following for conveniently accessing your data.

#+begin_src emacs-lisp
;; bug when C-c C-l
  ;; ;; 4.6 shortcut links
  ;; (add-to-list 'org-link-abbrev-alist '(("att" . org-attach-expand-link)))
#+end_src

Instead of modifying =org-link-abbrev-alist=, you can also use

: #+LINK: att %(org-attach-expand-link)

in your Org buffers.

*** Protocols for external access

Open Org source (and Capture) from Firefox.

Have a look at [[http://vimeo.com/5662410][Store links in Emacs Org using org-protocol.el]].

#+begin_src emacs-lisp
  (leuven--section "9.4 (org)Protocols")

  ;; 9.4 capture from Firefox (to store links and text)
  (with-eval-after-load "org-protocol"

    ;; map online URL to an existing working file
    (add-to-list 'org-protocol-project-alist
                 '("Worg at http://orgmode.org/worg/"
                   :online-suffix ".html"
                   :working-suffix ".org"
                   :base-url "http://orgmode.org/worg/"
                   :working-directory "~/Public/Repositories/worg/") t))
#+end_src

*** Refile and copy

Once a date has been scheduled, move the task to the appropriate category, by
using the refile note command =C-c C-w=. This lets me select (with completion)
the header under which the entry will be placed.

#+begin_src emacs-lisp
  (with-eval-after-load "org"
    (message "... Org Refile")

    ;; 9.5 any headline with level <= 2 is a target
    (defvar leuven-org-refile-extra-files
      (if (file-exists-p "~/org/notes/")
          (directory-files "~/org/notes/" t "^[^\\.#].*\\.\\(txt\\|org\\)$")
        nil)
      "List of extra files to be used as targets for refile commands.")

    (setq org-refile-targets
          `((nil
             :maxlevel . 8) ;; current file
            (,(append org-agenda-files leuven-org-refile-extra-files)
             :maxlevel . 4)))

    ;; cache refile targets to speed up the process
    (setq org-refile-use-cache t)

    ;; 9.5 provide refile targets as paths, including the file name
    ;; (without directory) as level 1 of the path
    (setq org-refile-use-outline-path 'file)

    ;; 9.5 allow to create new nodes (must be confirmed by the user) as
    ;; refile targets
    (setq org-refile-allow-creating-parent-nodes 'confirm)

    ;; refile only within the current buffer
    (defun leuven-org-refile-within-current-buffer ()
      "Move the entry at point to another heading in the current buffer."
      (interactive)
      (let ((org-refile-targets '((nil :maxlevel . 8))))
        (org-refile)))
    ;; FIXME Add a smart key binding
  #+end_src

#+begin_src emacs-lisp
    ;; exclude DONE state tasks from refile targets
    (defun bh/verify-refile-target ()
      "Exclude TODO keywords with a DONE state from refile targets."
      (not (member (nth 2 (org-heading-components)) org-done-keywords)))

    (setq org-refile-target-verify-function 'bh/verify-refile-target)
#+end_src

*** Archiving

#+begin_src emacs-lisp
    (leuven--section "9.6 (org)Archiving")

    ;; 9.6.1 subtrees should be archived in the current file
    (setq org-archive-location "::* Archive")

    )
#+end_src

** Agenda Views

#+begin_src emacs-lisp
  (leuven--section "10 (org)Agenda Views")

;;* 10 (info "(org)Agenda Views")

  ;; multiple same-day time stamps in entry make multiple agenda lines
  (setq org-agenda-skip-additional-timestamps-same-entry nil)

  ;; show outline path in echo area after line motion (though, may bring
  ;; some slowness)
  (setq org-agenda-show-outline-path t)

  ;; 10.0 restore the window configuration when exiting the agenda
  (setq org-agenda-restore-windows-after-quit t)
#+end_src

#+begin_src emacs-lisp
  ;; ;; speed up agenda by avoiding to update some text properties
  ;; (setq org-agenda-ignore-drawer-properties '(effort category))
#+end_src

*** Agenda files

#+begin_src emacs-lisp
;;** 10.1 (info "(org)Agenda files")

  (leuven--section "10.1 (org)Agenda files")

  (when (boundp 'org-agenda-files)
    (message "(Info) Found %s entries in `org-agenda-files'"
             (length org-agenda-files))
    (sit-for 0.5))
#+end_src

Avoid any possibility of getting a customized version of =org-agenda-files= added
at the end of your ~.emacs~ file.

#+begin_example
  (add-hook 'org-mode-hook
            (lambda ()
              (org-defkey org-mode-map
                          (kbd "C-c [") 'undefined)
              (org-defkey org-mode-map
                          (kbd "C-c ]") 'undefined)))
#+end_example

*** The agenda dispatcher

#+begin_src emacs-lisp
;;** 10.2 (info "(org)Agenda dispatcher")

  (leuven--section "10.2 (org)Agenda dispatcher")

  ;; enable sticky agenda: `q' key will bury agenda buffers (instead of
  ;; killing)
  (setq org-agenda-sticky t)
#+end_src

*** The Built-in agenda views

#+begin_src emacs-lisp
;;** 10.3 The (info "(org)Built-in agenda views")

  (leuven--section "10.3 (org)Built-in agenda views")
#+end_src

Press =C-c a a= to jump you to this week's task page from anywhere.

#+begin_src emacs-lisp
  ;; default duration for appointments that only have a starting time
  (setq org-agenda-default-appointment-duration nil)

  ;; ;; duration of an appointment will add to day effort
  ;; (setq org-agenda-columns-add-appointments-to-effort-sum t)
#+end_src

=C-c a t= should show *all* the TODO items... but...

#+begin_src emacs-lisp
  ;; show dated entries in the global `todo' list
  (setq org-agenda-todo-ignore-with-date nil) ;;!! tricky setting
#+end_src

#+begin_src emacs-lisp
  ;; show entries with a time stamp in the global `todo' list
  (setq org-agenda-todo-ignore-timestamp nil)
#+end_src

Don't tell me about stuff that isn't due yet: tasks scheduled in the future
should no longer show up in global todo or tags searches until that date
arrives -- at which point it will be in all lists.

#+begin_src emacs-lisp
  ;; 10.3.2 don't show scheduled entries in the global `todo' list
  (setq org-agenda-todo-ignore-scheduled 'future) ;;!! tricky setting
  (setq org-agenda-todo-ignore-scheduled nil)
#+end_src

#+begin_src emacs-lisp
  ;; 10.3.2 don't show entries scheduled in the future in the global
  ;; `todo' list (until they are within the warning period)
  (setq org-agenda-todo-ignore-deadlines 'near) ;;!! tricky setting
  (setq org-agenda-todo-ignore-deadlines nil)
#+end_src

#+begin_src emacs-lisp
  ;; 10.3.2 check also the sublevels of a TODO entry for TODO entries,
  ;; resulting in potentially much longer `todo' lists
  (setq org-agenda-todo-list-sublevels t)

  ;; 10.3.3 honor `todo' list `org-agenda-todo-ignore...' options also
  ;; in the `tags-todo' list
  (setq org-agenda-tags-todo-honor-ignore-options t)
#+end_src

#+begin_src emacs-lisp
  ;; ;; highlight current line (may bring some slowness)
  ;; (add-hook 'org-agenda-mode-hook 'hl-line-mode)
#+end_src

**** Advanced Search

#+begin_src emacs-lisp
  ;; 10.3.5 list of extra files to be searched by text search commands
  ;; (C-c a s)
  (setq org-agenda-text-search-extra-files nil)
  ;; (setq leuven-org-search-extra-files ...) to list extra files to be searched

  ;; turn on individual word search (for Google addicts)
  (setq org-agenda-search-view-always-boolean t
        org-agenda-search-view-search-words-only t)

  ;; match part of a word
  (setq org-agenda-search-view-force-full-words nil)

  ;; don't search headline for a time-of-day
  (setq org-agenda-search-headline-for-time nil)
#+end_src

#+begin_src emacs-lisp
  ;; 10.3.6 how to identify stuck projects
  (setq org-stuck-projects
        '("+LEVEL=2/-DONE" ;; identify a project
          ("TODO" "STRT") ;; TODO keywords
          nil "")) ;; tags, regexp
#+end_src

*** Presentation and sorting

#+begin_src emacs-lisp
;;** 10.4 (info "(org)Presentation and sorting")

  (leuven--section "10.4 (org)Presentation and sorting")

  ;; 10.4 format specifications for the prefix of items in the agenda views
  (setq org-agenda-prefix-format
        '((agenda . " %-11s%i %?-12t") ;; agenda
          (timeline . " % s")          ;; timeline
          (todo . " %i %-12:c")        ;; todo, alltodo
          (tags . " %i %-12:c")        ;; tags, tags-todo, stuck
          (search . " %i %-12:c")))    ;; search

  ;; text preceding scheduled items in the agenda view
  (setq org-agenda-scheduled-leaders
        '("Today      "
          "           "))

  ;; text preceding item pulled into the agenda by inactive time stamps
  (setq org-agenda-inactive-leader "[")

  ;; text preceding deadline items in the agenda view
  (setq org-agenda-deadline-leaders
        '("Deadline   "
          "In %d d" ;; or "%d d left"
          "%d d ago"))

  ;; faces for showing deadlines in the agenda
  (setq org-agenda-deadline-faces
        '((1.0001 . leuven-org-deadline-yesterday-or-before-face)
          (0.9999 . leuven-org-deadline-today-face)
          (0.0000 . leuven-org-deadline-tomorrow-or-later-face)))

  (with-eval-after-load "org-faces"

    ;; Org non-standard faces
    (defface leuven-org-deadline-yesterday-or-before-face
      '((t (:weight bold :foreground "#D24231" :background "#F8D3D4")))
      "Face used to highlight tasks whose deadline is in the past.")

    (defface leuven-org-deadline-today-face
      '((t (:weight bold :foreground "#BF8239" :background "#F8D1A9")))
      "Face used to highlight tasks whose deadline is today.")

    (defface leuven-org-deadline-tomorrow-or-later-face
      '((t (:weight bold :foreground "#45A856" :background "#B8E9B1")))
      "Face used to highlight tasks whose deadline is for later."))

  ;; 10.4 column to shift tags to (in agenda items)
  (setq org-agenda-tags-column -132)
#+end_src

#+begin_src emacs-lisp
  ;; type "L" in agenda and todo buffers to show category name and task
  ;; length for each task
  (defvar leuven--org-agenda-show-task-details nil)
  (defun leuven-org-agenda-toggle-task-details ()
    "Toggle inclusion of category and estimate in agenda views."
    (interactive)
    (if leuven--org-agenda-show-task-details
        (progn
          (setq leuven--org-agenda-show-task-details nil)
          (setq org-agenda-prefix-format
                '((agenda  . " %-11s%i %?-12t")
                  (timeline  . " % s")
                  (todo  . " ")
                  (search . " ")
                  (tags  . " "))))
      (setq leuven--org-agenda-show-task-details t)
      (setq org-agenda-prefix-format
            '((agenda . " %-11s%i %-12:c%?-12t%7e ")
              (timeline . " % s")
              (todo . " %i %-12:c")
              (search . " %i %-12:c")
              (tags . " %i %-12:c"))))
    (org-agenda-redo))

  (with-eval-after-load "org-agenda"

    (add-hook 'org-mode-hook
              (lambda ()
                (define-key org-agenda-keymap
                  (kbd "L") 'leuven-org-agenda-toggle-task-details)
                (define-key org-agenda-mode-map
                  (kbd "L") 'leuven-org-agenda-toggle-task-details))))
#+end_src

Show the time grid in the daily agenda but not in the weekly agenda, except
for today's date:

#+begin_src emacs-lisp
  ;; 10.4.2 settings for time grid for agenda display
  (setq org-agenda-time-grid '((daily remove-match)
                               ""
                               (0800 1000 1200 1400 1600 1800 2000)))

  ;; string for the current time marker in the agenda
  (setq org-agenda-current-time-string "now")
#+end_src

=time-up= will only be applied to those items have a time stamp for the day in
question, so that other sorting parameters will not be outranked by =time-up= for
the rest of the entries.

*************** TODO refile.org should come first
Current workaround: added =#+CATEGORY: @refile= at the end of that file (the =@=
symbol is alphabetically before the letters)
*************** END

Agenda view: put related tasks together, then by priority.

#+begin_src emacs-lisp
  ;; 10.4.3 sorting structure for the agenda items of a single day
  (setq org-agenda-sorting-strategy   ; custom value
        '((agenda time-up category-up priority-down effort-down)
          (todo category-up priority-down effort-down)
          (tags category-up priority-down effort-down)
          (search category-up)))

  ;; (setq org-sort-agenda-notime-is-late nil)

  ;; show agenda in the current window, keeping all other windows
  (setq org-agenda-window-setup 'current-window)
#+end_src

*** Agenda commands

#+begin_src emacs-lisp
;;** 10.5 (info "(org)Agenda commands")

  (leuven--section "10.5 (org)Agenda commands")

  ;; ;; enable Follow mode
  ;; (setq org-agenda-start-with-follow-mode t)
  ;; ;; XXX Seems nice, but first solve problem with decrypt question (auto-save)

  ;; get a compact view during follow mode in the agenda
  (defun leuven--compact-follow ()
    "Make the view compact, then show the necessary minimum."
    (ignore-errors
      (save-excursion
        (while (org-up-heading-safe))
        (hide-subtree)))
    (let ((org-show-siblings nil)
          (org-show-hierarchy-above t))
      (org-reveal))
    (save-excursion
      (org-back-to-heading t)
      (show-children)))

  ;; FIXME When this is enabled, clicking on a clock line from `v c'
  ;; (log check) does not jump to the right line
  ;; (add-hook 'org-agenda-after-show-hook 'leuven--compact-follow)

  ;; 10.5 number of days to include in overview display
  (setq org-agenda-span 'day)

  ;; always start the overview on the current day
  (setq org-agenda-start-on-weekday nil)

  ;; format string for displaying dates in the daily/weekly agenda
  ;; and in the timeline
  (setq org-agenda-format-date
        (concat ;; "\n"
                "%Y-%m-%d" " %a "
                (make-string (1- (window-width)) (string-to-char "_"))))

  ;; 10.5 only show clocked entries in agenda log mode (no closed
  ;; entries, no state changes)
  (setq org-agenda-log-mode-items '(clock))

  ;; 10.5 parameters for the clocktable in clockreport mode
  (setq org-agenda-clockreport-parameter-plist
        '(:link nil :maxlevel 3 :fileskip0 t))
  (setq org-agenda-clockreport-parameter-plist
        '(:link t :maxlevel 3 :fileskip0 t))

  ;; 10.5 definition of what constitutes a clocking problem (overlapping
  ;; clock entries, clocking gaps)
  (setq org-agenda-clock-consistency-checks
        '(:max-duration "10:00"
          :min-duration 0
          :max-gap "0:00"
          :gap-ok-around ("4:00")
          :default-face
          ((:weight bold
            :box (:line-width 1 :color "#AAEE77")
            :foreground "black" :background "#BFFA9E"))
          :gap-face
          ((:weight bold
            :box (:line-width 1 :color "#BBDDFF")
            :foreground "black" :background "#D0EDFF"))))
#+end_src

If you press =E=, it will *show* the *first notes* about the tasks.

#+begin_src emacs-lisp
  ;; 10.5 text prepended to the entry text in agenda buffers
  (setq org-agenda-entry-text-leaders "                ")
#+end_src

#+begin_src emacs-lisp
  ;; 10.5 file to which to add new entries with the `i' key in agenda and
  ;; calendar (org.el)
  (setq org-agenda-diary-file "~/org/diary.org")

  ;; 10.5? keep filters from one agenda view to the next
  (setq org-agenda-persistent-filter t)

  ;; faces for specific Priorities (#A, #B and #C)
  ;; XXX This generates an error when C-x C-w'ing the agenda view
  (setq org-priority-faces-XXX
        '((?A . (:weight bold :slant italic :underline t
                 :foreground "#6E0000" :background "#F67777"))
          (?B . (:slant italic
                 :foreground "#005606" :background "#B6E864"))
          (?C . (:slant italic
                 :foreground "#00337B" :background "#C3DCFF"))))
#+end_src

Contextual auto-exclusion for tags in the Agenda view. For example, I use the
following tags for TODOs:

- Phone ::
     Needs a phone

- Errands ::
     Done in town

- Home ::
     Done at home

Now, it's quite easy for my computer to figure out which of these are
possible, based on my location:

- Phone ::
     Am I outside of normal calling hours?

- Errands ::
     Am I outside of business hours?

- Home ::
     Does my IP address begin with 192.168.9?

I can now define the function =leuven--org-auto-exclude-function= to auto-exclude
based on this type of context information.

All I have to do is type =/ <RET>= in the agenda view now, and it excludes based
on my machine's current temporal and physical context.

#+begin_src emacs-lisp
  ;; 10.5 Commands in the agenda buffer
  (defun leuven--weekday-p ()
    "Return t if current day is between Monday and Friday."
    (let ((dow (nth 6 (decode-time))))
      (and (> dow 0)
           (< dow 6))))

  (defun leuven--working-p ()
    "Return t if current time is inside normal working hours.

  Currently: 08:30-12:30 and 13:30-17:30."
    (let* ((time (decode-time))
           (hour (nth 2 time))
           (mins (nth 1 time)))
      (and (leuven--weekday-p)
           (or (or (and (= hour 8) (>= mins 30))
                   (and (< 8 hour) (< hour 12))
                   (and (= hour 12) (<= mins 30)))
               (or (and (= hour 13) (>= mins 30))
                   (and (< 13 hour) (< hour 17))
                   (and (= hour 17) (<= mins 30)))))))

  (defun leuven--calling-hours-p ()
    "Return t if current time is inside normal calling hours.

  Currently: 08:00-21:59."
    (let* ((hour (nth 2 (decode-time))))
      (and (<= 8 hour) (<= hour 21))))

  (defun leuven--org-auto-exclude-function (tag)
    (and (cond
          ((string= tag "home")
           (with-temp-buffer
             (call-process "/sbin/ifconfig" nil t nil "en0" "inet")
             (goto-char (point-min))
             (not (re-search-forward "inet 192\\.168\\.9\\." nil t))))
          ((or (string= tag "errands")
               (string= tag "phone"))
           (let ((hour (nth 2 (decode-time))))
             (or (< hour 8) (> hour 21)))))
         (concat "-" tag)))

  ;;! ensure that `:refile:' tags never will be excluded!
  (defun leuven--org-auto-exclude-function (tag)
    (and (cond
          ((string= tag "home")
           (leuven--working-p))
          ((string= tag "work")
           (not (leuven--working-p)))
          ((or (string= tag "errands")
               (string= tag "phone"))
           (not (leuven--calling-hours-p))))
         (concat "-" tag)))

  (setq org-agenda-auto-exclude-function 'leuven--org-auto-exclude-function)
#+end_src

*************** TODO We should ensure that appointments don't disappear when filtering late at nite
- Look at appointments tagged =errands=
- Filter at 23:00 with =/ <RET>=
- Appointments such as "going to the doctor" will be removed from the agenda view...
*************** END

*** Custom agenda views

Links to common agenda views:
- [[elisp:(org-agenda nil "a")]]
- [[elisp:(org-agenda nil "w")][Show Waiting Tasks]]
- [[elisp:(org-agenda nil "p")][Show Projects]]

You can as well use your agenda and use =/= to limit the view to what you want
(=C-c a a / TAG=).

Commands:
- [[shell:ls -l]]
- shell:pwd

Vocabulary:
- SCHEDULED = start time
- Undated items
- Planned
- Uncategorized

Tasks views:
- Active
- Starred (= with an explicit priority)
- Completed
- Due today (only today)
- Due this week (only for current week: from Monday to Sunday included)
- Late (all overdue + today)
- Assigned to me
- Created by me
- With files attached

Sorted by:
- Creation date
- Last changed (= default)
- Project
- Creator
- Deadline
- Priority
- Title

Ordered by:
- Asc
- Desc (= default)

#+begin_src emacs-lisp
  ;; make the block agenda more compact (no agenda span name, no week
  ;; number, no separator line)
  (setq org-agenda-compact-blocks t)
  (setq org-agenda-compact-blocks nil)

  (setq org-agenda-block-separator
        ;; (concat (make-string 132 (string-to-char "_")) "\n\n")
        "\n")
#+end_src

Get your errand list for this week by filtering the agenda (for the current
week) on the =errands= tag.

#+begin_src emacs-lisp :tangle no
  ("d" "Daily Agenda"
   ((agenda ""
            ((org-agenda-todo-keyword-format "")
             (org-agenda-remove-tags t)))
    (tags "LEVEL=2+goals"
          ((org-agenda-remove-tags t)
           (org-agenda-prefix-format "  ")
           (org-agenda-todo-keyword-format "")))
    (todo "TODO"
          ((org-agenda-sorting-strategy '(tag-up))
           (org-agenda-show-inherited-tags nil)
           (org-agenda-todo-keyword-format "")))
    (todo "STRT"
          ((org-agenda-todo-keyword-format "")))
    (stuck ""
           ((org-agenda-remove-tags t)))))

  ("p" "Printed agenda"
   ((agenda ""
            ((org-agenda-span 'week)
             (org-agenda-start-on-weekday nil)
             (org-agenda-time-grid nil)
             ;; (org-agenda-repeating-timestamp-show-all t)
             (org-agenda-prefix-format "  -->  %t %s")
             (org-agenda-skip-function
              '(org-agenda-skip-entry-if 'deadline 'scheduled))))
    (agenda ""
            ((org-agenda-span 'day)
             (org-agenda-sorting-strategy '(time-up tag-up))
             (org-agenda-todo-keyword-format "[ ]")
             (org-agenda-scheduled-leaders '("" ""))
             (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline))
             (org-agenda-prefix-format "%t %T %s")
             ))
    (agenda ""
            ((org-agenda-span 'day)
             (org-deadline-warning-days 7)
             (org-agenda-time-grid nil)
             (org-agenda-include-diary nil)
             (org-agenda-todo-keyword-format "[ ]")
             (org-agenda-scheduled-leaders '("" ""))
             (org-agenda-overriding-header "Due Dates:")
             (org-agenda-skip-function '(org-agenda-skip-entry-if 'notdeadline))
             (org-agenda-prefix-format "%t %s")))
    (todo "TODO|STRT"
          ((org-agenda-sorting-strategy '(tag-up priority-down))
           (org-agenda-todo-ignore-with-date t)))
    (todo "WAIT"))
   ((org-agenda-with-colors nil)
    (org-agenda-prefix-format "%T [ ]")
    (org-agenda-todo-keyword-format "")
    (org-agenda-block-separator "---------------\n")
    (org-agenda-remove-tags t)
    (ps-number-of-columns 2)
    ;; (ps-print-header nil)
    (ps-landscape-mode t))
   ("~/org-agenda-storage.pdf"))

  ("P" "Projects"
   ((agenda ""
            ((org-agenda-skip-function
              '(org-agenda-skip-entry-if 'notregexp "* PROJ"))
             (org-agenda-include-diary nil)
             (org-agenda-time-grid nil)))
    (todo "PROJ"
          ((org-agenda-todo-ignore-deadlines t)
           (org-agenda-sorting-strategy '(priority-down))))))
#+end_src

#+begin_src emacs-lisp
;;** 10.6 (info "(org)Custom agenda views")

  (leuven--section "10.6 (org)Custom agenda views")

  (with-eval-after-load "org-agenda"

    ;; custom commands for the agenda -- start with a clean slate
    (setq org-agenda-custom-commands nil)
#+end_src

Search any word or regexp within your task name or in the note field:

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("f" "Like s, but with extra files"
                   search ""
                   ((org-agenda-text-search-extra-files
                     ;; FIXME Add `agenda-archives'
                     leuven-org-search-extra-files))) t)
#+end_src

*************** TODO Add =F= to search in all files, but not into DONE tasks

We should have two agenda views:
- sorted by priority (C-c a a, for example)
- sorted by effort

#+begin_src emacs-lisp
    ;; (add-to-list 'org-agenda-custom-commands
    ;;              '("A" . "0. Agenda...") t)
    ;;
    ;; (add-to-list 'org-agenda-custom-commands
    ;;              '("AF" "Agenda of upcoming due dates (6 months)"
    ;;                ;; FIXME We don't see DEADLINE with `-1m' (or so)
    ;;                ;; specifications (if they are more than 1m ahead of now)!
    ;;                agenda ""
    ;;                ((org-agenda-skip-function
    ;;                  '(org-agenda-skip-entry-if 'notdeadline))
    ;;                 (org-agenda-span 'day)
    ;;                 (org-agenda-time-grid nil)
    ;;                 (org-deadline-warning-days 183))) t)
    ;;              ;; Some SCHEDULED are shown (when paired with a deadline and
    ;;              ;; scheduled in the past or for today)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("b" . "All active tasks...") t)

    (add-to-list 'org-agenda-custom-commands
                 '("b=" "Edit (?) List of all TODO entries (column view)"
                   alltodo ""
                   ((org-agenda-overriding-columns-format
                     "%65ITEM(Task) %4TODO %PRIORITY %6Effort(Estim.) %14SCHEDULED %14DEADLINE(Due Date)")
                    (org-agenda-view-columns-initially t))) t)
#+end_src

Hide certain tasks that you don't want to be bothered with all the time:

- Hide low priority
- Hide =DFRD= tasks
- Hide future tasks?
- Hide subtasks?

*************** TODO Add extra filters (described above)

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("bT" "Filtered list of TODO entries"
                   tags-todo "TODO<>{DFRD\\|PROJ}"
                   ((org-agenda-overriding-header
                     "List of TODO items of all types but DFRD/PROJ, and PRIORITY >= #B")
                    (org-agenda-sorting-strategy
                     '(category-up priority-down todo-state-up alpha-up)))) t)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("p" . "2. Process/Clarify...") t)

    (add-to-list 'org-agenda-custom-commands
                 `("pu" "Uncategorized"
                   tags "CATEGORY={@Inbox}&LEVEL=2"
                   ((org-agenda-overriding-header "Level 2 stuff in inbox"))) t)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("o" . "3. Organize...") t)

    (add-to-list 'org-agenda-custom-commands
                 '("or" "Thoughts to refile"
                   tags "refile|capture"
                   ((org-agenda-overriding-header "Refile stuff"))) t)

    (add-to-list 'org-agenda-custom-commands
                 `("oc" "Tasks to refile (column view)"
                   tags-todo ""
                   ((org-agenda-files ,(quote (list org-default-notes-file)))
                    (org-agenda-overriding-columns-format
                     "%65ITEM(Task) %4TODO %PRIORITY %20TAGS %6Effort(Estim.) %14SCHEDULED %14DEADLINE(Due Date)")
                    (org-agenda-view-columns-initially t))) t)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("r" . "4. Review...") t)
#+end_src

*************** TODO Add report "Recently added/completed/modified"
Recently done.
*************** END

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("rt" "Unscheduled TODO entries"
                   alltodo ""
                   ((org-agenda-entry-types '(:timestamp :deadline :scheduled))
                    (org-agenda-overriding-header "Unscheduled TODO entries: "))) t)

    ;; all TODO entries, but DFRD
    (add-to-list 'org-agenda-custom-commands
                 '("rT" "List of undated TODO entries (no DFRD)"
                   tags-todo "TODO<>{DFRD}"
                   ((org-agenda-overriding-header
                     "Global list of undated TODO items of all types but DFRD")
                    (org-agenda-skip-function
                     '(org-agenda-skip-entry-if 'scheduled 'deadline 'timestamp))
                    (org-agenda-sorting-strategy '(priority-down)))) t)

    ;; show only TODO entries, ignoring entries that have time stamps (it also
    ;; covers scheduled or deadline items)
    (add-to-list 'org-agenda-custom-commands
                 '("rs" "Undated TODO items"
                   todo "TODO"
                   ((org-agenda-overriding-header "Undated TODO items: ")
                    (org-agenda-todo-ignore-with-date t))) t)
#+end_src

#+begin_src emacs-lisp
    ;; calendar view for org-agenda
    (when (locate-library "calfw-org")

      (autoload 'cfw:open-org-calendar "calfw-org"
        "Open an Org schedule calendar." t)

      (add-to-list 'org-agenda-custom-commands
                   '("r^" "Calendar for current month"
                     (lambda (&rest ignore)
                       (cfw:open-org-calendar))) t)

      ;; (defun cfw:open-org-calendar-non-work (&args)
      ;;   (interactive)
      ;;   (let ((org-agenda-skip-function 'org-agenda-skip-work))
      ;;     (cfw:open-org-calendar)))
      ;;
      ;; (add-to-list 'org-agenda-custom-commands
      ;;              '("c" "Calendar (non-work) for current month"
      ;;                cfw:open-org-calendar-non-work) t)

      )
#+end_src

=org-timeline= has weaknesses and although not officially deprecated, should be
best avoided. See Carsten's comments in
http://thread.gmane.org/gmane.emacs.orgmode/39368/focus=39465

#+begin_src emacs-lisp
    ;; show what happened today
    (add-to-list 'org-agenda-custom-commands
                 '("rL" "Timeline for today"
                   ((agenda ""
                            ((org-agenda-clockreport-mode t)
                             (org-agenda-entry-types '(:timestamp))
                             (org-agenda-log-mode-items '(clock closed))
                             (org-agenda-show-log t)
                             (org-agenda-span 'day))))) t)

    (add-to-list 'org-agenda-custom-commands
                 '("rC" "Clock Review"
                   ((agenda ""
                            ((org-agenda-clockreport-mode t)
                             (org-agenda-overriding-header "Clocking Review")
                             (org-agenda-show-log 'clockcheck)
                             (org-agenda-span 'day))))) t)
#+end_src

Cleanup:

- Done actions older than 14 days
- Inactive ticklers older than 14 days
- Completed projects older than 14 days

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("r$" "Cleanup"
                   todo "DONE|CANX|DFRD"
                   ((org-agenda-overriding-header "Old tasks to delete or archive")
                    ;; also show deadlines and scheduled items
                    (org-agenda-todo-ignore-with-date nil))) t)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("rP" "Projects"
                   tags-todo "project-DONE-CANX"
                   ((org-agenda-overriding-header "Projects (High Level)")
                    (org-agenda-sorting-strategy nil))) t)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("rn" "Now (undated tasks in progress)"
                   todo "STRT"
                   ((org-agenda-todo-ignore-with-date t))) t)
#+end_src

**** Weekly task review

1. Clear inbox
2. Review previous calendar data
3. Review upcoming calendar
4. Review (stuck) projects
5. Review (next) actions
6. Review waiting-for
7. Review someday/maybe

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("rw" "Weekly review"
                   (
                    (tags "CATEGORY={@Inbox}&LEVEL=2|TODO={NEW}"
                          ((org-agenda-overriding-header "Inbox")))

                    (agenda ""
                            ((org-agenda-clockreport-mode t)
                             (org-agenda-format-date
                              (concat "\n"
                                      "%Y-%m-%d" " %a "
                                      (make-string (window-width) ?_)))
                             (org-agenda-overriding-header "Past week")
                             (org-agenda-prefix-format " %?-11t %i %-12:c% s")
                             (org-agenda-show-log 'clockcheck)
                             (org-agenda-span 7)
                             (org-agenda-start-day "-1w") ;; recently done
                             (org-deadline-warning-days 0)))

                    (agenda ""
                            ((org-agenda-overriding-header "Next month")
                             (org-agenda-span 'month)
                             (org-agenda-start-day "+0d")
                             (org-deadline-warning-days 0) ;; XXX
                             ))

                    (todo "PROJ"
                          ((org-agenda-overriding-header "Project list")))

                    ;; XXX we should show which tasks (don't) have CLOCK lines: archived vs deleted
                    (todo "DONE|PROJDONE"
                          ((org-agenda-overriding-header
                            "Candidates to be archived")))

                    ;; (stuck ""
                    ;;        ((org-agenda-overriding-header "Stuck projects")))

                    (todo "STRT"
                          ((org-agenda-overriding-header "In progress")
                           (org-agenda-todo-ignore-scheduled nil)))

                    (todo "TODO" ;; don't include items from Inbox! XXX
                          ((org-agenda-overriding-header "Action list")))

                    ;; ignore scheduled and deadline entries, as they're
                    ;; visible in the above agenda (for the past + for next
                    ;; month) or scheduled/deadline'd for much later...
                    (todo "WAIT|DLGT"
                          ((org-agenda-format-date "")
                           (org-agenda-overriding-header "Waiting for")
                           (org-agenda-todo-ignore-deadlines 'all) ;; future?
                           (org-agenda-todo-ignore-scheduled t)))

                    ;; same reasoning as for WAIT|DLGT
                    (todo "DFRD"
                          ((org-agenda-format-date "")
                           (org-agenda-overriding-header "Someday")
                           (org-agenda-todo-ignore-deadlines 'all)
                           (org-agenda-todo-ignore-scheduled t)))

                   ;; ((org-agenda-block-separator "\n")
                   ;;  (org-agenda-clockreport-mode nil)
                   ;;  (org-agenda-prefix-format " %i %?-12t% s")
                   ;;  (org-agenda-write-buffer-name "Weekly task review"))
                   ;; "~/org-weekly-review.html") t)
                    )) t)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("rd" "Daily review"
                   ((agenda ""
                            ((org-agenda-entry-types '(:timestamp :sexp))
                             (org-agenda-overriding-header "Calendar")
                             (org-agenda-span 'day)))
                    (agenda ""
                            ((org-agenda-entry-types '(:deadline))
                             (org-agenda-overriding-header "Due Dates")
                             (org-agenda-skip-function
                              '(org-agenda-skip-entry-if 'todo 'done))
                             (org-agenda-sorting-strategy
                              '(priority-down time-down))
                             (org-agenda-span 'day)
                             (org-agenda-start-on-weekday nil)
                             (org-agenda-time-grid nil)))
                    (agenda ""
                            ((org-agenda-entry-types '(:scheduled))
                             (org-agenda-overriding-header "Scheduled")
                             (org-agenda-skip-function
                              '(org-agenda-skip-entry-if 'todo 'done))
                             (org-agenda-sorting-strategy
                              '(priority-down time-down))
                             (org-agenda-span 'day)
                             (org-agenda-start-on-weekday nil)
                             (org-agenda-time-grid nil)))
                    )
                   ((org-agenda-format-date "")
                    (org-agenda-start-with-clockreport-mode nil))) t)
#+end_src

#+begin_src emacs-lisp
;;*** Calendar style views

    (add-to-list 'org-agenda-custom-commands
                 '("rc" "Calendar for 7 days"
                   agenda ""
                   ((org-agenda-entry-types '(:timestamp :sexp))
                    (org-agenda-overriding-header "Calendar for 7 days")
                    ;; (org-agenda-repeating-timestamp-show-all t)
                    (org-agenda-span 'week)
                    (org-agenda-time-grid nil))) t)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("rr" "Recent items (past 7 days)"
                   ;; faster than tags
                   agenda ""
                   ((org-agenda-start-day "-7d")
                    (org-agenda-span 7)
                    (org-agenda-repeating-timestamp-show-all nil)
                    ;; %s is only for agenda views
                    ;; (org-agenda-prefix-format "%s")
                    ;; maybe not make much difference ka
                    ;; (org-agenda-use-tag-inheritance nil)
                    (org-agenda-inactive-leader "Inactive:  ")
                    (org-agenda-include-inactive-timestamps t))) t)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("d" . "5. Do the work...") t)
#+end_src

*************** TODO Show overridden headers when in agenda view

#+begin_src emacs-lisp
;;*** Other views
#+end_src

The *hotlist* is a convenient way to see your *most important tasks* for you to be
working on right now. It contains /active/ tasks that:

- are due soon (in the next 7 days), or
- have a high priority (=#A=), or
- are =FLAGGED=.

There is an exception to the above rule: tasks with a future =SCHEDULED= date
will be hidden from the hotlist regardless of their =DEADLINE= date, priority or
flag.

In other words, to be listed in the hotlist, tasks must have as well a
=SCHEDULED= date that is on or before today, or that is blank.

*************** TODO Use option (org-agenda-todo-ignore-with-date t) = ignore SCHEDULED criteria?

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("dh" "Hotlist"
                   ;; tags-todo "DEADLINE<=\"<+1w>\"|PRIORITY={A}|FLAGGED"
                   ((tags-todo "DEADLINE<=\"<+0d>\""
                               ((org-agenda-overriding-header "Late")))
                    (tags-todo "DEADLINE>\"<+0d>\"+DEADLINE<=\"<+1w>\""
                               ((org-agenda-overriding-header "Due in next 7 days")))
                    (tags-todo "DEADLINE={}+PRIORITY={A}|DEADLINE>\"<+1w>\"+PRIORITY={A}"
                               ((org-agenda-overriding-header "High priority")))
                    (tags-todo "DEADLINE={}+FLAGGED|DEADLINE>\"<+1w>\"+FLAGGED"
                               ((org-agenda-overriding-header "Flagged")
                                (org-agenda-skip-function
                                 '(org-agenda-skip-entry-when-regexp-matches))
                                (org-agenda-skip-regexp "\\[#A\\]"))))
                   ((org-agenda-todo-ignore-scheduled 'future)
                    (org-agenda-sorting-strategy '(deadline-down)))) t)
#+end_src

The hotlist is the perfect thing to *review each morning* to know what you need
to do each day.

*************** TODO Have the hotlist emailed to you each day

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("de" "Effort less than 1 hour"
                   tags-todo "Effort<>{}+Effort<\"1:00\""
                   ((org-agenda-todo-ignore-scheduled 'future))) t)
#+end_src

#+begin_src emacs-lisp
    ;; checking tasks that are assigned to me
    (add-to-list 'org-agenda-custom-commands
                 `("dm" "Tasks assigned to me"
                   tags ,(concat "Assignee={" user-login-name "}")
                   ((org-agenda-overriding-header
                     ,(concat "Tasks assigned to " user-login-name)))) t)
#+end_src

#+begin_src emacs-lisp
    ;; create a sparse tree (current buffer only) with all entries containing
    ;; the word `TODO', `FIXME' or `XXX'
    (add-to-list 'org-agenda-custom-commands
                 '("1" "Task markers (in current buffer)"
                   occur-tree "\\<TODO\\|FIXME\\|XXX\\>") t)
#+end_src

To create PDF output, the GhostScript =ps2pdf= utility must be installed on the
system.

The *exported agenda views* are not *stored* when you use one of those commands
interactively because this might use too much overhead. Instead, there is a
special command to produce all specified files in one step: =C-c a e=.

=C-x C-w=: write the agenda view to a file.

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("E" . "Exported agenda files...") t)

;;*** Printed agenda

    ;; exporting agenda views
    (add-to-list 'org-agenda-custom-commands
                 '("Ea"
                   agenda ""
                   (;; (org-tag-faces nil)
                    (ps-landscape-mode t)
                    (ps-number-of-columns 1))
                   ("~/org-agenda.txt" "~/org-agenda.html" "~/org-agenda.pdf")) t)

    (add-to-list 'org-agenda-custom-commands
                 '("Ep" "Call list"
                   tags-todo "phone"
                   ((org-agenda-prefix-format " %-20:c [ ] " )
                    (org-agenda-remove-tags t)
                    ;; (org-agenda-with-colors nil)
                    (org-agenda-write-buffer-name
                     "Phone calls that you need to make")
                    (ps-landscape-mode t)
                    (ps-number-of-columns 1))
                   ("~/org-calls.pdf")) t)

    (add-to-list 'org-agenda-custom-commands
                 '("Ee" "Print reports (TODO)"
                   ;; See ThinkingRock examples
                   ((agenda ""
                            ((org-agenda-overriding-header "Scheduled TODO's")
                             (org-agenda-prefix-format "%8e ")
                             (org-agenda-skip-function
                              '(org-agenda-skip-entry-if 'regexp "habit"))
                             (org-agenda-sorting-strategy '(todo-state-up))
                             (org-agenda-span 'week)
                             (org-agenda-todo-keyword-format "%-4s")))
                    (tags-todo "thisweek"
                               ((org-agenda-overriding-iding-header
                                 "Unscheduled TODO's; also tasks (from which todo's were generated)")
                                (org-agenda-prefix-format "%-7e")
                                (org-agenda-skip-function
                                 '(org-agenda-skip-entry-if 'scheduled))
                                (org-agenda-sorting-strategy '(todo-state-up))
                                (org-agenda-todo-keyword-format "%-10s"))))
                   ((org-agenda-remove-tags t))
                   ("~/org-agenda-de.html")) t)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("v" . "6. More views...") t)

;;*** Priorities

    ;; priority levels
    (add-to-list 'org-agenda-custom-commands
                 '("v," . "Priorities...") t)

    (add-to-list 'org-agenda-custom-commands
                 '("v,," "Actions Grouped by Priority"
                   (;; important things to do
                    (tags-todo "+PRIORITY={A}")
                    ;; medium important things to do
                    (tags-todo "+PRIORITY={B}")
                    ;; other things to do
                    (tags-todo "+PRIORITY={C}"))) t)

    ;; list only priority A tasks for the current day
    (add-to-list 'org-agenda-custom-commands
                 '("v,A" "Priority #A tasks for today"
                   agenda ""
                   ((org-agenda-skip-function
                     '(org-agenda-skip-entry-if 'notregexp "\\=.*\\[#A\\]"))
                    (org-agenda-span 'day)
                    (org-agenda-overriding-header
                     "Today's priority #A tasks: "))) t)

    ;; list priority A and B tasks for the current day
    (add-to-list 'org-agenda-custom-commands
                 '("v,B" "Priority #A and #B tasks for today"
                   agenda ""
                   ((org-agenda-overriding-header
                     "Today's priority #A and #B tasks: ")
                    (org-agenda-skip-function
                     '(org-agenda-skip-entry-if 'regexp "\\=.*\\[#C\\]"))
                    (org-agenda-span 'day))) t)
#+end_src

#+begin_src emacs-lisp
;;*** Tags

    (add-to-list 'org-agenda-custom-commands
                 '("v:" . "Contexts...") t)

    (add-to-list 'org-agenda-custom-commands
                 '("v:h" "Home realm"
                   tags-todo "home") t)

    (add-to-list 'org-agenda-custom-commands
                 '("v:w" "Work realm"
                   tags-todo "work") t)

    (add-to-list 'org-agenda-custom-commands
                 '("v:e" "Errands context"
                   tags-todo "errands") t)

    (add-to-list 'org-agenda-custom-commands
                 '("v:p" "Phone context"
                   tags-todo "phone") t)

    (add-to-list 'org-agenda-custom-commands
                 '("v:m" "Mail context"
                   tags-todo "mail") t)

    (add-to-list 'org-agenda-custom-commands
                 '("v::" "Next/Started and Delegated/Waiting For Actions Grouped by Context"
                   (;; Next/Started Actions
                    (tags-todo "phone&TODO={TODO\\|STRT}")
                    (tags-todo "mail&TODO={TODO\\|STRT}")
                    (tags-todo "errands&TODO={TODO\\|STRT}")
                    ;; Delegated/Waiting For Actions
                    (tags-todo "phone&TODO={WAIT\\|DLGT}")
                    (tags-todo "mail&TODO={WAIT\\|DLGT}")
                    (tags-todo "errands&TODO={WAIT\\|DLGT}"))) t)
#+end_src

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 '("vp"
                   tags-todo ""
                   ((org-agenda-view-columns-initially t))) t)
#+end_src

**** TODO Organize view

All active *tasks*, filtered by due date:
- *Overdue*
- Completed (today, I guess)
- Due *today*
- Due *tomorrow*
- Due within *a week*
- Due *later*
- *No due date* (includes *In-Tray*)

*************** TODO Do this above view?

#+begin_src emacs-lisp
    (add-to-list 'org-agenda-custom-commands
                 `("dd" "All active tasks, by due date"
                   ((agenda ""
                            ((org-agenda-overriding-header "Today")
                             ;; FIXME We don't see "timed" DEADLINE
                             (org-agenda-skip-function
                              (lambda ()
                                (let* ((dl (org-entry-get nil "DEADLINE")))
                                  (if (or (not dl)
                                          (equal dl "")
                                          (org-time> dl (org-time-today)))
                                      (progn (outline-next-heading) (point))))))
                             (org-agenda-skip-scheduled-if-deadline-is-shown t)
                             (org-agenda-span 'day)
                             (org-deadline-warning-days 0)))
                    (agenda ""
                            ((org-agenda-entry-types '(:deadline))
                             (org-agenda-overriding-header "Tomorrow")
                             (org-deadline-warning-days 1)))
                    (agenda ""
                            ((org-agenda-overriding-header "Next 5 days")
                             (org-agenda-skip-function
                              '(leuven--skip-entry-unless-deadline-in-n-days-or-more 2))
                             (org-deadline-warning-days 7)))
                    (agenda ""
                            ((org-agenda-format-date "")
                             (org-agenda-overriding-header "Next 3 weeks")
                             (org-agenda-skip-function
                              '(leuven--skip-entry-unless-deadline-in-n-days-or-more 7))
                             (org-deadline-warning-days 28)))
                    (agenda ""
                            ((org-agenda-entry-types '(:deadline))
                             (org-agenda-overriding-header
                              "Unscheduled upcoming due dates:")
                             (org-agenda-skip-entry-if 'scheduled)
                             (org-agenda-span 'day)
                             (org-agenda-time-grid nil)
                             (org-deadline-warning-days 365))))
                   ((org-agenda-block-separator "\n")
                    (org-agenda-clockreport-mode nil)
                    (org-agenda-format-date "")
                    (org-agenda-span 'day)
                    (org-agenda-sorting-strategy '(deadline-up))
                    (org-agenda-use-time-grid nil)
                    (org-agenda-write-buffer-name "Reminders"))) t)
#+end_src

Show reminders:
- Overdue actions *(leadtime: -365..-1)*
- Actions for today/tomorrow
- All reminders for the next 5 days

#+begin_src emacs-lisp
    (defun leuven--skip-entry-unless-overdue-deadline ()
      "Skip entries that have no deadline, or that have a deadline later than or equal to today."
      (let* ((dl (org-entry-get nil "DEADLINE")))
        (if (or (not dl)
                (equal dl "")
                (org-time>= dl (org-time-today)))
            (progn (outline-next-heading) (point)))))

    (defun leuven--skip-entry-if-past-deadline ()
      "Skip entries that have a deadline earlier than today."
      (let* ((dl (org-entry-get nil "DEADLINE")))
        (if (org-time< dl (org-time-today))
            (progn (outline-next-heading) (point)))))

    (defun leuven--skip-entry-unless-deadline-in-n-days-or-more (n)
      "Skip entries that have no deadline, or that have a deadline earlier than in N days."
      (let* ((dl (org-entry-get nil "DEADLINE")))
        (if (or (not dl)
                (equal dl "")
                (org-time< dl (+ (org-time-today) (* n 86400))))
            (progn (outline-next-heading) (point)))))

    (add-to-list 'org-agenda-custom-commands
                 `("dt" "Agenda for upcoming TODO entries"
                   ((agenda ""
                            ((org-agenda-format-date "")
                             (org-agenda-overriding-header "Past due")
                             (org-agenda-skip-function
                              'leuven--skip-entry-unless-overdue-deadline)
                             (org-deadline-warning-days 0)))
                    (agenda ""
                            ((org-agenda-overriding-header "Today/tomorrow")
                             (org-agenda-skip-function
                              'leuven--skip-entry-if-past-deadline)
                             (org-agenda-span 2)
                             (org-agenda-use-time-grid t)
                             (org-deadline-warning-days 0)))
                    (agenda ""
                            ((org-agenda-format-date "")
                             (org-agenda-overriding-header "Next 5 days")
                             (org-agenda-skip-function
                              '(leuven--skip-entry-unless-deadline-in-n-days-or-more 2))
                             (org-deadline-warning-days 7))))
                   ((org-agenda-block-separator "\n")
                    (org-agenda-clockreport-mode nil)
                    (org-agenda-span 'day)
                    (org-agenda-use-time-grid nil)
                    (org-agenda-write-buffer-name "Reminders"))
                   "~/org-agenda-upcoming-todo-entries.html") t)
#+end_src

Agenda:
- Overdue
- Today
- Tomorrow
- Next 5 days
- Next 3 weeks
- Later
- No due date

#+begin_src emacs-lisp
    (defun leuven--skip-entry-if-deadline-or-schedule ()
      "Skip entries that have a deadline or that have a scheduled date."
      (let* ((dl (org-entry-get nil "DEADLINE"))
             (sd (org-entry-get nil "SCHEDULED")))
        (if (or (and dl
                     (not (equal dl "")))
                (and sd
                     (not (equal sd ""))))
            (progn (outline-next-heading) (point)))))

    (defun leuven--skip-entry-if-deadline-in-less-than-n-days-or-schedule-in-less-than-n-days (n1 n2)
      "Skip entries that have a deadline in less than N1 days, or that have a
    scheduled date in less than N2 days, or that have no deadline nor scheduled."
      (let* ((dl (org-entry-get nil "DEADLINE"))
             (sd (org-entry-get nil "SCHEDULED")))
        (if (or (and dl
                     (not (equal dl ""))
                     (org-time< dl (+ (org-time-today) (* n1 86400))))
                (and sd
                     (not (equal sd ""))
                     (org-time< sd (+ (org-time-today) (* n2 86400))))
                (and (or (not dl) ;; no deadline
                         (equal dl ""))
                     (or (not sd) ;; nor scheduled
                         (equal sd ""))))
            (progn (outline-next-heading) (point)))))

    (add-to-list 'org-agenda-custom-commands
                 '("dT" "Agenda for all TODO entries"
                   ((agenda ""
                            ((org-agenda-format-date "")
                             (org-agenda-overriding-header "Past due")
                             (org-agenda-skip-function
                              'leuven--skip-entry-unless-overdue-deadline)
                             (org-deadline-warning-days 0)))
                    (agenda ""
                            ((org-agenda-format-date "")
                             (org-agenda-overriding-header "Today/tomorrow")
                             (org-agenda-skip-function
                              'leuven--skip-entry-if-past-deadline)
                             (org-agenda-span 2)
                             (org-agenda-use-time-grid t)
                             (org-deadline-warning-days 0)))
                    (agenda ""
                            ((org-agenda-format-date "")
                             (org-agenda-overriding-header "Next 12 days")
                             (org-agenda-skip-function
                              '(leuven--skip-entry-unless-deadline-in-n-days-or-more 2))
                             (org-deadline-warning-days 14)))
                    (todo ""
                          ((org-agenda-overriding-header "Later")
                           (org-agenda-skip-function
                            '(leuven--skip-entry-if-deadline-in-less-than-n-days-or-schedule-in-less-than-n-days 15 2))
                           (org-agenda-sorting-strategy '(ts-up))))
                    (todo ""
                          ((org-agenda-overriding-header "No due date")
                           (org-agenda-skip-function
                            'leuven--skip-entry-if-deadline-or-schedule))))
                   ((org-agenda-block-separator "\n")
                    (org-agenda-clockreport-mode nil)
                    (org-agenda-prefix-format " %i %?-12t% s")
                    (org-agenda-span 'day)
                    (org-agenda-use-time-grid nil)
                    (org-agenda-write-buffer-name "List Review"))
                   "org-agenda-all-todo-entries.html") t)
#+end_src

*************** TODO Show SCHEDULED items as well in "Next 12 Days"

#+begin_src emacs-lisp
    ;; inbox
    (add-to-list 'org-agenda-custom-commands
                 '("I" "Inbox"
                   todo ""
                   ((org-agenda-files '("~/org/refile.org")))) t)

    ;; emails
    (add-to-list 'org-agenda-custom-commands
                 '("@" "Emails"
                   todo ""
                   ((org-agenda-files '("~/org/email.org")))) t)
#+end_src

*************** TODO Add a custom view which is some "bill" to send to your boss/client (table view)

**** Display all active tasks from the current directory

The function =leuven-org-todo-list-current-dir= will display your tasks from the
current directory (including from local files ~TODO.org~ and ~BUGS.org~, for
example).

*************** TODO Add recursive option to show all tasks from subdir

#+begin_src emacs-lisp
  (defun leuven-org-todo-list-current-dir ()
    "Produce a view from all Org files in the current directory."
    (interactive)
    (let* ((fname (buffer-file-name))
           (dname (if fname
                      (if (file-directory-p fname)
                          fname
                        (file-name-directory fname))
                    default-directory))
           (org-agenda-files (directory-files dname t "\\.\\(org\\|txt\\)$"))
           (org-agenda-sorting-strategy '(priority-down))
           (org-agenda-overriding-header
            (format "TODO list for directory %s" dname))
           (org-agenda-sticky nil))
      (message "%s..." org-agenda-overriding-header)
      (org-todo-list)))

  ;; "TODO list" without asking for a directory
  (global-set-key
    (kbd "<C-f3>") 'leuven-org-todo-list-current-dir)
#+end_src

#+begin_src emacs-lisp
    ) ;; with-eval-after-load "org-agenda" ends here
#+end_src

*** Exporting Agenda Views

#+begin_src emacs-lisp
;;** 10.7 (info "(org)Exporting Agenda Views")

  (leuven--section "10.7 (org)Exporting Agenda Views")

  ;; 10.7 alist of variable/value pairs that should be active during
  ;; agenda export
  (setq org-agenda-exporter-settings
        '((ps-number-of-columns 1)
          (ps-landscape-mode t)
          (htmlize-output-type 'css)))
#+end_src

*************** TODO htmlize-output-type is duplicated lots of times!

*** Agenda column view

#+begin_src emacs-lisp
;;** 10.8 (info "(org)Agenda column view")

  (leuven--section "10.8 (org)Agenda column view")

  ;; 10.8 default column format, if no other format has been defined
  (setq org-columns-default-format
        ;; "%65ITEM(Task) %DEADLINE(Due Date) %PRIORITY %6CLOCKSUM(Spent) %6Effort(Estim.){:}")
        ;; "%1BLOCKED %4TODO %CATEGORY %5Effort{:} %50ITEM %20TAGS %21ALLTAGS")
        "%60ITEM(Details) %5PRIORITY(Prio) %14SCHEDULED(Scheduled) %15TAGS(Context) %7TODO(To Do) %6CLOCKSUM(Clock) %5Effort(Effort){:} ")

  ;; DUPLICATE Obey `eval' variables -- RISKY!
  (setq enable-local-eval t)
#+end_src

*** Not sorted

**** Mouse cursor doesn't highlight agenda lines

XXX Does this work?

#+begin_src emacs-lisp
  (add-hook 'org-agenda-finalize-hook
            (lambda ()
              (remove-text-properties (point-min) (point-max)
                                      '(mouse-face t))))
#+end_src

*************** TODO Adding ":tangle yes" on the above code block results in partial tangling!

** Markup for rich export

#+begin_src emacs-lisp
;;* 11 (info "(org)Markup")

  (leuven--section "11 (org)Markup")

  (with-eval-after-load "org-faces"

    ;; add a face to #+begin_quote and #+begin_verse blocks
    (setq org-fontify-quote-and-verse-blocks t))

  (with-eval-after-load "org"
    (message "... Org Markup")

    ;;??? change the face of a headline (as an additional information) if
    ;; it is marked DONE (to face `org-headline-done')
    (setq org-fontify-done-headline t)

    ;; 11.1 hide the emphasis marker characters
    (setq org-hide-emphasis-markers t) ;; impact on table alignment!
#+end_src

*** Images and Tables

Automatic screenshot insertion.

#+begin_src emacs-lisp
    (defun leuven-org-insert-image-or-take-screenshot (name)
      "Insert a link to an already existing image, or else to a screenshot.

    The screenshot is either taken to the given non-existing file name,
    or added into the given directory, defaulting to the current one."
      ;; FIXME: Should limit to '("pdf" "jpeg" "jpg" "png" "ps" "eps")
      ;; which is org-export-latex-inline-image-extensions.
      (interactive "GImage name? ")
      (when (file-directory-p name)
        (setq name (concat
                    (make-temp-name
                     (expand-file-name
                      (concat (file-name-as-directory name)
                              (subst-char-in-string
                               "." "-"
                               (file-name-sans-extension
                                (file-name-nondirectory
                                 (buffer-file-name)))))))
                    ".png")))
      (unless (file-exists-p name)
        (if (file-writable-p name)
            (progn
              (message "Taking screenshot into %s" name)
              (call-process "import" nil nil nil name)
              (message "Taking screenshot...done"))
          (error "Cannot create image file")))
      (insert (concat "[[" name "]]"))
      (org-display-inline-images)))
#+end_src

*** Embedded LaTeX

To get one entity in the middle of a word, use ={}=, i.e. some =w\entity{}rd= (new
exporter only).

#+begin_src emacs-lisp
  ;; 11.7.1 define user entities to produce special characters
  (with-eval-after-load "org-entities"

    (add-to-list 'org-entities-user
                 '("ok"
                   ;; \definecolor{checkmark}{HTML}{1FAC21}
                   "{\\color{checkmark}\\ding{51}}" nil
                   "<font color='green'>&#x2714;</font>"
                   "OK"
                   "OK" ""))

    (add-to-list 'org-entities-user
                 '("nok"
                   ;; \usepackage{pifont}
                   "{\\color{red}\\ding{55}}" nil
                   "<font color='red'>&#x2718;</font>"
                   "NOK"
                   "NOK" "")))
#+end_src

To list all available entities, run =M-x org-entities-help=.

#+begin_src emacs-lisp
  ;; 11.7 interpret "_" and "^" for export when braces are used
  (setq org-export-with-sub-superscripts '{})

  ;; 11.7 convert LaTeX fragments to images when exporting to HTML (using MathJax)
  (setq org-export-with-LaTeX-fragments t) ;; XXX undefined?
#+end_src

#+begin_src emacs-lisp
  ;; highlight LaTeX and related syntax
  (setq org-highlight-latex-and-related
        '(latex
          script
          entities))
#+end_src

** Exporting

#+begin_src emacs-lisp
;;* 12 (info "(org)Exporting")

  ;; bind the exporter dispatcher to a key sequence
  (with-eval-after-load "org"
    (message "... Org Exporting")

    ;; libraries in this list will be loaded once the export framework is needed
    (setq org-export-backends '(ascii html icalendar latex odt))

    ;; (define-key org-mode-map
    ;;   (kbd "C-c C-e") 'org-export-dispatch)

    ;; XXX temporary (until Org 8 is bundled within Emacs)
    (define-key org-mode-map
      (kbd "C-c C-e")
      (lambda ()
        (interactive)
        (if (fboundp 'org-export-dispatch)
            (org-export-dispatch)
          (message (concat "This version of Org mode is no longer supported. "
                           "Please upgrade to 8 or later"))
          (sit-for 1.5)))))
#+end_src

*** Export options

#+begin_src emacs-lisp
;;** 12.2 (info "(org)Export options")

  (leuven--section "12.2 (org)Export options")

  ;; Org generic export engine
  (with-eval-after-load "ox"

    ;; ;; 12.3 don't insert a time stamp into the exported file
    ;; (setq org-export-time-stamp-file nil)

    ;; 13.1.5 export all drawers (including properties)
    ;; (setq org-export-with-drawers t)

    ;; default language of HTML export (see `org-export-language-setup' XXX)
    (setq org-export-default-language "en")

    ;; include priority cookies in export
    (setq org-export-with-priority t)

    ;; activate smart quotes during export
    (setq org-export-with-smart-quotes t)

    ;; allow #+BIND to define local variable values for export
    (setq org-export-allow-bind-keywords t)

    ;; exported stuff will not be pushed onto the kill ring
    (setq org-export-copy-to-kill-ring nil)

    ;; ;; export and publishing commands will run in background
    ;; (setq org-export-in-background t)

    ;; ;; use a non-intrusive export dispatcher
    ;; (setq org-export-dispatch-use-expert-ui t)

    ;; export snippet translations
    (add-to-list 'org-export-snippet-translation-alist
                 '("l" . "latex"))
    (add-to-list 'org-export-snippet-translation-alist
                 '("b" . "beamer"))

    ) ;; with-eval-after-load "ox" ends here
#+end_src

#+begin_src emacs-lisp
  ;; execute buffer when exporting it (see some thread with Eric Schulte,
  ;; end of December 2010)
  ;;;;;;;;;; (add-hook 'org-export-first-hook 'org-babel-execute-buffer)
#+end_src

*** HTML export

To get a start for your CSS file, use the command =M-x
org-export-htmlize-generate-css= to extract class definitions.

#+begin_src emacs-lisp
;;** 12.5 (info "(org)HTML export")

  ;; Org HTML export engine
  (with-eval-after-load "ox-html"

    ;; output type to be used by htmlize when formatting code snippets
    (setq org-export-htmlize-output-type 'css) ;; XXX

    ;; ;; URL pointing to a CSS file defining text colors for htmlized Emacs buffers
    ;; (setq org-export-htmlized-org-css-url "style.css")

    ;; XML declaration
    (setq org-html-xml-declaration
          '(("html" . "<!-- <xml version=\"1.0\"> -->")
            ("was-html" . "<?xml version=\"1.0\" encoding=\"%s\"?>")
            ("php" . "<?php echo \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\"; ?>")))

    ;; coding system for HTML export
    (setq org-html-coding-system 'utf-8)

    ;; format for the HTML postamble
    (setq org-html-postamble
          "  <div id=\"copyright\">\n    &copy; %d %a\n  </div>")

    ;; 13.1.5 don't include the JavaScript snippets in exported HTML files
    (setq org-html-head-include-scripts nil)

    ;; 12.5.9 turn inclusion of the default CSS style off
    (setq org-html-head-include-default-style nil)
#+end_src

[[http://tidy.sourceforge.net/][HTML Tidy]] is a HTML linter. Please see [[http://www.htmlpedia.org/wiki/HTML_Tidy][List of the Tidy errors]].

#+begin_src emacs-lisp
    ;; check that `tidy' is in PATH, and that configuration file exists
    (when (and (executable-find "tidy")
               (file-exists-p "~/.tidyrc")) ;; tidy-config

      (defun leuven--export-html-final-filter (contents backend info)
        (if (not (eq backend 'html)) contents
          (let* ((in-file "~/tidy-stdin.html")
                          ;; this filepath must be readable by Cygwin
                 (err-file "~/tidy-errors.log")
                 new-contents)
            (with-temp-file in-file
              (insert contents))
            (setq new-contents
                  (shell-command-to-string
                   (format "tidy -config ~/.tidyrc -f %s %s"
                           err-file in-file)))
            (message "HTML Tidy'ed")
            (message "%s" (org-file-contents err-file))
            new-contents)))

      (add-to-list 'org-export-filter-final-output-functions
                   'leuven--export-html-final-filter))

    ) ;; eval-after-load "ox-html" ends here
#+end_src

Emacs 23+ users: in order to avoid "Invalid face" errors, you need to use the
version made available by Carsten Dominik in =org-mode/contrib/lisp= directory.

#+begin_src emacs-lisp
;;** (info "(emacs-goodies-el)htmlize")

  (leuven--section "(emacs-goodies-el)htmlize")

  ;; HTML-ize font-lock buffers
  (autoload 'htmlize-buffer "htmlize"
    "Convert BUFFER to HTML, preserving colors and decorations." t)
  (autoload 'htmlize-region "htmlize"
    "Convert the region to HTML, preserving colors and decorations." t)
  (autoload 'htmlize-file "htmlize"
    "Load FILE, fontify it, convert it to HTML, and save the result." t)

  (with-eval-after-load "htmlize"

    ;; output type of generated HTML
    (setq htmlize-output-type 'css)

    ;; override output type `inline-css' used for htmlizing a region
    (defun htmlize-region-for-paste (beg end)
      "Htmlize the region and return just the HTML as a string.

  This forces the `css' style and only returns the HTML body, but
  without the BODY tag. This should make it useful for inserting
  the text to another HTML buffer."
      (let* ((htmlize-output-type 'css)  ; was `inline-css'
             (htmlbuf (htmlize-region beg end)))
        (unwind-protect
            (with-current-buffer htmlbuf
              (buffer-substring
               (plist-get htmlize-buffer-places 'content-start)
               (plist-get htmlize-buffer-places 'content-end)))
          (kill-buffer htmlbuf))))

    ;; charset declared by the resulting HTML documents
    (setq htmlize-html-charset "utf-8")

    ;; non-ASCII characters (codes in the 128-255 range) are copied to
    ;; HTML without modification -- if your HTML is in Unicode
    (setq htmlize-convert-nonascii-to-entities nil)

    ;; key binding
    (global-set-key
      (kbd "M-P") 'htmlize-buffer)

    ) ;; with-eval-after-load "htmlize" ends here
#+end_src

To get around PostScript problems, you can write the buffer to your browser
and then print from there, and in color.

This adds a Quick Print option to your menu bar (under File).

#+begin_src emacs-lisp
  ;; quick print preview (to Web browser) with `htmlize-view-buffer'
  (GNUEmacs
    (autoload 'htmlize-view-buffer "htmlize-view"
      "Convert buffer to html preserving faces and view in web browser." t)

    ;; same key binding as Org export to HTML (open in browser)
    (global-set-key
      (kbd "C-c C-e h o") 'htmlize-view-buffer)

    ;; view current buffer as html in web browser
    (with-eval-after-load "htmlize-view"

      ;; add "Quick Print" entry to file menu
      (htmlize-view-add-to-files-menu)))
#+end_src

Now, you can print from the browser in (complete) Unicode, using your system's
capabilities.

*** LaTeX and PDF export

#+begin_src emacs-lisp
;;** 12.6 (info "(org)LaTeX and PDF export")
#+end_src

#+begin_src emacs-lisp
  (leuven--section "12.6 (org)LaTeX and PDF export")

  ;; LaTeX back-end
  (with-eval-after-load "ox-latex"

    ;; markup for TODO keywords and for tags, as a printf format
    (defun org-latex-format-headline (todo todo-type priority text tags)
      "Default format function for an headline."
      (concat (when todo
                (format "{%s\\textbf{\\textsc{\\textsf{%s}}}} "
                        (cond ((equal todo-type 'todo) "\\color{red}")
                              ((equal todo-type 'done) "\\color{teal}")
                              (t "\\color{gray}"))
                        todo))
              (when priority
                (format "\\framebox{\\#%c} " priority))
              text
              (when tags
                (format "\\hfill{}\\fbox{\\textsc{%s}}"
                ;; XXX source of "undefined control sequence"?
                  (mapconcat 'identity tags ":")))))

    ;; function for formatting the headline's text
    (setq org-latex-format-headline-function
          'org-latex-format-headline)

    ;; format string for links with unknown path type
    (setq org-latex-link-with-unknown-path-format "\\colorbox{red}{%s}")
#+end_src

Look at the variable =org-latex-remove-logfiles=, which controls whether some
of the files produced by LaTeX (=org-latex-logfiles-extensions=) are removed.

#+begin_src emacs-lisp
    (defun leuven--change-pdflatex-program (backend)
      "When exporting an Org document to LaTeX, automatically run XeLaTeX,
    if asked."

      ;; default (in Windows binary)
      (setq org-latex-pdf-process
            (if (executable-find "latexmk")
                '("latexmk -CF -pdf %f && latexmk -c")
                                        ; must clean .fdb_latexmk, .fls, .ilg,
                                        ; .ind, etc.
              '("pdflatex -interaction=nonstopmode -output-directory=%o %f"
                "pdflatex -interaction=nonstopmode -output-directory=%o %f"
                "pdflatex -interaction=nonstopmode -output-directory=%o %f")))

      (when (string-match "^#\\+LATEX_CMD: xelatex" (buffer-string))
        (setq org-latex-pdf-process
              (if (executable-find "latexmk")
                  '("latexmk -CF -pdf -pdflatex=xelatex %f && latexmk -c")
                '("xelatex -interaction=nonstopmode -output-directory=%o %f"
                  "xelatex -interaction=nonstopmode -output-directory=%o %f"
                  "xelatex -interaction=nonstopmode -output-directory=%o %f")))))

    ;; hook run before parsing an export buffer
    (add-hook 'org-export-before-parsing-hook
              'leuven--change-pdflatex-program)
#+end_src

You can easily customize this variable on a per file basis. If you seldom use
=bibtex=, have the default be to run =pdflatex= just once or twice. Then, for any
Org file that needs =bibtex=, simply put in the following line (or a variation
thereof):

#+begin_src org :tangle no
,#+BIND: org-latex-pdf-process ("pdflatex %b" "bibtex %b" "pdflatex %b" "pdflatex %b")
#+end_src

Also, you can use =latexmk= (in TeX Live) which can save you some time when it
is not necessary to rebuild index and/or bibliography.

#+begin_src emacs-lisp
    ;; export source code using `listings' (instead of `verbatim')
    (setq org-latex-listings t)

    ;; 12.6.2 default packages to be inserted in the header
    ;; include the `listings' package for fontified source code
    (add-to-list 'org-latex-packages-alist '("" "listings") t)

    ;; include the `xcolor' package for colored source code
    (add-to-list 'org-latex-packages-alist '("" "xcolor") t)
#+end_src

When using the =utf8= option to =inputenc= (and not =utf8x= which should be avoided,
as it uses =ucs= which is no longer maintained), we have 2 solutions to support
the UTF-8 *non-breaking space*:

- Convert it in Org mode, when exporting (via a filter), or

#+begin_src emacs-lisp :tangle no
    (defun leuven--latex-filter-nbsp (text backend info)
      "Ensure that non-breaking spaces are properly handled in LaTeX/Beamer export."
      (when (memq backend '(latex beamer))
        (replace-regexp-in-string "" "~" text)))

    ;; check that it's defined (in org-export.el)
    (add-to-list 'org-export-filter-plain-text-functions
                 'leuven--latex-filter-nbsp)
#+end_src

- Convert it in LaTeX:

#+begin_src emacs-lisp
    ;; convert `nbsp' to its LaTeX equivalent
    (add-to-list 'org-latex-packages-alist
                 (concat "\\ifdefined\\DeclareUnicodeCharacter{"
                         "\\DeclareUnicodeCharacter{00A0}{~}"
                         "}\\fi") t)
#+end_src

The exporter will *add* a language option to the =babel= package according to the
=#+LANGUAGE:= keyword (only) if:

- The =babel= package is explicitly loaded (in preamble), _and_
- The language is different from the one set by the user.

#+begin_src emacs-lisp
    ;; include the `babel' package for language-specific hyphenation and
    ;; typography
    (add-to-list 'org-latex-packages-alist '("french" "babel") t)
#+end_src

What about =apacite= and =tikz= in =org-latex-packages-alist=?

#+begin_src emacs-lisp
    (defun leuven--change-pdflatex-packages (backend)
      "When exporting an Org document to LaTeX, automatically select the
    LaTeX packages to include (depending on PDFLaTeX vs XeLaTeX)."

      ;; unconditionally remove `inputenc' from all the default packages
      (setq org-latex-packages-alist
            (delete '("AUTO" "inputenc" t)
                    org-latex-packages-alist))

      ;; unconditionally remove `fontenc' from all the default packages
      (setq org-latex-packages-alist
            (delete '("T1" "fontenc" t)
                    org-latex-packages-alist))

      ;; unconditionally remove `textcomp' from all the default packages
      (setq org-latex-packages-alist
            (delete '("" "textcomp" t)
                    org-latex-packages-alist))

      (if (string-match "^#\\+LATEX_CMD: xelatex" (buffer-string))
          ;; packages to include when XeLaTeX is used
          (setq org-export-latex-packages-alist
                '(("" "fontspec" t)
                  ("" "xunicode" t)
                  ;; add here things like `\setmainfont{Georgia}'
                  ))

        ;; packages to include when PDFLaTeX is used
        (setq org-export-latex-packages-alist
              '(("AUTO" "inputenc" t)
                ("T1" "fontenc" t)
                ("" "textcomp" t))))

      ;; packages to always include
      (add-to-list 'org-export-latex-packages-alist
                   '("frenchb" "babel") t))

    ;; hook run before parsing an export buffer
    (add-hook 'org-export-before-parsing-hook
              'leuven--change-pdflatex-packages)
#+end_src

#+begin_src emacs-lisp
    ;; 12.6.5 default position for LaTeX figures
    (setq org-latex-default-figure-position "!htbp")
#+end_src

#+begin_src emacs-lisp
    ) ;; with-eval-after-load "ox-latex" ends here
#+end_src

*** LaTeX Beamer and PDF export

#+begin_src emacs-lisp
  ;; 12.6.6 Beamer class export
  ;; (require 'ox-beamer)
  (with-eval-after-load "ox-beamer"

    (message "ox-beamer LOADED!") (sit-for 5)

    ;; default title of a frame containing an outline
    (setq org-beamer-outline-frame-title "Plan"))
#+end_src

*** OpenDocument Text (ODT)

ODT export is not loaded by default. You will have to load it explicitly or to
add it to =org-export-backends=.

#+begin_src emacs-lisp
  (with-eval-after-load "ox-odt"

    ;; convert "odt" format to "doc" format
    (setq org-odt-preferred-output-format "doc"))
#+end_src

** Publishing

Publish related Org mode files as a website.

*************** Publishing                                            :warning:
It can be used for generating different PDF files from the same source file...
See [[http://orgmode.org/worg/org-tutorials/org-latex-export.html#sec-9-2][9.2 The Multiple Export Case]].
*************** END

#+begin_src emacs-lisp
;;* 13 (info "(org)Publishing")

  (leuven--section "13 (org)Publishing")

  (with-eval-after-load "ox-publish"

    ;; show message about files *not* published
    (setq org-publish-list-skipped-files nil)
#+end_src

*** Uploading files

#+begin_src emacs-lisp
    ;; ;; 13.2 always publish all files
    ;; ;; (do not use time stamp checking for skipping unmodified files)
    ;; (setq org-publish-use-timestamps-flag nil)
#+end_src

*** Triggering publication

#+begin_src emacs-lisp
    ;; 13.4 force publishing all files
    (defun org-publish-all-force ()
      (interactive)
      (org-publish-all t)))
#+end_src

** Working With Source Code

Literate programming and reproducible research.

#+begin_src emacs-lisp
;;* 14 (info "(org)Working With Source Code")

  (with-eval-after-load "ob-core"

    ;; make the images in the Emacs buffer automatically refresh after
    ;; execution
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+end_src

#+begin_src emacs-lisp
    (defadvice org-babel-next-src-block
      (after leuven-org-babel-next-src-block activate)
      "Recenter after jumping to the next source block."
      (recenter))

    (defadvice org-babel-previous-src-block
      (after leuven-org-babel-previous-src-block activate)
      "Recenter after jumping to the previous source block."
      (recenter))
    )
#+end_src

#+begin_src emacs-lisp
    (defadvice org-agenda-switch-to
      (after leuven-org-agenda-switch-to activate)
      "Recenter after jumping to the file which contains the item at point."
      (recenter))
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load "ob-sh"

    ;; command used to invoke a shell
    (setq org-babel-sh-command "bash")

    ;; use plain old syntax (instead of `$(...)') for Cygwin
    (setq org-babel-sh-var-quote-fmt
          "`cat <<'BABEL_TABLE'\n%s\nBABEL_TABLE\n`"))
#+end_src

*** Editing source code

#+begin_src emacs-lisp
;;** 14.2 (info "(org)Editing source code")

  (leuven--section "14.2 (org)Editing source code")
#+end_src

Mapping between languages (listings in LaTeX) and their major mode (in Emacs).

#+begin_src emacs-lisp
  (with-eval-after-load "org-src"

    ;; mapping languages to their major mode (for editing the source code block
    ;; with `C-c '')
    (add-to-list 'org-src-lang-modes
                 '("dot" . graphviz-dot)))
#+end_src

#+begin_src emacs-lisp
  ;; display the source code edit buffer in the current window, keeping
  ;; all other windows
  (setq org-src-window-setup 'current-window)

  ;; FIXME Bind this to the correct keys
  (defun leuven--org-babel-expand-src-block ()
    (interactive)
    (let ((org-src-window-setup 'reorganize-frame))
      (org-babel-expand-src-block)))

  ;; indent the content of a source code block
  (setq org-edit-src-content-indentation 2)

  ;; fontify code in code blocks (highlight syntax in the org-buffer)
  (setq org-src-fontify-natively t)
  ;;! create overlay `org-block-background' and remove text property
  ;;! `org-block'

  ;; preserve spaces and `tab' characters in source code blocks
  (setq org-src-preserve-indentation t)

  ;; same effect for `tab' as in the language major mode buffer
  (setq org-src-tab-acts-natively t)


  (with-eval-after-load "org"
    (message "... Org Editing source code")

    ;; allow indent region in the code edit buffer (according to language)
    (defun leuven-org-indent-region (&optional arg)
      (interactive "P")
      (or (org-babel-do-key-sequence-in-edit-buffer (kbd "C-M-\\"))
          (indent-region arg)))

    ;; make `C-c C-v C-x C-M-\' more convenient
    (define-key org-mode-map
      (kbd "C-M-\\") 'leuven-org-indent-region))

  ;; prevent auto-filling in src blocks
  (setq org-src-prevent-auto-filling t)

  (global-set-key
    (kbd "C-c C-v C-d") 'org-babel-demarcate-block)
#+end_src

C-c TAB
Toggle the visibility of existing tags in the buffer. This can be used as a
cheap preview (sgml-tags-invisible).

View just the source-code blocks within the current Babel file (something
logically equivalent to "tangle", but without creating a separate file).

#+begin_src emacs-lisp
  (defvar only-code-overlays nil
    "Overlays hiding non-code blocks.")
  (make-variable-buffer-local 'only-code-overlays)

  (defun hide-non-code ()
    "Hide non-code-block content of the current Org mode buffer."
    (interactive)
    (add-to-invisibility-spec '(non-code))
    (let (begs ends)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward org-babel-src-block-regexp nil t)
          (push (match-beginning 5) begs)
          (push (match-end 5)       ends))
        (map 'list (lambda (beg end)
                     (let ((ov (make-overlay beg end)))
                       (push ov only-code-overlays)
                       (overlay-put ov 'invisible 'non-code)))
             (cons (point-min) (reverse ends))
             (append (reverse begs) (list (point-max)))))))

  (defun show-non-code ()
    "Show non-code-block content of the current Org mode buffer."
    (interactive)
    (mapc 'delete-overlay only-code-overlays))
#+end_src

*** Evaluating code blocks

#+begin_src emacs-lisp
;;** 14.5 (info "(org)Evaluating code blocks")

  (leuven--section "14.5 (org)Evaluating code blocks")

  ;; I don't want to execute code blocks with `C-c C-c' (evaluate code
  ;; block only with `C-c C-v e')
  (setq org-babel-no-eval-on-ctrl-c-ctrl-c t)

  ;; languages for which Babel will raise literate programming errors
  ;; when noweb references can not be resolved.

  (with-eval-after-load "ob-core"
    (add-to-list 'org-babel-noweb-error-langs "emacs-lisp"))
#+end_src

*** Library of Babel

#+begin_src emacs-lisp
;;** 14.6 (info "(org)Library of Babel")

  (leuven--section "14.6 (org)Library of Babel")

  (with-eval-after-load "ob-lob"

    ;; load the NAMED code blocks defined in Org mode files into the
    ;; library of Babel (global `org-babel-library-of-babel' variable)
    (let ((lob-file (concat (file-name-directory (locate-library "org"))
                            "../doc/library-of-babel.org")))
      (when (file-exists-p lob-file)
        (org-babel-lob-ingest lob-file))))
#+end_src

*** Languages

#+begin_src emacs-lisp
  ;; template used to export the body of code blocks
  (setq org-babel-exp-code-template
        ;; (concat "\n=%name=:\n"
                "#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC")
        ;; )

  ;; keep lower-case
  (setq org-babel-results-keyword "results")
#+end_src

Customize the =org-babel-load-languages= variable to enable support for
languages which can be evaluated in Org mode buffers.

#+begin_src emacs-lisp
;;** 14.7 (info "(org)Languages")

  (leuven--section "14.7 (org)Languages")

  ;; FIXME Test executable-find (of Rterm, gnuplot, ruby, etc.) before
  ;; setting language to yes...

  (with-eval-after-load "org"
    (message "... Org Languages")

    (org-babel-do-load-languages ;; loads org, gnus-sum, etc...
     'org-babel-load-languages
     '((C . nil)
       (R . t) ;; requires R and ess-mode
       (awk . t)
       (calc . t)
       (ditaa . t) ;; sudo aptitude install openjdk-6-jre
       (dot . t)
       (emacs-lisp . t)
       (gnuplot . t) ;; requires gnuplot-mode
       (haskell . nil)
       (latex . t)
       (ledger . t) ;; requires ledger
       (ocaml . nil)
       (octave . nil)
       (org . t)
       (perl . nil)
       (python . t)
       (ruby . nil)
       (screen . nil)
       (sh . t)
       (sql . t)
       (sqlite . nil))))
#+end_src

=screen= offers support for interactive terminals. Mostly shell scripts. Heavily
inspired by =eev=.

Eric Schulte believes screen has more of a focus on sustained interaction with
an interactive terminal

** Miscellaneous

#+begin_src emacs-lisp
;;* 15 (info "(org)Miscellaneous")
#+end_src

#+begin_src emacs-lisp
  ;; from Dan Davison
  (defun leuven-switch-to-org-scratch ()
    "Switch to a temp Org buffer. If the region is active, insert it."
    (interactive)
    (let ((contents (and (region-active-p)
                         (buffer-substring (region-beginning)
                                           (region-end)))))
      (find-file "/tmp/org-scratch.org")
      (if contents (insert contents))))
#+end_src

*** Ispell

*************** TODO ad-handle-definition: `org-mode-flyspell-verify' got redefined
IIUC, this message appears when the original definition of the adviced
function is loaded (AFTER having been adviced).
*************** END

#+begin_src emacs-lisp
  ;; ;; flyspell should not check babel blocks
  ;; (defadvice org-mode-flyspell-verify
  ;;   (after leuven-org-mode-flyspell-verify activate)
  ;;   "Don't spell check src blocks."
  ;;   (require 'org-element)
  ;;   (setq ad-return-value
  ;;         (and ad-return-value
  ;;              (not (eq (org-element-type (org-element-at-point))
  ;;                       'src-block)))))
#+end_src

#+begin_src emacs-lisp
  (defun leuven--org-switch-language ()
    "Switch language if a `#+LANGUAGE:' Org meta-tag is on top 8 lines."
    (save-excursion
      (goto-line (1+ 8))
      (let (lang
            (dico-alist '(("fr" . "francais")
                          ("en" . "american"))))
        (when (re-search-backward "#\\+LANGUAGE: +\\([[:alpha:]_]*\\)" 1 t)
          (setq lang (match-string 1))
          (ispell-change-dictionary (cdr (assoc lang dico-alist)))))))

  ;; guess language
  (add-hook 'org-mode-hook 'leuven--org-switch-language)
#+end_src

*** Easy templates

#+begin_src emacs-lisp
;;** 15.2 (info "(org)Easy Templates")

  (leuven--section "15.2 (org)Easy Templates")

  (with-eval-after-load "org"
    (message "... Org Easy Templates")

    ;; keep lower-case (easy templates)
    (setq org-structure-template-alist
          '(("s" "#+begin_src ?\n\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
            ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
            ("v" "#+begin_verse\n?\n#+end_verse" "<verse>\n?\n</verse>")
            ("c" "#+begin_center\n?\n#+end_center" "<center>\n?\n</center>")
            ("l" "#+begin_latex\n?\n#+end_latex" "<literal style=\"latex\">\n?\n</literal>")
            ("L" "#+latex: " "<literal style=\"latex\">?</literal>")
            ("h" "#+begin_html\n?\n#+end_html" "<literal style=\"html\">\n?\n</literal>")
            ("H" "#+html: " "<literal style=\"html\">?</literal>")
            ("a" "#+begin_ascii\n?\n#+end_ascii")
            ("A" "#+ascii: ")
            ("i" "#+index: ?" "#+index: ?")
            ("I" "#+include: %file ?" "<include file=%file markup=\"?\">")))

    (add-to-list 'org-structure-template-alist
                 '("C" "#+begin_comment\n?\n#+end_comment")))
#+end_src

*** Speed keys

Activate single letter commands (for example, outline navigation with =f=, =b=, =n=,
and =p=) at beginning of a headline:

- =f= ::
     =org-forward-same-level=

- =b= ::
     =org-backward-same-level=

- =n= ::
     =outline-next-visible-heading=

- =p= ::
     =outline-previous-visible-heading=

For navigating blocks:

- F ::
     =org-next-block=

- B ::
     =org-previous-block=

#+begin_src emacs-lisp
;;** 15.3 (info "(org)Speed keys")

  (leuven--section "15.3 (org)Speed keys")

  (with-eval-after-load "org"
    (message "... Org Speek keys")

    ;; activate single letter commands at beginning of a headline
    (setq org-use-speed-commands t))
#+end_src

*** Code evaluation and security issues

For security reasons, evaluation is not turned on by default.

#+begin_src emacs-lisp
;;** 15.4 (info "(org)Code evaluation security") issues

  (leuven--section "15.4 (org)Code evaluation security issues")

  (with-eval-after-load "ob-core"

    ;;!! don't be prompted on every code block evaluation
    (setq org-confirm-babel-evaluate nil))
#+end_src

*** A cleaner outline view

#+begin_src emacs-lisp
;;** 15.8 A (info "(org)Clean view")

  (with-eval-after-load "org"
    (message "... Org Clean view")

    ;; 15.8 don't skip even levels for the outline
    (setq org-odd-levels-only nil))
#+end_src

*** Interaction with other packages

#+begin_src emacs-lisp
;;** 15.10 (info "(org)Interaction")

  (leuven--section "15.10 (org)Interaction")
#+end_src

#+begin_src emacs-lisp
  ;; extension of Imenu
  (when (and ;; `org-babel' has been loaded
             (fboundp 'org-babel-execute-src-block)

             ;; `imenu' has been loaded
             (fboundp 'try-to-add-imenu))

    (try-require 'imenu+)

    (setq org-src-blocks-imenu-generic-expression
          `(("Snippets" ,org-babel-src-name-w-name-regexp 2)))

    (add-hook 'org-mode-hook
              (lambda ()
                (setq imenu-generic-expression
                      org-src-blocks-imenu-generic-expression))))


  ;; alternative to imenu
  (defun dan/find-in-buffer ()
    (interactive)
    (let ((targets
           `(("<named src blocks>" . ,org-babel-src-name-regexp)
             ("<src block results>" . ,org-babel-result-regexp))))
      (occur
       (cdr
        (assoc
         (completing-read "Find: " (mapcar #'car targets)) targets)))
      (other-window 1)))
#+end_src

#+begin_src emacs-lisp
  ;; allow YASnippet to do its thing in Org files
  ;;! make sure you initialise YASnippet *before* Org mode
  (when (try-require 'yasnippet)

    (defun yas/org-very-safe-expand ()
      (let ((yas/fallback-behavior 'return-nil))
        (yas/expand)))

    (add-hook 'org-mode-hook
              (lambda ()
                ;; YASnippet (using the new org-cycle hooks)
                (set (make-local-variable 'yas/trigger-key) (kbd "tab")) ;; needed?
                (add-to-list 'org-tab-first-hook
                             'yas/org-very-safe-expand)
                (define-key yas/keymap
                  (kbd "tab") 'yas/next-field) ;; `yas/next-field-or-maybe-expand'?
                )))
#+end_src

*** Org-crypt

To later decrypt an entry that's encrypted, use =M-x org-decrypt-entry= or =C-c
C-r= (fits nicely with the meaning of "reveal").

#+begin_src emacs-lisp
  ;; keep my encrypted data (like account passwords) in my Org mode
  ;; files with a special tag instead
  (with-eval-after-load "org"
    (message "... Org Crypt")

    (when (try-require 'org-crypt) ;; loads org, gnus-sum, etc...

      ;; encrypt all entries before saving
      (org-crypt-use-before-save-magic)

      ;; which tag is used to mark headings to be encrypted
      (setq org-tags-exclude-from-inheritance '("crypt"))))
#+end_src

** Consistency check

#+begin_src emacs-lisp :tangle no
  (add-hook 'org-mode-hook
            (lambda ()
              (save-excursion
                (goto-char (point-min))
                (if (search-forward "#+AUTHOR:" nil t)
                    (unless (search-forward "#+Time-stamp:" nil t)
                      (display-warning 'org
                                       (format "The file `%s' does not contain a \"#+Time-stamp:\" line -- while #+AUTHOR found."
                                               (buffer-name (current-buffer)))
                                       :warning))))))
#+end_src

** Obsoleted syntax

The following syntax checks should be made just *before exporting*
documents, *not when opening* the files for the agenda, for example (for
performance reasons)!

*** Org 7.8

#+begin_src emacs-lisp :tangle no
  ;; warn about deprecated features since version 7.8
  (add-hook 'org-mode-hook
            (lambda ()
              (save-excursion
                (goto-char (point-min))
                (when (re-search-forward (org-make-options-regexp
                                          '("BABEL")) nil t)
                  (display-warning 'org-babel
                                   (format "The file `%s' contains a \"#+BABEL:\" line."
                                           (buffer-name (current-buffer)))
                                   :warning)))))

  (add-hook 'org-mode-hook
            (lambda ()
              (save-excursion
                (goto-char (point-min))
                (let ((n (count-matches "#\\+\\(srcname\\|source\\):")))
                (when (> n 0)
                  (display-warning 'org-babel
                                   (format (concat "The file `%s' contains %s \"#+src"
                                                   "name:\" or \"#+"
                                                   "source:\" lines.")
                                           ;; trick to avoid srcname to
                                           ;; be found in the Org file
                                           ;; itself which tangles
                                           ;; `.emacs' file
                                           (buffer-name (current-buffer))
                                           n)
                                   :warning))))))

  (add-hook 'org-mode-hook
            (lambda ()
              (save-excursion
                (goto-char (point-min))
                (let ((n (count-matches "#\\+\\(\\(src\\)?name\\|source\\):.+=")))
                  (when (> n 0)
                    (display-warning 'org-babel
                                     (format "The file `%s' contains %s deprecated variable assignments."
                                             (buffer-name (current-buffer))
                                             n)
                                     :warning))))))

  ;; function to update Org mode buffers to use the new code block
  ;; syntax (switch between versions 7.7 and 7.8)
  (defun update-org-buffer ()
    "Update an Org mode buffer to the new data, code block and call line syntax."
    (interactive)
    (save-excursion
      (flet ((to-re (lst) (concat "^[ \t]*#\\+" (regexp-opt lst t)
                                  "\\(\\[\\([[:alnum:]]+\\)\\]\\)?\\:[ \t]*"))
             (update (re new)
                     (goto-char (point-min))
                     (while (re-search-forward re nil t)
                       (replace-match new nil nil nil 1))))
        (let ((old-re (to-re '("RESULTS" "DATA" "SRCNAME" "SOURCE")))
              (lob-re (to-re '("LOB")))
              (case-fold-search t))
          (update old-re "name")
          (update lob-re "call")))))
#+end_src

#+begin_src emacs-lisp :tangle no
  (defun leuven--org-check-property-line ()
    "Check the syntax of #+PROPERTY lines."
    (interactive)
    (goto-char (point-min))
    (search-forward "#+PROPERTY:" nil t)
    (if (looking-at " *:")
        (display-warning 'org-babel
                         (format "The file `%s' contains a syntax error on #+PROPERTY line: abusive colon."
                                 (buffer-name (current-buffer)))
                         :warning)))

  (add-hook 'org-mode-hook 'leuven--org-check-property-line)
#+end_src

*** Org 8

- =#+SETUPFILE:= must be followed by a path enclosed by double quotes
- So does =#+INCLUDE:=...

** Other

#+begin_src emacs-lisp
  ;; don't pad tangled code with newlines
  (setq org-babel-tangle-pad-newline nil)

  ;; how to combine blocks of the same name during tangling
  (setq org-babel-tangle-named-block-combination 'append)


  ;; minimum number of lines for output *block* (placed in a
  ;; #+begin_example...#+end_example) vs output marked as literal by
  ;; inserting a *colon* at the beginning of the lines
  (setq org-babel-min-lines-for-block-output 2)
#+end_src

#+begin_src emacs-lisp
  ;; ;; FIXME Make this the default behavior
  ;; ;; grab the last line too, when selecting a subtree
  ;; (org-end-of-subtree nil t)
#+end_src

#+begin_src emacs-lisp
  ;; backend aware export preprocess hook
  (defun leuven--org-export-preprocess-hook ()
    "My backend aware export preprocess hook."
    (save-excursion
      (when (eq org-export-current-backend 'latex)
        ;; ignoreheading tag for bibliographies and appendices
        (let* ((tag "ignoreheading"))
          ;; (goto-char (point-min))
          ;; (while (re-search-forward (concat ":" tag ":") nil t)
          ;; (delete-region (point-at-bol) (point-at-eol)))
          (org-map-entries
           (lambda ()
             (delete-region (point-at-bol) (point-at-eol)))
           (concat ":" tag ":"))))
      (when (eq org-export-current-backend 'html)
        ;; set custom css style class based on matched tag
        (let* ((match "Qn"))
          (org-map-entries
           (lambda ()
             (org-set-property "HTML_CONTAINER_CLASS" "inlinetask"))
           match)))))

  (add-hook 'org-export-preprocess-hook 'leuven--org-export-preprocess-hook)
#+end_src

#+begin_src emacs-lisp
  (defun insert-one-equal-or-two ()
    (interactive)
    (cond
     ((or (bolp) (not (looking-back "=")))
      ;; insert just one =
      (self-insert-command 1))
     ((save-excursion
        (backward-char)
        ;; Skip symbol backwards.
        (and (not (zerop (skip-syntax-backward "w_")))
             (not (looking-back "="))
             (or (insert-and-inherit "=") t))))
     (t
      ;; insert == around following symbol
      (delete-backward-char 1)
      (unless (looking-back "=") (insert-and-inherit "="))
      (save-excursion
        (skip-syntax-forward "w_")
        (unless (looking-at "=") (insert-and-inherit "="))))))

  ;; must be in eval-after-load "org"?
  ;; (define-key org-mode-map
  ;;   (kbd "=") 'insert-one-equal-or-two)
#+end_src

Export the current subtree into an email body, using *properties* to populate
the mail message:

- =MAIL_SUBJECT= or subtree heading -> "Subject"
- =MAIL_TO= -> "To"
- =MAIL_CC= -> "Cc
- =MAIL_BCC= -> "BCc"
- =MAIL_FMT= -> determines the format of the email (e.g., =org= by default, =ascii=
or =html=)

#+begin_src emacs-lisp
  (with-eval-after-load "org"
    (message "... Org Mime")

    ;; using Org mode to send buffer/subtree per mail
    (when (try-require 'org-mime)

      (add-hook 'org-mode-hook
                (lambda ()
                  (local-set-key
                    (kbd "C-c m") 'org-mime-subtree)))

      (defun leuven-mail-subtree ()
        (interactive)
        (org-agenda-goto)
        (org-mime-subtree))

      (add-hook 'org-agenda-mode-hook
                (lambda ()
                  (local-set-key
                    (kbd "C-c m") 'leuven-mail-subtree)))

      ;; add a `mail_composed' property with the current time when
      ;; `org-mime-subtree' is called
      (add-hook 'org-mime-send-subtree-hook
                (lambda ()
                  (org-entry-put (point) "mail_composed"
                                 (current-time-string))))))
#+end_src

** A.3 Adding hyperlink types

For more flexibility, you can use a URL-like syntax which could then export
conditionally on the output format.

See http://orgmode.org/worg/org-tutorials/org-latex-export.html#sec-10-3

#+begin_src emacs-lisp
;;** A.3 (info "(org)Adding hyperlink types")

  ;; ;; define a new link type (`latex') whose path argument can hold the name of
  ;; ;; any LaTeX command
  ;; (org-add-link-type
  ;;  "latex" nil
  ;;  (lambda (path desc format)
  ;;    (cond
  ;;     ((eq format 'html)
  ;;      (format "<span class=\"%s\">%s</span>" path desc))
  ;;     ((eq format 'latex)
  ;;      (format "\\%s{%s}" path desc)))))

  (with-eval-after-load "org"
    (message "... Org Adding hyperlink types")

    ;; add background color by using custom links like [[bgcolor:red][Warning!]]
    (org-add-link-type
      "bgcolor" nil
      (lambda (path desc format)
       (cond
        ((eq format 'html)
         (format"<span style=\"background-color:%s;\">%s</span>" path desc))
        ((eq format 'latex)
         (format"\\colorbox{%s}{%s}" path desc))
        (t
         (format"BGCOLOR LINK (%s): {%s}{%s}" format path desc))))))
#+end_src

** A.6 Dynamic blocks

#+begin_src emacs-lisp
;;** A.6 (info "(org)Dynamic blocks")

  (with-eval-after-load "org"
    (message "... Org Update dynamic blocks and tables")

    (defun leuven-org-update-buffer ()
      "Update all dynamic blocks and all tables in the buffer."
      (interactive)
      (when (eq major-mode 'org-mode)
        (message "(Info) Update Org buffer %s"
                 (file-name-nondirectory (buffer-file-name)))
        (sit-for 1.5)
        (let ((flyspell-mode-before-save flyspell-mode))
          (flyspell-mode -1)              ; temporarily disable Flyspell to avoid
                                          ; checking the following modifications
                                          ; of the buffer
          (org-align-all-tags)
          (org-update-all-dblocks)
          ;; (when (fboundp 'org-table-iterate-buffer-tables)
          (org-table-iterate-buffer-tables)
          ;; )
          (when (file-exists-p (buffer-file-name (current-buffer)))
            (leuven--org-remove-redundant-tags))
          (when flyspell-mode-before-save (flyspell-mode 1)))))

    ;; make sure that all dynamic blocks and all tables are always
    ;; up-to-date
    (add-hook 'before-save-hook 'leuven-org-update-buffer)
    (message "Add leuven-org-update-buffer to before-save-hook") (sit-for 1.5))
#+end_src

** Org-contrib

*** Org-effectiveness

#+begin_src emacs-lisp
  (with-eval-after-load "org"
    (message "... Org Effectiveness")

    (when (try-require 'org-effectiveness)

      (add-hook 'org-mode-hook
                (lambda ()
                  (org-effectiveness-count-todo)
                  (sit-for 0.2)))))
#+end_src

*** Org-notmuch

Link emails from Org files.

*** Google Weather

#+begin_example
,* Weather
  :PROPERTIES:
  :CATEGORY: Weather
  :END:

%%(org-google-weather "Lille" "en-gb")
#+end_example

# Contacting host: www.google.com:80 (proxy!?)

#+begin_src emacs-lisp
  (GNUEmacs
    ;; add weather forecast in your Org agenda
    (autoload 'org-google-weather "org-google-weather"
      "Return Org entry with the weather for LOCATION in LANGUAGE." t)

    (with-eval-after-load "org-google-weather"
      ;; (try-require 'url)

      ;; add the city
      (setq org-google-weather-format "%C %i %c, %l-%h")))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 25.9-org-mode ends here
#+end_src

* TeX

#+begin_src emacs-lisp
;;** 25.10 (info "(emacs)TeX Mode")

(leuven--chapter leuven-chapter-25.10-tex-mode "25.10 TeX Mode"
#+end_src

** Native TeX Mode

- (la)tex-mode ::
     Default Emacs built-in (La)TeX mode (menu =TeX=; text =LaTeX= displayed in the
     mode line)

#+begin_src emacs-lisp
  (leuven--section "25.10 (emacs)TeX Mode")
#+end_src

Under Windows, in the *native* TeX mode, =shell-file-name= must be =cmdproxy.exe= to:

- avoid the error "comint-send-string: writing to process: invalid argument,
  tex-shell", and

- properly quote =tex-start-commands=.

#+begin_src emacs-lisp
  ;; get colored PDFLaTeX output
  (define-derived-mode latex-output-mode fundamental-mode "LaTeX-Output"
    "Simple mode for colorizing LaTeX output."
    (set (make-local-variable 'font-lock-defaults)
         '((("^!.*" .
             compilation-error-face) ;; LaTeX error
            ("^-+$" .
             compilation-info-face) ;; Latexmk separator
            ("^Package .* Warning: .*" .
             compilation-warning-face)
            ("Reference .* undefined" .
             compilation-warning-face)
            ("^\\(?:Overfull\\|Underfull\\|Tight\\|Loose\\).*" .
             font-lock-string-face)
            ("^LaTeX Font Warning:" .
             font-lock-string-face)
            ;; ...
            ))))

  (defadvice TeX-recenter-output-buffer
    (after leuven-colorize-latex-output activate)
    (with-selected-window (get-buffer-window (TeX-active-buffer))
      (latex-output-mode)))
#+end_src

** AUCTeX

- (La)TeX-mode ::
     AUCTeX (menus =Preview=, =LaTeX=, =Command= and =Ref=; text =LaTeX/P= displayed in
     the mode line)

AUCTeX supports TeX and extensions such as LaTeX. For LaTeX, there is a
(major) =LaTeX-mode= in AUCTeX which runs (in this order):

1. =text-mode-hook=, then
2. =TeX-mode-hook=, and then
3. a hook =LaTeX-mode-hook= special to the LaTeX mode.

If you need to make a customization via a hook which is only relevant for the
LaTeX mode, put it into the =LaTeX-mode-hook=; if it is relevant for any AUCTeX
mode, add it to =TeX-mode-hook= and if it is relevant for all text modes, append
it to =text-mode-hook=.

AUCTeX defines the ~tex-mode.el~ mode names as alias of its own modes: it
aliases =(la)tex-mode= to =(La)TeX-mode=.

#+begin_src emacs-lisp
  (leuven--section "25.10 (emacs)AUCTeX Mode")

;;** 1.2 (info "(auctex)Installation") of AUCTeX

  (try-require 'tex-site)

  ;; support for LaTeX documents
  (GNUEmacs
    (with-eval-after-load "latex"
#+end_src

You can detect the *successful activation of AUCTeX*: after loading a LaTeX
file, AUCTeX gives you a =Command= menu.

- Press =C-c C-c File <RET> <RET>= to run =dvips= (note that the command is =File= and
  not =Dvips= as one might expect)

- Press =C-c C-c Print <RET> <RET>= to run =GSview= (also somewhat misleading name)

- If you want to print the document, do it from =GSview=.

#+begin_src emacs-lisp
      ;; ;; TEST ??
      ;; (add-hook 'tex-mode-hook 'imenu-add-menubar-index)

      ;; ;; LaTeX-sensitive spell checking
      ;; (add-hook 'tex-mode-hook
      ;;           (lambda ()
      ;;             (make-local-variable 'ispell-parser)
      ;;             (setq ispell-parser 'tex)))
#+end_src

#+begin_src emacs-lisp
;;** 2.6 (info "(auctex)Completion")

      (leuven--section "2.6 (auctex)Completion")

      ;; if this is non-nil when AUCTeX is loaded, the TeX escape
      ;; character `\' will be bound to `TeX-electric-macro'
      (setq TeX-electric-escape t)

;;** 2.8 (info "(auctex)Indenting")

      (leuven--section "2.8 (auctex)Indenting")

      ;; leave the `tikzpicture' code unfilled when doing `M-q'
      (add-to-list 'LaTeX-indent-environment-list '("tikzpicture"))

      ;; auto-indentation (suggested by the AUCTeX manual -- instead of
      ;; adding a local key binding to `<RET>' in the `LaTeX-mode-hook')
      (setq TeX-newline-function 'newline-and-indent)
#+end_src

#+begin_src emacs-lisp
;;* 3 Controlling Screen (info "(auctex)Display")

;;** 3.1 (info "(auctex)Font Locking")

      (leuven--section "3.1 (auctex)Font Locking")

      ;; (for Org mode) add the `comment' environment to the variable
      ;; `LaTeX-verbatim-environments' so that, if the `#+TBLFM' line
      ;; contains an odd number of dollar characters, this does not
      ;; cause problems with font-lock in LaTeX-mode
      (add-to-list 'LaTeX-verbatim-environments "comment")
#+end_src

#+begin_src emacs-lisp
;;** 4.1 Executing (info "(auctex)Commands")

      (leuven--section "4.1 Executing (auctex)Commands")

      ;; add a command to execute on the LaTeX document
      (add-to-list 'TeX-command-list
                   '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t))

      (defun leuven--LaTeX-mode-hook ()
        ;; default command to run in the LaTeX buffer
        (setq TeX-command-default
              (save-excursion
                (save-restriction
                  (widen)
                  (goto-char (point-min))
                  (let ((re (concat
                             "^\\s-*\\\\usepackage\\(?:\\[.*\\]\\)?"
                             "{.*\\<\\(?:font\\|math\\)spec\\>.*}")))
                    (save-match-data
                      (if (re-search-forward re 3000 t)
                          "XeLaTeX"
                        "LaTeX")))))))

      (add-hook 'LaTeX-mode-hook 'leuven--LaTeX-mode-hook)

      ;; use PDF mode by default (instead of DVI)
      (setq-default TeX-PDF-mode t)
#+end_src

A decent viewer reloads the PDF automatically when the file has changed while
staying on the same page (no need to close & reopen).

Support for forward search with PDF files means that the viewer jumps to the
page in the output file corresponding to the position in the source file.
Currently, this only works if you use the pdfsync LaTeX package and xpdf or
SumatraPDF as your PDF viewer.

#+begin_src emacs-lisp
;;** 4.2 (info "(auctex)Viewing") the formatted output

      (leuven--section "4.2 (auctex)Viewing the formatted output")

      (defvar sumatrapdf-command
        (concat windows-program-files-dir "SumatraPDF/SumatraPDF.exe")
        "Path to the SumatraPDF executable.")

      ;; use a saner PDF viewer (evince, SumatraPDF)
      (setcdr (assoc "^pdf$" TeX-output-view-style)
              (cond (running-ms-windows
                     `("." (concat "\"" ,sumatrapdf-command "\" %o")))
                    ;; under Windows, we could open the PDF file with
                    ;; `start "" xxx.pdf' (in a command prompt)
                    (t
                     '("." "evince %o"))))

      ;; for AUCTeX 11.86+
      (when (boundp 'TeX-view-program-list)
        (add-to-list 'TeX-view-program-list
                     `("SumatraPDF"
                       (concat "\"" ,sumatrapdf-command "\" %o"))))

      (when running-ms-windows
        (setcdr (assoc 'output-pdf TeX-view-program-selection)
                '("SumatraPDF")))
#+end_src

#+begin_src emacs-lisp
;;** 4.3 (info "(auctex)Debugging") Catching the errors

      (leuven--section "4.3 (auctex)Debugging Catching the errors")

      ;; don't show output of TeX compilation in other window
      (setq TeX-show-compilation nil)
#+end_src

#+begin_src emacs-lisp
;;** 4.7 (info "(auctex)Documentation")
#+end_src

=C-c ?= (or =M-x TeX-doc=) displays documentation for a package.

*************** TODO TeX-doc does not provide a list of available keywords for completion
Nor a default when point is on a command name...
*************** END

#+begin_src emacs-lisp
;;** 5.2 (info "(auctex)Multifile") Documents

      ;; assume that the file is a master file itself
      (setq-default TeX-master t)

;;** 5.3 Automatic (info "(auctex)Parsing Files")

      ;; enable parse on load (if no style hook is found for the file)
      (setq TeX-parse-self t)

      ;; enable automatic save of parsed style information when saving
      ;; the buffer
      (setq TeX-auto-save t)

;;** 5.5 (info "(auctex)Automatic") Customization

      ;; TODO Add beamer.el to TeX-style-path

;;*** 5.5.1 (info "(auctex)Automatic Global") Customization for the Site

      (leuven--section "5.5.1 (auctex)Automatic Global Customization for the Site")

      ;; directory containing automatically generated TeX information
      (setq TeX-auto-global
            ;; must end with a slash
            "~/.emacs.d/auctex-auto-generated-info/")

;;*** 5.5.3 (info "(auctex)Automatic Local") Customization for a Directory

      (leuven--section "5.5.3 (auctex)Automatic Local Customization for a Directory")

      ;; directory containing automatically generated TeX information
      (setq TeX-auto-local "~/.emacs.d/auctex-auto-generated-info/")
                                        ; must end with a slash
#+end_src

** Preview-LaTeX

You can detect the successful activation of =preview-latex=: after loading a
LaTeX file, =preview-latex= gives you a ~Preview~ menu.

#+begin_src emacs-lisp
;;** (info "(preview-latex)Top")

      (leuven--section "(preview-latex)Top")

      (with-eval-after-load "preview"

        ;; path to `gs' command (for format conversions)
        (setq preview-gs-command
          (cond (running-ms-windows
                 (or (executable-find "gswin32c.exe")
                     "C:/texlive/2012/tlpkg/tlgs/bin/gswin32c.exe"))
                                        ; default value
                (t
                 "/usr/bin/gs")))
        (leuven--file-exists-and-executable-p preview-gs-command)

        ;; scale factor for included previews
        (setq preview-scale-function 1.2))
#+end_src

** RefTeX

AUCTeX is fantastic, and RefTeX just makes things better.

To fill in =\ref{}= and =\cite{}= commands, you can use =C-c &=
(=reftex-view-crossref=).

A Table of Contents of the entire (multifile) document with browsing
capabilities is available with =C-c ==. Hitting =l= there will show all the
labels and cites.

Labels can be created with =C-c (= and referenced with =C-c )=. When
referencing, you get a menu with all labels of a given type and context of the
label definition. The selected label is inserted as a =\ref= macro.

Citations can be made with =C-c [= which will use a regular expression to pull
out a *formatted* list of articles from your BibTeX database. The selected
citation is inserted as a =\cite= macro.

Index entries can be made with =C-c /= which indexes the word at point or the
current selection. More general index entries are created with =C-c <=.
=C-c >= displays the compiled index.

#+begin_src emacs-lisp
      (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
                                 ;; with AUCTeX LaTeX mode

      ;; minor mode with distinct support for `\label', `\ref', `\cite'
      ;; and `\index' in LaTeX
      (with-eval-after-load "reftex"

        ;; turn all plug-ins on
        (setq reftex-plug-into-AUCTeX t)

        ;; use a separate selection buffer for each label type -- so the
        ;; menu generally comes up faster
        (setq reftex-use-multiple-selection-buffers t))
#+end_src

** BibTeX

#+begin_src emacs-lisp
      )) ;; with-eval-after-load "latex" ends here
#+end_src

#+begin_src emacs-lisp
) ;; chapter 25.10-tex-mode ends here
#+end_src

* SGML and HTML Modes

#+begin_src emacs-lisp
(leuven--chapter leuven-chapter-25-text "25 Commands for Human Languages"

;;** 25.11 (info "(emacs)HTML Mode")

  (leuven--section "25.11 (emacs)HTML Mode")
#+end_src

** HTML

*** html-mode

The default HTML mode, derived from SGML mode (see the HTML and SGML menus),
works quite well for editing HTML4 documents (whose tags don't have to close).

- =C-c C-v= ::
     *View* your file *in your browser* (=browse-url-of-buffer=).

- =C-c C-b= (or =C-c <left>=) ::
     Jump to the opening HTML tag (=sgml-skip-tag-backward=)

- =C-c C-f= (or =C-c <right>=) ::
     Jump to the closing HTML tag (=sgml-skip-tag-forward=)

- =C-c TAB= ::
     Hide all of the angle-bracketed tags in the buffer (=sgml-tags-invisible=).
     This can be used as a cheap *preview* of *just the bare text*.

- =C-c /= ::
     =sgml-close-tag=

- =C-M-i= ::
     =ispell-complete-word=

Plug [[http://tidy.sourceforge.net/][HTML Tidy]] with ~tidy.el~.

#+begin_src emacs-lisp
  (when (and (locate-library "tidy")
             (executable-find "tidy"))

    (autoload 'tidy-buffer "tidy"
      "Run Tidy HTML parser on current buffer." t)
    (autoload 'tidy-parse-config-file "tidy"
      "Parse the `tidy-config-file'." t)
    (autoload 'tidy-save-settings "tidy"
      "Save settings to `tidy-config-file'." t)
    (autoload 'tidy-build-menu  "tidy"
      "Install an options menu for HTML Tidy." t)

    (defun leuven--html-mode-hook ()
      "Customize html(-helper)-mode."

      ;; set up a "tidy" menu in the menu bar
      (when (boundp 'html-mode-map)
        (tidy-build-menu html-mode-map))
      (when (boundp 'html-helper-mode-map)
        (tidy-build-menu html-helper-mode-map))

      ;; bind the key sequence `C-c C-c' to `tidy-buffer'
      (local-set-key
        (kbd "C-c C-c") 'tidy-buffer)

      (setq sgml-validate-command "tidy"))

    ;; also run from `html-helper-mode'
    (add-hook 'html-mode-hook 'leuven--html-mode-hook))
#+end_src

*** html-helper-mode

You might also want to consider =html-helper-mode=, which has a lot more
features than plain =html-mode=:

- autocompletion,
- auto-insertion of closing tags... and
- a lot more.

When you open a buffer for HTML editing, a didactic HTML menu appears, so you
can use your mouse to invoke commands.

Using the prefix-arg (=C-u=) to relevant HTML tags, =html-helper-mode= will put
tags around a region you've specified.

#+begin_src emacs-lisp
  (when (locate-library "html-helper-mode")

    (autoload 'html-helper-mode "html-helper-mode"
      "Mode for editing HTML documents." t)

    ;; invoke html-helper-mode automatically on .html files
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . html-helper-mode))

    ;; invoke html-helper-mode automatically on .asp files
    (add-to-list 'auto-mode-alist '("\\.asp\\'" . html-helper-mode))

    ;; invoke html-helper-mode automatically on .jsp files
    (add-to-list 'auto-mode-alist '("\\.jsp\\'" . html-helper-mode)))
#+end_src

** XHTML

[[id:786a2051-476a-4277-82df-d8ebf8ba0e99][nXML]] seems to be the most recommended mode to view and edit well-formed *XHTML*
(reformulation of HTML as an XML application).

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.xhtml?\\'" . xml-mode)) ;; alias for `nxml-mode'
#+end_src

Alternatively, you can use [[http://ourcomments.org/Emacs/nXhtml/doc/nxhtml.html][nXhtml]] mode, derived from nXML mode. It adds a lot
of things useful for *XHTML* files with mixed content:

- handling *multiple major modes* (Mumamo) in one buffer (for CSS, JS, PHP and
  similar things): get the correct syntax highlighting and indentation for
  each of them,
- folding,
- improved interface to Tidy (?),
- etc.

Though, it takes a while to load.

web-mode could be another alternative for editing HTML documents embedding
CSS/JS.

** XML
   :PROPERTIES:
   :ID:       786a2051-476a-4277-82df-d8ebf8ba0e99
   :END:

nXML mode (default for editing XML files, since GNU Emacs 23.2) does:

- real-time *validation against a schema in RELAX NG* (actually RNC, i.e. the
  "Compact" Syntax): =C-c C-n= (assuming RNG validation is on),

- *code completion* against the RNG schema.

Some key bindings:

- =C-M-p= ::
     Move backward over one element (=nxml-backward-element=).

- =C-M-n= ::
     Move forward over one element (=nxml-forward-element=).

- =C-M-u= ::
     Move up the element structure (=nxml-backward-up-element=).

- =C-M-d= ::
     Move down the element structure (=nxml-down-element=).

#+begin_src emacs-lisp
  (with-eval-after-load "nxml-mode"

    ;; remove the binding of `C-c C-x' (`nxml-insert-xml-declaration'), used
    ;; by Org timeclocking commands
    (define-key nxml-mode-map
      (kbd "C-c C-x") nil)

    ;; view the buffer contents in a browser
    (define-key nxml-mode-map
      (kbd "C-c C-v") 'browse-url-of-buffer))
      ;; XXX (normally bound to `rng-validate-mode')
#+end_src

** Highlight the closing tag

#+begin_src emacs-lisp
  (when (try-require 'hl-tags-mode)

    (add-hook 'html-mode-hook
              (lambda ()
                (require 'sgml-mode)
                ;; when `html-mode-hook' is called from `html-helper-mode'
                (hl-tags-mode 1)))

    (add-hook 'nxml-mode-hook
              (lambda ()
                (hl-tags-mode 1))))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 25 ends here
#+end_src

* Editing Programs

#+begin_src emacs-lisp
;;* 26 Editing (info "(emacs)Programs")

(leuven--chapter leuven-chapter-26-programs "26 Editing Programs"
#+end_src

** Major Modes for Programming Languages

Have a look at:
- [[http://cedet.sourceforge.net][CEDET]] for development in AWK, C/C++, C#, Calc,
  Erlang, Java, Javascript, Make, PHP, Python, Ruby and Scheme,
- [[http://common-lisp.net/project/slime][SLIME]] for Common Lisp development,
- JDEE for Java programs.

Emacs tool for ELISP code analysis (to keep overview of the function calls and
dependecies between functions/variables): byte-compile-generate-call-tree

Also =who-calls.el=

#+begin_src emacs-lisp
;;** 26.1 Major Modes for (info "(emacs)Program Modes")

  (leuven--section "26.1 Major Modes for (emacs)Program Modes")
#+end_src

#+begin_src emacs-lisp
  (autoload 'graphviz-dot-mode "graphviz-dot-mode"
    "Major mode for the dot language." t)
  (add-to-list 'auto-mode-alist '("\\.dot\\'" . graphviz-dot-mode))
#+end_src

** Top-Level Definitions, or Defuns

Imenu is a great tool allowing you to go to a function definition, but only if
the definition is in the buffer you are currently editing (it won't jump and
open another file).

#+begin_src emacs-lisp
;;** 26.2 Top-Level Definitions, or (info "(emacs)Defuns")

  (leuven--section "26.2 Top-Level Definitions, or (emacs)Defuns")

  (GNUEmacs
    ;; making buffer indexes as menus (awesome!)
    (when (try-require 'imenu-XXX)
      ;; imenu-add-to-menubar: Command attempted to use minibuffer while in
      ;; minibuffer

      ;; automatically add Imenu to the menu bar in /any/ mode that supports
      ;; it
      (defun try-to-add-imenu ()
        (condition-case nil
            (imenu-add-to-menubar "Imenu")
          (error nil)))
      (add-hook 'font-lock-mode-hook 'try-to-add-imenu)

      ;; show current function in mode line (based on Imenu)
      (which-func-mode 1))) ;; ~ Stickyfunc mode (in header line)
#+end_src

** Indentation for Programs

Changing the "hanginess" of a brace and then reindenting, will not move the
brace to a different line. For this, you're better off getting an external
program like GNU =indent=, which will rearrange brace location, among other
things.

#+begin_src emacs-lisp
;;** 26.3 (info "(emacs)Program Indent")ation

    (leuven--section "26.3 (emacs)Program Indentation")

    ;; turn on auto-fill mode in Lisp modes
    (add-hook 'lisp-mode-hook 'turn-on-auto-fill)
    (add-hook 'emacs-lisp-mode-hook 'turn-on-auto-fill)

    ;; auto-indentation: automatically jump to the "correct" column when
    ;; the <RET> key is pressed while editing a program (act as if you
    ;; pressed `C-j')
    (GNUEmacs24
      (add-hook 'prog-mode-hook
                (lambda ()
                  (local-set-key
                    (kbd "<return>") 'newline-and-indent))))

    ;; (defun back-to-indentation-or-beginning ()
    ;;   (interactive)
    ;;   (if (/= (point) (line-beginning-position))
    ;;       (beginning-of-line)
    ;;     (back-to-indentation)))
    ;;
    ;; (defun align-with-spaces (beg end)
    ;;   "Align selected using only spaces for whitespace."
    ;;   (interactive "r")
    ;;   (let ((indent-tabs-mode nil))
    ;;     (align beg end)))

    (with-eval-after-load "sh-script"

      ;; use the SMIE code for navigation and indentation
      (setq sh-use-smie t))
#+end_src

** Commands for Editing with Parentheses

#+begin_src emacs-lisp
;;** 26.4 Commands for Editing with (info "(emacs)Parentheses")

  (leuven--section "26.4 Commands for Editing with (emacs)Parentheses")

  ;; jump to matching parenthesis
  (defun match-paren (arg)
    "Go to the matching parenthesis, if on a parenthesis."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
          ((looking-at "\\s\)") (forward-char 1) (backward-list 1))))

  (global-set-key
    (kbd "C-)") 'match-paren)

  ;; advanced highlighting of matching parentheses
  (if (try-require 'mic-paren)

      ;; activate `mic-paren' parenthesis highlighting (if the matching paren
      ;; is offscreen, show the matching line in the echo area + many other
      ;; useful things)
      (paren-activate)

    ;; highlight matching paren
    (GNUEmacs
      (show-paren-mode 1)
      (setq show-paren-style 'mixed)
      (setq show-paren-ring-bell-on-mismatch t))
    (XEmacs
      (paren-set-mode 'paren)))

  ;; highlight surrounding parentheses
  (GNUEmacs
    (autoload 'highlight-parentheses-mode "highlight-parentheses"
      "Minor mode to highlight the surrounding parentheses." t)

    ;; (add-hook 'emacs-lisp-mode-hook 'highlight-parentheses-mode)

    (with-eval-after-load "highlight-parentheses"

      (define-globalized-minor-mode global-highlight-parentheses-mode
        highlight-parentheses-mode
        (lambda ()
          (highlight-parentheses-mode t)))
      (global-highlight-parentheses-mode t)

      (setq hl-paren-background-colors
            '("#FF993F" "#FFF33F" "#B0FF3F" "#4BFF4B"
              "#3FFFB0" "#3FF3FF" "#3F99FF" "#3F3FFF"))

      (setq hl-paren-colors
            '("black" "black" "black" "black" "black"
              "black" "black" "white"))))
#+end_src

** Manipulating Comments

#+begin_src emacs-lisp
;;** 26.5 (info "(emacs)Comments")

  (leuven--section "26.5 (emacs)Comments")

  ;; always comments out empty lines
  (setq comment-empty-lines t)
#+end_src

** Documentation Lookup

#+begin_src emacs-lisp
;;** 26.6 (info "(emacs)Documentation") Lookup

  (leuven--section "26.6 (emacs)Documentation Lookup")

  ;; show the function arglist or the variable docstring in the echo area
  (GNUEmacs
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode))
#+end_src

** Hideshow minor mode
   :PROPERTIES:
   :ID:       a36b1dbd-1d05-4ff2-b19a-167e50c4f1f7
   :END:

TODO See http://stackoverflow.com/questions/2399612/why-is-there-no-code-folding-in-emacs

You can have block-oriented *folding* in programming modes: Hideshow
distinguishes end-of-block.

~hs-minor-mode.el~ collapses code for a lot of languages, not only Lisp. See
[[id:42ad895e-c049-4710-a877-5014a7f6acfc][outline-minor-mode]] as well.

#+begin_src emacs-lisp
;;** 26.7 (info "(emacs)Hideshow") minor mode

  (leuven--section "26.7 (emacs)Hideshow minor mode")

  ;; enable hideshow for programming modes
  (add-hook 'prog-mode-hook
            (lambda ()
              (hs-minor-mode 1)))

  ;; Especially after changing a couple of those really awkward
  ;; key bindings with `@' in the middle.
  ;; Changing: C-c @ c-s  to C-c s  (hs-show-block)
  ;;           C-c @ c-h  to C-c h  (hs-hide-block)
  ;; Seems not to collide with anything when in cperl-mode at least.

  ;; (define-key hs-minor-mode-map
  ;;   [?\C-c ?\C-\M-h] 'hs-hide-all)
  ;; (define-key hs-minor-mode-map
  ;;   [?\C-c ?\C-\M-s] 'hs-show-all)

  ;; (global-set-key (kbd "C-c @ @") 'hs-hide-all)
  ;; (global-set-key (kbd "C-c @ @") 'hs-show-all)
  (global-set-key
    (kbd "C-c @ h") 'hs-hide-block)
  (global-set-key
    (kbd "C-c @ s") 'hs-show-block)
#+end_src

#+begin_src emacs-lisp
  ;; if hideshowvis is not installed, do not attempt to configure it,
  ;; as this will prevent packages (including hideshowvis itself)
  ;; from compiling
  (when (and (display-graphic-p)
             (try-require 'hideshowvis-XXX))

    (autoload 'hideshowvis-enable "hideshowvis"
      "Highlight foldable regions." t)

    (autoload 'hideshowvis-minor-mode "hideshowvis"
      "Will indicate regions foldable with hideshow in the fringe." t)

    ;; enable hideshowvis for programming modes
    (add-hook 'prog-mode-hook
              (lambda ()
                ;; more syntax definitions
                (require 'fold-dwim)
                (hideshowvis-enable)))

    ;; +/- fold buttons
    (define-fringe-bitmap 'hs-marker [0 24 24 126 126 24 24 0])

    (defcustom hs-fringe-face 'hs-fringe-face
      "*Specify face used to highlight the fringe on hidden regions."
      :type 'face
      :group 'hideshow)

    (defface hs-fringe-face
      '((t (:box (:line-width 2 :color "#808080" :style released-button)
            :foreground "#999999")))
      "Face used to highlight the fringe on folded regions"
      :group 'hideshow)

    (defcustom hs-face 'hs-face
      "*Specify the face to to use for the hidden region indicator"
      :type 'face
      :group 'hideshow)

    (defface hs-face
      '((t (:box (:line-width 1 :color "#999999")
            :foreground "#999999" :background "#FFF8C0")))
      "Face to hightlight the ... area of hidden regions"
      :group 'hideshow)

    (defun display-code-line-counts (ov)
      (when (eq 'code (overlay-get ov 'hs))
        (let* ((marker-string "*fringe-dummy*")
               (marker-length (length marker-string))
               (display-string
                ;; (format "(%d)..."
                ;; (count-lines (overlay-start ov) (overlay-end ov)))
                "..."))
          (overlay-put ov 'help-echo "Hidden text. C-c,= to show")
          (put-text-property 0 marker-length
                             'display (list 'left-fringe
                                            'hs-marker
                                            'hs-fringe-face)
                             marker-string)
          (overlay-put ov 'before-string marker-string)
          (put-text-property 0 (length display-string)
                             'face 'hs-face display-string)
          (overlay-put ov 'display display-string))))

    (setq hs-set-up-overlay 'display-code-line-counts))
#+end_src

** Completion for Symbol Names
   :PROPERTIES:
   :ID:       4b262301-5370-40c6-8da6-019215634e20
   :END:

#+begin_src emacs-lisp
;;** 26.8 (info "(emacs)Symbol Completion")

  (leuven--section "26.8 (emacs)Symbol Completion")
#+end_src

It's more or less a convention that each language mode binds its symbol
completion command (=completion-at-point=) to =<M-tab>=.

Note that =<M-tab>= is used by many window managers themselves (typically for
switching between windows) and is not passed to applications.

In that case, you should:

- type =C-M-i= (or =<escape> <tab>=) for completion, or

- bind the command normally bound to =<M-tab>= to a key that is convenient for
  you to hit, such as =<C-tab>=.

#+begin_src emacs-lisp
  ;; when you hit `<C-tab>', call the command normally bound to `<M-tab>'
  (global-set-key
    (kbd "<C-tab>")
    (lambda ()
      (interactive)
      (call-interactively (key-binding (kbd "<M-tab>")))))
#+end_src

See also [[id:0fa23e4a-e42c-4317-834c-d2ef7c9d741c][Dabbrev]], Emacs' standard autocompletion (on by default).

** Glasses minor mode

#+begin_src emacs-lisp
;;** 26.9 (info "(emacs)Glasses") minor mode

  (leuven--section "26.9 (emacs)Glasses minor mode")

  (with-eval-after-load "glasses"

    ;; face to be put on capitals of an identifier looked through glasses
    (setq glasses-face 'bold)

    ;; string to be displayed as a visual separator in unreadable
    ;; identifiers
    (setq glasses-separator ""))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 26 ends here
#+end_src

* Compiling and Testing Programs

It is possible to see a warning, while we are programming, if we did a
mistake: there's a CWarn mode for C and C++, but I don't know about similar
features for Java.

flymake can compile in the background and colorize lines with errors/warnings
- http://flymake.sourceforge.net/
- http://www.emacswiki.org/cgi-bin/wiki/JdeeFlymake

#+begin_src emacs-lisp
;;* 27 (info "(emacs)Building") Compiling and Testing Programs

(leuven--chapter leuven-chapter-27-building "27 Compiling and Testing Programs"

  (autoload 'flymake-mode "flymake"
    "Toggle on-the-fly syntax checking." t)

  (with-eval-after-load "flymake"

    ;; set up `flymake'
    (defun activate-flymake ()
      "Activate Flymake when real buffer and you have write access."
      (when (and (buffer-file-name)
                 (file-writable-p buffer-file-name))
        (flymake-mode t)))

    ;; XXX add errors to mode line
    (defun leuven--flymake-show-help ()
      "Display the error output of the current line in the mode line."
      (when (get-char-property (point) 'flymake-overlay)
        (let ((help (get-char-property (point) 'help-echo)))
          (if help (message "%s" help)))))

    (add-hook 'post-command-hook 'leuven--flymake-show-help))
#+end_src

** Running Compilations under Emacs

My build command: =cd /path/to/Makefile && make -f Makefile=.

You don't need a =Makefile= to perform simple tasks, because =make= knows a lot of
built in rules out of the box. For example, to compile a =.c= source file =foo.c=
into a program =foo=, all you need is say =make -k foo=, and =make= will do it even
without a =Makefile=.

#+begin_src emacs-lisp
;;** 27.1 Running (info "(emacs)Compilation")s under Emacs

  (leuven--section "27.1 Running (emacs)Compilations under Emacs")

  ;; http://www.emacswiki.org/emacs-en/eproject allows to define projects, and
  ;; in each project to define menu commands and shortcut keys as you like.
  ;; For example:
  ;;
  ;; make (f9)               : `-in src make' OR `make'
  ;; clean (C-f9)            : `rm -vf src/emacs-23.* etc/DOC* && make clean' OR `make clean'
  ;; run (f8)                : `src/emacs' OR `./my-program'
  ;; stop (C-f8)             : `-e kill-compilation'
  ;; ---
  ;; configure               : `./configure'
  ;; install                 : `echo root-pass | sudo -S make install'


  ;; invoke a compiler with the same command as in the last invocation of
  ;; `compile'
  (autoload 'recompile "compile"
    "Re-compile the program including the current buffer." t)
  (global-set-key
    (kbd "<f9>") 'recompile)

  ;; scroll the `*compilation*' buffer window to follow output as it
  ;; appears
  (setq compilation-scroll-output t)

  ;; number of lines in a compilation window
  (setq compilation-window-height (* 2 5))

  ;; ;; I also don't like that the compilation window sticks around after
  ;; ;; a successful compile. After all, most of the time, all I care
  ;; ;; about is that the compile completed cleanly. Here's how I make the
  ;; ;; compilation window go away, only if there was no compilation
  ;; ;; errors:
  ;; (setq compilation-finish-function
  ;;       (lambda (buf str)
  ;;         (if (string-match "exited abnormally" str)
  ;;             ;; there were errors
  ;;             (message "Compilation errors, press C-x ` to visit")
  ;;           ;; no errors, make compilation window go away in 0.5 sec
  ;;           (run-at-time 0.5 nil 'delete-windows-on buf)
  ;;           (message "NO COMPILATION ERRORS!"))))


  (GNUEmacs
    (defun cc-goto-first-error( buffer exit-condition )
      (with-current-buffer buffer
        (goto-char (point-min))
        (compilation-next-error 1)
        (beep)))

    (add-to-list 'compilation-finish-functions 'cc-goto-first-error))


  (defvar make-clean-command "make clean all"
    "*Command used by the `make-clean' function.")

  (defun make-clean (&optional arg)
    "Run a make clean."
    (interactive "P")
    (require 'compile) ;; needed for compile-internal
    (if arg
        (setq make-clean-command
              (read-string "Command: " make-clean-command)))
    (save-some-buffers (not compilation-ask-about-save) nil)
    (compile-internal make-clean-command "No more errors"))

  (global-set-key
    (kbd "<S-f9>") 'make-clean)
#+end_src

** Compilation Mode

#+begin_src emacs-lisp
;;** 27.2 (info "(emacs)Compilation Mode")

  (leuven--section "27.2 (emacs)Compilation Mode")

  ;; automatically jump to the first error during compilation
  (setq compilation-auto-jump-to-first-error t)

  ;; display the next compiler error message
  (global-set-key
    (kbd "<f10>") 'next-error)

  ;; display the previous compiler error message
  (global-set-key
    (kbd "<S-f10>") 'previous-error)

  ;; display the first compiler error message
  (global-set-key
    (kbd "<C-f10>") 'first-error)

  ;; highlight and parse the whole compilation output as soon as it
  ;; arrives
  (setq compile-auto-highlight t)
#+end_src

** Searching with Grep under Emacs

Find files matching some regexp, and click on the hyperlinks to the files to
locate your match.

The commands
- =lgrep= (local search, with =grep-template=) and
- =rgrep= (*recursive* search, with =grep-find-template=)
are somehow more user-friendly than the =M-x grep= command.

#+begin_src emacs-lisp
;;** 27.4 (info "(emacs)Grep Searching") under Emacs

  (leuven--section "27.4 (emacs)Grep Searching under Emacs")

  ;; ignore case distinctions in the default `grep' command
  (setq grep-command "grep -i -H -n -e ")

  ;; do not append `null-device' (`/dev/null' or `NUL') to `grep' commands
  (setq grep-use-null-device nil)
  ;; not necessary if the `grep' program used supports the `-H' option

  ;; ;; for Windows
  ;; (setq grep-find-command '("findstr /sn *" . 13))

  ;; use `find -print0' and `xargs -0'
  (setq grep-find-use-xargs 'gnu)

  ;; run `grep' via `find', with user-friendly interface
  (global-set-key
    (kbd "C-c 3") 'rgrep)
#+end_src

#+begin_src emacs-lisp
  ;; 10.3.5 Org keyword search
  (defun leuven-org-grep (regexp &optional context)
    "Recursively search for REGEXP in Org files in directory tree rooted at `org-directory'.

  Prefix argument determines number of lines of output context."
    (interactive "sSearch regexp: \nP")
    (let ((grep-find-ignored-files '("#*" ".#*"))
          (grep-template (concat "grep <X> -i -nH "
                                 (when context
                                   (concat "-C" (number-to-string context)))
                                 " -e <R> <F>")))
      (rgrep regexp "*.org" org-directory)))
#+end_src

** Running Debuggers Under Emacs

#+begin_src emacs-lisp
;;** 27.6 Running (info "(emacs)Debuggers") Under Emacs

  (leuven--section "27.6 Running (emacs)Debuggers Under Emacs")

  (with-eval-after-load "gdb-mi"

    ;; enable Gdb-Many-Windows mode
    (setq gdb-many-windows t))
    ;; the only important parameter for GDB
#+end_src

*** Debugging Mercury programs                                       :noexport:

1. Put these lines in your ~.emacs~ file:

   #+begin_src emacs-lisp :tangle no
   (setq mercury-dir (file-name-as-directory (getenv "MERCURY_DIR")))
   (load-file (concat mercury-dir "/lib/mercury/elisp/gud.el"))
   (setq mdb-command-name
         "bash.exe mdb ./mas_server.exe -c ../online/mas_server/mas_config_local.xml -d ../data")
   #+end_src

2. To start the debugger, open a file in your build directory, e.g.
   ~build/Makefile~.

3. Run =M-x mdb=.

4. At the prompt, you should see the command from the ~.emacs~ file
   (=mdb-command-name=). Change if necessary and hit the =<RET>= key.

5. Find your bugs.

** Debugging Lisp programs

Emacs has the basic debugger/stack trace, but it also has the Edebug facility,
which is very powerful, for the more complex situation.

With that source-level debugger for Emacs Lisp, you can:
- step through evaluation, stopping before and after each expression,
- set conditional or unconditional breakpoints.

#+begin_src emacs-lisp
;;** Debugging Lisp programs

  ;; source-level debugger for Emacs Lisp
  (with-eval-after-load "edebug"

    (defadvice edebug-overlay-arrow (around leuven-highlight-line activate)
      "Highlight line currently being Edebug'ged."
      (require 'hl-line)
      (hl-line-mode)
      ad-do-it)

    (defun leuven-edebug-quit ()
      "Stop Edebug'ging and remove highlighting."
      (interactive)
      (hl-line-mode -1)
      (top-level))

    (define-key edebug-mode-map
      [remap top-level] 'leuven-edebug-quit))
#+end_src

** Executing Lisp Expressions

Just as in C, C++, Java, Perl, Python, etc, Lisp code is kept in files. All
the normal editing operations are performed on files. In this respect, hacking
in Lisp is like hacking in any other language that you are used to. What's
different is that what you are hacking is a running Lisp program. When you
edit a function definition or add a new one, you compile it into a running
program. There is no compile, link, run, debug cycle as you know it from C or
Java.

Ponder that for a minute.

When you fix a bug in a C function, you have to recompile, relink, and reload
your program before you can test the fix. You don't do that in Lisp. You make
the fix and then go straight to testing it. This process can be even faster
than fixing a bug in a scripting language like Perl.

** Evaluating Emacs Lisp Expressions

To (attempt to) cleanly reevaluate a buffer of elisp code, use =nuke-and-eval=.

#+begin_src emacs-lisp
;;** 27.9 (info "(emacs)Lisp Eval") Expressions

  (leuven--section "27.9 (emacs)Lisp Eval Expressions")

  ;; enable the use of the command `eval-expression' without confirmation
  (put 'eval-expression 'disabled nil)

  ;; maximum depth of lists to print in the result of the evaluation
  ;; commands before abbreviating them
  (setq eval-expression-print-level nil) ;; no limit

  ;; maximum length of lists to print in the result of the evaluation
  ;; commands before abbreviating them
  (setq eval-expression-print-length nil) ;; no limit
#+end_src

** Lisp Interaction Buffers

#+begin_src emacs-lisp
;;** 27.10 Lisp Interaction Buffers

  (leuven--section "27.10 (emacs)Lisp Interaction Buffers")

  ;; inhibit the initial startup message in the `*scratch*' buffer
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
#+end_src

Don't use any specific mode for the initial buffer. That ensure that no Lisp
or Org specific stuff gets loaded at each startup time.

#+begin_src emacs-lisp
  ;; major mode command symbol to use for the initial `*scratch*' buffer
  (setq initial-major-mode 'fundamental-mode)
#+end_src

*That code must be used in the ~.emacs~ file (or libraries loaded from it).*
Otherwise, =*scratch*= will already have been created, in the default major
mode.

To evaluate a non-interactive command, simply use =IELM=.

** Other

#+begin_src emacs-lisp
  ;;;_ * eldoc

  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (require 'edebug)))
#+end_src

#+begin_src emacs-lisp
  ;;;_ * elint

  (defun elint-current-buffer ()
    (interactive)
    (elint-initialize)
    (elint-current-buffer))

  (with-eval-after-load "elint"
    (add-to-list 'elint-standard-variables 'current-prefix-arg)
    (add-to-list 'elint-standard-variables 'command-line-args-left)
    (add-to-list 'elint-standard-variables 'buffer-file-coding-system)
    (add-to-list 'elint-standard-variables 'emacs-major-version)
    (add-to-list 'elint-standard-variables 'window-system))
#+end_src

#+begin_src emacs-lisp
  ;;;_ * emacs-lisp

  (add-hook 'emacs-lisp-mode-hook 'turn-on-auto-fill)

  ;; (defun elisp-indent-or-complete (&optional arg)
  ;;   (interactive "p")
  ;;   (call-interactively 'lisp-indent-line)
  ;;   (unless (or (looking-back "^\\s-*")
  ;;          (bolp)
  ;;          (not (looking-back "[-[:alnum:]_*+/=<>!?]+")))
  ;;     (call-interactively 'lisp-complete-symbol)))
  ;;
  ;; (with-eval-after-load "lisp-mode"
  ;;   (define-key emacs-lisp-mode-map
  ;;     (kbd "<tab>") 'elisp-indent-or-complete))
#+end_src

#+begin_src emacs-lisp
  ;;;_  + paredit

  (autoload 'paredit-mode "paredit"
    "Minor mode for pseudo-structurally editing Lisp code." t)
  (autoload 'enable-paredit-mode "paredit"
    "Minor mode for pseudo-structurally editing Lisp code." t)

  ;;;;;;;;;;;;;;(add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
#+end_src

#+begin_src emacs-lisp
  ;;;_  + redshank

  (when (locate-library "redshank")
      (autoload 'redshank-mode "redshank"
        "Minor mode for restructuring Lisp code (i.e., refactoring)." t)

      (add-hook 'emacs-lisp-mode-hook
                (lambda ()
                  (redshank-mode 1))))

  ;; lang-emacs-lisp.el ends here
#+end_src

** TODO From Thierry Volpiatto

Seems good, except that it changes the behavior of TAB when done in a word.
Instead of indenting, it completes the word at point, changing the buffer's
contents!

#+begin_src emacs-lisp :tangle no
  ;; Lisp complete or indent
  (define-key lisp-interaction-mode-map
    [remap indent-for-tab-command] 'helm-lisp-completion-at-point-or-indent)
  (define-key emacs-lisp-mode-map
    [remap indent-for-tab-command] 'helm-lisp-completion-at-point-or-indent)

  ;; Lisp complete
  (define-key lisp-interaction-mode-map
    [remap completion-at-point] 'helm-lisp-completion-at-point)
  (define-key emacs-lisp-mode-map
    [remap completion-at-point] 'helm-lisp-completion-at-point)
#+end_src

#+begin_src emacs-lisp
) ;; chapter 27 ends here
#+end_src

* Maintaining Programs

#+begin_src emacs-lisp
;;* 28 (info "(emacs)Maintaining") Programs

(leuven--chapter leuven-chapter-28-maintaining "28 Maintaining Programs"
#+end_src

** Version Control

Version control systems that interact with Emacs in a generic way.

- =C-x v d= ::
     open dired buffer in VC-mode

- =C-x v v= ::
     take appropriate action (add, commit)

#+begin_src emacs-lisp
;;** 28.1 (info "(emacs)Version Control")

  (leuven--section "28.1 (emacs)Version Control")

  ;; (try-require 'vc) ;; for defining function `vc-switches' (XXX autoload?)
#+end_src

*** Version Control and the Mode Line

"Unmodified-according-to-VC" buffers use =-= as a separator in their VC
indicator, and modified buffers have =:= (e.g., =CVS-1.2= vs. =CVS:1.2=). The
tooltip over the VC indicator also says more explicitly.

#+begin_src emacs-lisp
;;*** 28.1.2 (info "(emacs)VC Mode Line")

  (leuven--section "28.1.2 Version Control and the Mode Line")

  (with-eval-after-load "vc"

    (GNUEmacs
      (when (image-type-available-p 'png)
        ;; http://www.emacswiki.org/emacs/VcIcon
        (defun vc-icon ()
          "Display a colored icon indicating the vc status of the current file."
          (let ((icon (if (vc-workfile-unchanged-p (buffer-file-name))
                          (concat leuven--directory
                                  "Pictures/NormalIcon.png")
                        (concat leuven--directory
                                "Pictures/ModifiedIcon.png")))
                (bg-colour (face-attribute 'mode-line :background)))
            (propertize
             "  "
             'display (find-image `((:type png
                                     :file ,icon
                                     :ascent center
                                     :background ,bg-colour))))))

        (setq-default mode-line-format
                      (push '(vc-mode (:eval (vc-icon))) mode-line-format)))))
#+end_src

If you choose a JPG icon, you must set its type to =jpeg= (*NOT* =jpg=) in
=find-image=.

But don't forget that JPEG images can't have /transparent backgrounds/...

If PNG images are not correctly supported, see [[id:9432da83-fa9d-4466-a4da-57f33d662bbd][Images]].

*************** Lisp expression in mode-line-format
The Lisp expressions supported in =mode-line-format= are those documented in the
manual, and nothing else. In particular, the =:eval= part must appear
explicitly, and any symbol stands for its value (which is not eval'ed). IOW, a
full-blown Lisp evaluation there is not implemented...
*************** END

*** Features of the Log Entry Buffer

Show the diff we are about to commit: =C-c C-d=.

#+begin_src emacs-lisp
;;*** 28.1.4 (info "(emacs)Log Buffer")

  (defun leuven--vc-log-mode-setup ()
    ;; check if `ispell-program-name' seems correct
    (when (ispell-check-program-name)
      (setq ispell-local-dictionary "american")
      (flyspell-mode)))

  (add-hook 'vc-log-mode-hook 'leuven--vc-log-mode-setup)
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load "vc-git"

    ;; major mode for editing git commit messages
    (when (try-require 'git-commit)

      ;; turn on on-the-fly spell-checking
      (add-hook 'git-commit-mode-hook 'turn-on-flyspell)

      ;; turn off save-place
      (add-hook 'git-commit-mode-hook
                (lambda ()
                  (toggle-save-place 0)))))
#+end_src

*** Examining And Comparing Old Revisions

#+begin_src emacs-lisp
;;*** 28.1.6 (info "(emacs)Old Revisions")

  (leuven--section "28.1.6 Examining And Comparing Old Revisions")

  ;; switches for diff under VC
  (setq vc-diff-switches diff-switches)
#+end_src

*** VC Directory Mode

#+begin_src emacs-lisp
;;*** 28.1.9 (info "(emacs)VC Directory Mode")

  (leuven--section "28.1.9 VC Directory Mode")

  (defun leuven-vc-jump ()
    "Jump to VC status buffer."
    (interactive)
    (let* ((fname (buffer-file-name))
           (dname (if fname
                      (if (file-directory-p fname)
                          fname
                        (file-name-directory fname))
                    default-directory)))
      (message "VC status for directory: %s" dname)
      (vc-dir dname)))

  ;; vc status without asking for a directory
  (global-set-key
    (kbd "<C-f9>") 'leuven-vc-jump)

  ;; hide up-to-date and unregistered files
  (add-hook  'vc-dir-mode-hook
             (lambda ()
               (define-key vc-dir-mode-map
                 (kbd "x") 'leuven-vc-dir-hide-up-to-date-and-unregistered)
               (define-key vc-dir-mode-map
                 (kbd "E") 'vc-ediff)
               (define-key vc-dir-mode-map
                 (kbd "#") 'vc-ediff-ignore-whitespace) ;; ediff-windows-wordwise?
               ))

  (defun leuven-vc-dir-hide-up-to-date-and-unregistered ()
    (interactive)
    (vc-dir-hide-up-to-date)
    (vc-dir-hide-unregistered))

  (defun vc-dir-hide-unregistered ()
    "Hide unregistered items from display."
    (interactive)
    (let ((crt (ewoc-nth vc-ewoc -1))
          (first (ewoc-nth vc-ewoc 0)))
      ;; go over from the last item to the first and remove the
      ;; unregistered files and directories with no child files
      (while (not (eq crt first))
        (let* ((data (ewoc-data crt))
               (dir (vc-dir-fileinfo->directory data))
               (next (ewoc-next vc-ewoc crt))
               (prev (ewoc-prev vc-ewoc crt))
               ;; ewoc-delete does not work without this...
               (inhibit-read-only t))
          (when (or
                 ;; remove directories with no child files
                 (and dir
                      (or
                       ;; nothing follows this directory
                       (not next)
                       ;; next item is a directory
                       (vc-dir-fileinfo->directory (ewoc-data next))))
                 ;; remove files in the unregistered state
                 (eq (vc-dir-fileinfo->state data) 'unregistered))
            (ewoc-delete vc-ewoc crt))
          (setq crt prev)))))

  (defun vc-ediff-ignore-whitespace (historic &optional not-urgent)
    "Ignore regions that differ in white space & line breaks only."
    (interactive (list current-prefix-arg t))
    (require 'ediff)
    (let ((ediff-ignore-similar-regions t))
      (call-interactively 'vc-ediff))) ;; XXX does not work yet
#+end_src

*** Customizing VC

#+begin_src emacs-lisp
;;*** 28.1.12 (info "(emacs)Customizing VC")

  (leuven--section "28.1.12 Customizing VC")

  ;; ;; display run messages from back-end commands
  ;; (setq vc-command-messages t)          ; [default: nil]

  ;; http://www.emacswiki.org/emacs/VcTopDirectory
  ;; For git
  (defadvice vc-dir-prepare-status-buffer
             (before leuven-vcs-goto-top-directory activate compile)
    (let* ((backend (ad-get-arg 2))
           (vcs-dir (ad-get-arg 1))
           (vcs-top-dir (vc-call-backend backend 'responsible-p vcs-dir)))
      (when (stringp vcs-top-dir)
        (ad-set-arg 1 vcs-top-dir))))

  (GNUEmacs
    (defun leuven--ediff-revision (file rev1 &optional rev2)
      "Run Ediff by comparing 'master' against the 'current'."
      (require 'ediff)
      (find-file file)
      (if (and (buffer-modified-p)
               (y-or-n-p (format "Buffer %s is modified. Save buffer? "
                                 (buffer-name))))
          (save-buffer (current-buffer)))
      (ediff-load-version-control)
      (funcall
       (intern (format "ediff-%S-internal" ediff-version-control-package))
       rev1 rev2 nil))

    (defun leuven-vc-diff (&optional arg)
      (interactive "P")
      (call-interactively
       (cond (arg
              (lambda ()
                (interactive)
                (vc-diff nil)))
             (t
              (lambda ()
                (interactive)
                (leuven--ediff-revision (buffer-file-name)
                                        (read-string "revision? "
                                                     "HEAD" nil "HEAD")
                                        ""))))))

    (define-key vc-prefix-map
      (kbd "=") 'leuven-vc-diff))
#+end_src

** Change Logs

#+begin_src emacs-lisp
;;** 28.2 (info "(emacs)Change Log")

  (leuven--section "28.2 (emacs)Change Logs")

  (with-eval-after-load "add-log"

    ;; don't make a new entry, when the last entry was made by you and on
    ;; the same date
    (setq add-log-always-start-new-record nil)

    ;; adds the file's version number to the change log entry
    (setq change-log-version-info-enabled t)

    (add-hook 'change-log-mode-hook
              (add-to-list
               'change-log-font-lock-keywords
               '("^[0-9-]+:? +\\|^\\(Sun\\|Mon\\|Tue\\|Wed\\|Thu\\|Fri\\|Sat\\) [A-z][a-z][a-z] [0-9:+ ]+"
                 (0 'change-log-date-face)
                 ("\\([^<(]+?\\)[   ]*[(<]\\([[:alnum:]_.+-]+@[[:alnum:]_.-]+\\)[>)]" nil nil
                  (1 'change-log-name)
                  (2 'change-log-email))))))
#+end_src

** Tags Tables

Using tags tables is the most generic approach to setup code navigation. A
"tag" signifies a language object for which an index entry is available.

Once you've built a ~TAGS~ file (=ctags=/=etags=), you can find all commands that
match a regexp.

Support for tags has been in Emacs for a long time: any installation of Emacs
should comes with the =etags= program, which supports many different languages.

Comparison of tools:

- etags (Emacs-style TAGS file) ::
     Ada, Asm, C, Objective C, C++, C#, Cobol, Erlang, Forth, Fortran, HTML,
     Java, Lisp, Lua, Makefile, Pascal, Perl, PHP, Postscript, Prolog, Python,
     Scheme, TeX, TeXinfo, and YACC.

     On Windows, Emacs comes with =etags= and a similar executable file called
     =ctags=. In the Emacs distribution, =etags.exe= = =ctags.exe= in the =bin=
     directory.

- Exuberant Ctags ::
     Ant, Asm, Asp, Awk, Basic, BETA, C, C++, C#, Cobol, DosBatch, Eiffel,
     Erlang, Flex, Fortran, HTML, Java, JavaScript, Lisp, Lua, Makefile,
     MatLab, OCaml, Pascal, Perl, PHP, Python, REXX, Ruby, Scheme, Sh, SLang,
     SML, SQL, Tcl, TeX, Vera, Verilog, VHDL, Vim, and YACC.

     You should download *Exuberant Ctags* from http://ctags.sourceforge.net/ or
     from Cygwin. Only *Exuberant* =ctags.exe= recognizes =-e= option (/etags mode/,
     which will create a tag file for use with the Emacs editor).

     Exuberant Ctags can be extended to look for other things via regular
     expression. It is a wonderful thing!

     For example, I can now look for tags in my shell code to by running:

     #+begin_src sh :tangle no
     etags --langdef=shell --regex-shell='/function [_[:alnum:]]+/[_[:alnum:]]+/' --language-force=shell
     #+end_src

- Cscope ::
     C, but flexible enough to support C++ and Java, and to be used as a
     generalized "grep database".

- ebrowse ::
     For C++, you will be better off with ebrowse, a program that also comes
     with Emacs. It understands C++ much better than etags does, and provides
     similar commands (so you don't lose anything). Check out the Ebrowse
     manual, which is part of the Emacs distribution, for details.

- GNU Idutils ::

- GNU Global (gtags) ::
     C, C++, Yacc, Java, and PHP4.

     Global is a lot smarter about finding tags tables, and is fairly fast to
     update.

*Emacs TAGS* and *Exuberant Ctags* don't do fancy stuff, e.g. keeping an index of
function references. They record only positions where a function (or variable
etc.) is *defined*.

Recording positions where a function is *called* (finding all *symbol references*)
is the kind of thing external tools such as *GNU Global*, *GNU Idutils* and *Cscope*
can do for you, if you're working with a language that they support. *Grep*
would be the fallback method.

Please also see [[http://hub.opensolaris.org/bin/view/Project+opengrok/][Comparison with Similar Tools]].

Once you have a good tagging system in place, many tools become enabled for
your language, such as:
- tag decoration mode (like drawing lines over the top of function tags),
- stickyfunc mode (which shows the current function in the header line),
- [[id:5032bcdb-ac6b-4101-a0ce-28192fb7e247][Emacs Code Browser]], and
- tag jumping.

#+begin_src emacs-lisp
;;** 28.3 (info "(emacs)Tags")

  (leuven--section "28.3 (emacs)Tags Tables")
#+end_src

*** Creating Tags Tables

First of all, you must build a ~TAGS~ file (which keeps the symbols from your
project, by scanning all the source and header files with the =etags= command).

For example, you can have a ~TAGS~ Makefile target to do this for you:

#+begin_example
TAGS:
	rm -f TAGS
	find $$(pwd) \( -name \*.el \
                     -o -name \*.[chCH] \
                     \) -print | /usr/bin/ctags -e -
#+end_example

You can create a ~TAGS~ file by using =M-x compile <RET> tags <RET>=.

Alternatively,

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "etags"

    ;; tags enhancements
    (try-require 'sure-tags))
#+end_src

will make sure that ~TAGS~ file exists (and builds it if it doesn't), allowing
you to

- first rebuild the ~TAGS~ file or
- specify a new one

when the search fails.

*** Selecting a Tags Table

After this, you can select the tag file to use with the command
=M-x visit-tags-table <RET>=.

#+begin_src emacs-lisp
  ;; list of file names of tags tables to search
  (setq tags-table-list
        '(
          "~/TAGS"
          "/usr/local/lib/emacs/src/TAGS"
          ;; "/usr/share/texmf-texlive/tex/latex/TAGS"
          ))
#+end_src

*** Finding a Tag

You can search for the *first definition* of a tag (matching your regexp) by
using =M-x find-tag= (bound to =M-.=). The default tag is the identifier under the
cursor.

To continue searching for *next definition*, use =C-u M-.=.

#+begin_src emacs-lisp
  (defun find-next-tag ()
    (interactive)
    (find-tag nil t))
#+end_src

Use =M-*= (=M-x pop-tag-mark=) to *jump back* to where you last invoked =M-.=.

*** Select from multiple TAGS files

You can search for *occurrences* of tags that match you regexp on all files in
the TAGS table, by using =M-x tags-search <RET>=.

To continue searching for next match, use =M-,=.

#+begin_src emacs-lisp
  (with-eval-after-load "etags"

    ;; select from multiple tags
    (when (try-require 'etags-select)

      ;; do a `find-tag-at-point', and display all exact matches
      (global-set-key
        (kbd "M-?") 'etags-select-find-tag-at-point)))
#+end_src

*** Find Emacs Lisp symbol definition

Find the definition of the Emacs Lisp symbol near point:

- =C-x F= ::
     find *function*

- =C-x V= ::
     find *variable*

- =C-x K= ::
     find function *bound to key* sequence

Use =C-x 4= for displaying in another window, and =C-x 5= for displaying in
another frame.

#+begin_src emacs-lisp
  ;; find the definition of the Emacs Lisp function or variable near point
  (GNUEmacs
    (find-function-setup-keys))
#+end_src

** Emacs Development Environment

*** Collection of Emacs Development Environment Tools

#+begin_src emacs-lisp
;;** 28.4 (info "(emacs)EDE")

  (leuven--section "28.4 Emacs Development Environment")
#+end_src

CEDET (integrated into Emacs 23.2) brings improvements over a plain TAGS file.
It provides:

- [[http://www.gnu.org/software/emacs/manual/semantic.html][Semantic]] ::
     a *parser* and code analyzer which provides *smart completion*
     ("Intellisense")

- EDE ::
     a *project management* system which can *generate Makefiles* to compile your
     code for you

- SRecode ::
     a template / *code generation* system which can convert tags from semantic
     back into code

- COGRE (COnnected GRaph Editor) ::
     a *UML diagram editor* which can generate code from a class diagram that
     you draw in Emacs.

See [[http://cedet.sourceforge.net/languagesupport.shtml][supported languages]].

The commands to display *symbol references* are:

- =C-c , g= ::
     =semantic-symref-symbol= and

- =C-c , G= ::
     =semantic-symref= (current tag).

#+begin_src emacs-lisp
  (unless (string< emacs-version "23.2")
    ;; ;; enable global EDE (project management) features
    ;; (global-ede-mode 1)

    (setq semantic-default-submodes
          '(
            ;; turn Semantic DB mode on (Semantic parsers store the
            ;; results of parsing source code in a database file, which can
            ;; be saved for future Emacs sessions)
            global-semanticdb-minor-mode

            ;; the idle scheduler with automatically reparse buffers in idle
            ;; time
            global-semantic-idle-scheduler-mode ;; [minimum-features]

            ;; display a summary of the symbol at point in the echo area
            ;; (~ ElDoc)
            global-semantic-idle-summary-mode ;; [code-helpers]

            ;; display a tooltip with a list of possible completions near
            ;; the cursor
            global-semantic-idle-completions-mode ;; [gaudy-code-helpers]

            ;; turn Semantic MRU Bookmarks on (keep track of the Most
            ;; Recently Used tags)
            global-semantic-mru-bookmark-mode

            ;; enable Semantic-Stickyfunc mode (display a header line that
            ;; shows the declaration line of the function or tag)
            global-semantic-stickyfunc-mode ;; [gaudy-code-helpers]

            ;; enable Semantic-Highlight-Func mode
            global-semantic-highlight-func-mode ;; [excessive-code-helpers]

            ;; turn on all active decorations
            global-semantic-decoration-mode ;; [gaudy-code-helpers]
            ))

    ;; XXX if prog-mode, then Semantic will be launched after Emacs init, as
    ;; the scratch buffer is in Emacs Lisp...
    (add-hook 'java-mode-hook
              (lambda ()
                ;; enable parser features (Semantic mode) and install a
                ;; `Development' menu on the menu-bar
                (semantic-mode 1)))

    ;; ;; smart completion, and display of information for tags & classes
    ;; (require 'semantic/ia)
    ;;
    ;; (require 'semantic/db)

    (with-eval-after-load "semantic"

      (defun leuven--semantic ()
        ;; automatically complete whatever symbol you are typing
        (local-set-key "\C-c?" 'semantic-ia-complete-symbol) ;; better binding: `M-/'?

        ;; jump to the definition of the symbol under cursor
        (local-set-key "\C-cj" 'semantic-ia-fast-jump) ;; where a symbol is declared

        ;; show the documentation of the symbol under cursor
        (local-set-key "\C-cq" 'semantic-ia-show-doc) ;; show javadoc of the right method

        ;; show a summary about the symbol under cursor
        (local-set-key "\C-cs" 'semantic-ia-show-summary)


        ;; show possible public member functions or data members (when at `.'
        ;; or `->' after an object name)
        (local-set-key "\C-c>" 'semantic-complete-analyze-inline)

        ;; toggle between the implementation and a prototype of symbol under
        ;; cursor
        (local-set-key "\C-cp" 'semantic-analyze-proto-impl-toggle)

        ;; visit the header file under cursor
        (local-set-key "\C-c=" 'semantic-decoration-include-visit)


        ;; unfold the block under cursor
        (local-set-key "\C-c+" 'semantic-tag-folding-show-block)

        ;; fold the block under cursor
        (local-set-key "\C-c-" 'semantic-tag-folding-fold-block)

        ;; C-c C-c is not a prefix key!
        ;; ;; unfold all
        ;; (local-set-key "\C-c\C-c+" 'semantic-tag-folding-show-all)
        ;;
        ;; ;; fold all
        ;; (local-set-key "\C-c\C-c-" 'semantic-tag-folding-fold-all)
        )

      (add-hook 'prog-mode-hook 'leuven--semantic)

      (defun leuven--c-mode-semantic ()
        "Completion on `.' or `->'."
        (local-set-key "." 'semantic-complete-self-insert)
        (local-set-key ">" 'semantic-complete-self-insert)
        (local-set-key "\C-c\C-r" 'semantic-symref))

      (add-hook 'c-mode-common-hook 'leuven--c-mode-semantic))

    ;; hooks, specific for Semantic
    (defun leuven--semantic-imenu ()
      (imenu-add-to-menubar "TAGS"))

    (add-hook 'semantic-init-hooks 'leuven--semantic-imenu)

    )
#+end_src

*** Advanced Code Browsing
    :PROPERTIES:
    :ID:       5032bcdb-ac6b-4101-a0ce-28192fb7e247
    :END:

Some people use CEDET in combination with [[http://www.xemacs.org/Documentation/packages/html/ecb_2.html][ECB (the Emacs Code Browser)]], which
provides views of directories and files.

Keyboard navigation:

- =C-c . g d= ::
     Go to directories

- =C-c . g s= ::
     Go to sources

- =C-c . g m= ::
     Go to methods

- =C-c . g h= ::
     Go to history

- =C-c . g 1= ::
     Go to edit buffer

#+begin_src emacs-lisp
  ;; Emacs Code Browser
  (custom-set-variables '(ecb-options-version "2.40"))
  (when (try-require 'ecb-autoloads-XXX)

    ;; trick for starting ECB 2.40 (with CEDET merged in Emacs since 23.2)
    (GNUEmacs
      (require 'semantic/analyze))
    (provide 'semantic-analyze)
    (provide 'semantic-ctxt)
    (provide 'semanticdb)
    (provide 'semanticdb-find)
    (provide 'semanticdb-mode)
    (provide 'semantic-load)

    (setq stack-trace-on-error t)

    ;; don't show tip of the day at start time of ECB
    (setq ecb-tip-of-the-day nil)

    ;; toggle activation of ECB (between `ecb-activate' and
    ;; `ecb-deactivate')
    (global-set-key
      (kbd "C-c e") 'ecb-minor-mode)

    ;; (global-set-key (kbd "<M-left>") 'ecb-goto-window-methods)
    ;; (global-set-key (kbd "<M-right>") 'ecb-goto-window-edit1)
    )
#+end_src

If you've installed CEDET and ECB, EmacsAssist is worth trying out:
http://www.mail-archive.com/gnu-emacs-sources@gnu.org/msg00292.html

It uses CEDET to provide a handy symbols browser for the current file, that
narrows down the list as you type substrings. Tastes differ, but I for one
really like this.

#+begin_src emacs-lisp :tangle no
   (when (try-require 'eassist)

     (defun leuven--c-mode-eassist ()
       (local-set-key "\C-ct" 'eassist-switch-h-cpp)
       (local-set-key "\C-xt" 'eassist-switch-h-cpp)
       (local-set-key "\C-ce" 'eassist-list-methods))

     (add-hook 'c-mode-common-hook 'leuven--c-mode-eassist))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 28 ends here
#+end_src

* Abbrevs

An "abbrev" is a *word* which has been defined (in a fixed list) to "expand"
into a specified *expansion*.

#+begin_src emacs-lisp
;;* 29 (info "(emacs)Abbrevs")

(leuven--chapter leuven-chapter-29-abbrevs "29 Abbrevs"

  ;; See (info "(autotype)") as well
#+end_src

** Controlling Abbrev Expansion

For complex templates, I use =YASnippet=. For example, new file templates (where
it's lisp evaluation is handy), class and function templates with docblocks,
etc. I use it to reduce the repetitious parts of programming, and let me focus
on getting things done.

=YASnippet= does support mirror fields and transformations. It also does support
multiple snippet with same name. It will also expand snippets containing
non-word-constituent characters, which =abbrev= can't. So I can't have =@p= expand
to =@param= with =abbrev=, but I can with =YASnippet=.

#+begin_src emacs-lisp
;;** 29.3 Controlling (info "(emacs)Expanding Abbrevs")

  (leuven--section "29.3 Controlling Expanding Abbrevs")

  ;; Yet Another Snippet extension for Emacs
  (GNUEmacs
    ;; use the "standard" package (NOT `yasnippet-bundle'!)
    (when (try-require 'yasnippet)
#+end_src

=yas-snippet-dirs= is assumed to contain *directories of modes* with snippets.

By default, put *your own snippets* in =~/.emacs.d/snippets=.

#+begin_src emacs-lisp
      (defvar leuven-yasnippet-my-snippets-dir
        "~/src/yasnippet/snippets"
        "Directory containing my personal additional YASnippets.")

      ;; root directories that store the snippets
      (let ((my-snippets
             leuven-yasnippet-my-snippets-dir)
            (org-snippets
             (concat leuven-local-repos-directory "yasnippet-org-mode")))

        (when (file-directory-p org-snippets)
          (add-to-list 'yas-snippet-dirs org-snippets))

        ;; the first element is always the user-created snippets directory
        (when (file-directory-p my-snippets)
          (add-to-list 'yas-snippet-dirs my-snippets)))

      ;; use Snippet mode for files with a `yasnippet' extension
      (add-to-list 'auto-mode-alist '("\\.yasnippet\\'" . snippet-mode))
#+end_src

#+begin_src emacs-lisp
      ;; enable the YASnippet menu and tab-trigger expansion in *all*
      ;; buffers
      (yas-global-mode 1)

      ;; ;; text that will be used in menu to represent the trigger
      ;; (setq yas-trigger-symbol " <tab>")
#+end_src

After editing your snippets:
- =M-x yas-recompile-all= to compile all snippets,
- =M-x yas-reload-all= to reload them all.

;; https://github.com/vderyagin/dotemacs/blob/master/conf/yasnippet-configuration.el
;; https://earthserver.com/Setting_up_a_C%2B%2B11_development_environment_on_Linux_with_Clang_and_Emacs

Automatically reload snippets after saving.

#+begin_src emacs-lisp
      (add-hook 'snippet-mode-hook
                (lambda ()
                  (setq require-final-newline nil)))

      ;; automatically reload snippets after saving
      (defun recompile-and-reload-all-snippets ()
        (interactive)
        (when (eq major-mode 'snippet-mode)
          (yas-recompile-all)
          (yas-reload-all)
          (message "Reloaded all snippets")))

      (add-hook 'after-save-hook 'recompile-and-reload-all-snippets)))
#+end_src

** Dynamic Abbrev Expansion
   :PROPERTIES:
   :ID:       0fa23e4a-e42c-4317-834c-d2ef7c9d741c
   :END:

"Dynamic abbrevs" allow the meanings of abbreviations (expansions) to be
*determined automatically from the contents of the buffer*. It is completely
independent of Abbrev mode.

=M-/= runs the command =dabbrev-expand= by default. Expand previous word
"dynamically". *Expands to the most recent, preceding word* for which this is a
prefix.

=C-M-/= runs the command =dabbrev-completion=. Completion on current word. Like
=M-/= but finds all expansions in the current buffer and *presents suggestions
for completion*.

See [[id:4b262301-5370-40c6-8da6-019215634e20][completion for symbol names]].

#+begin_src emacs-lisp
;;** 29.7 (info "(emacs)Dabbrev Customization")

  (leuven--section "29.7 Dabbrev Customization")

  ;; (with-eval-after-load "dabbrev"
  ;;
  ;;   ;; preserve case when expanding the abbreviation
  ;;   (setq dabbrev-case-replace nil))
#+end_src

*** Hippie-expand

#+begin_src emacs-lisp
  ;; expand text trying various ways to find its expansion
  (global-set-key
    (kbd "M-/") 'hippie-expand)

  (with-eval-after-load "hippie-exp"

    ;; list of expansion functions tried (in order) by `hippie-expand'
    ;; (completion strategy)
    (setq hippie-expand-try-functions-list
          '(try-expand-dabbrev ;; current buffer
            try-expand-dabbrev-visible ;; visible (parts of all) buffers
            try-expand-dabbrev-all-buffers ;; all opened buffers
            try-expand-dabbrev-from-kill ;; kill ring
            try-complete-file-name-partially ;; file names
            try-complete-file-name
            try-expand-all-abbrevs ;; abbreviations
            try-expand-list
            try-expand-line
            try-complete-lisp-symbol-partially
            try-complete-lisp-symbol
            try-expand-whole-kill))

    (setq hippie-expand-try-functions-list
          '(try-complete-file-name-partially
            try-complete-file-name
            try-expand-all-abbrevs
            try-expand-dabbrev
            try-expand-dabbrev-all-buffers
            try-expand-dabbrev-from-kill))

    ;; integrate YASnippet with `hippie-expand'
    (with-eval-after-load "yasnippet"

      (add-to-list 'hippie-expand-try-functions-list
                    'yas/hippie-try-expand)))
#+end_src

*** Auto-Complete

Extensible inline text completion mechanism -- really brilliant!

Auto start vs M-/

#+begin_src emacs-lisp
  (GNUEmacs

    ;; Auto Completion
    (when (locate-library "auto-complete-config")
      (idle-require 'auto-complete-config)

      (with-eval-after-load "auto-complete-config"

        ;; avoid flyspell processes when auto completion is being started
        (ac-flyspell-workaround)

        ;; optimize sources to use
        (ac-config-default)

        ;; change default sources
        (setq-default ac-sources
                      ;; buffers whom major-mode is same to of a current
                      ;; buffer
                      '(ac-source-words-in-same-mode-buffers))

        ;; change sources for Emacs Lisp mode
        (add-hook 'emacs-lisp-mode-hook
                  (lambda ()
                    (setq ac-sources
                          '(ac-source-words-in-same-mode-buffers
                            ac-source-words-in-buffer
                            ac-source-symbols))))

        ;; enable auto-complete-mode automatically for Sword mode
        (add-to-list 'ac-modes 'sword-mode)

        ;; ;; delay to completions will be available
        ;; (setq ac-delay 0.1)

        ;; completion menu will be automatically shown
        (setq ac-auto-show-menu 0.3)

        ;; ;; start auto-completion at current point
        ;; (define-key ac-mode-map
        ;;   (kbd "M-TAB") 'auto-complete)

        ;; try expand
        (define-key ac-complete-mode-map
          (kbd "<tab>") 'ac-expand))))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 29 ends here
#+end_src

* Dired, the Directory Editor

#+begin_src emacs-lisp
;;* 30 (info "(emacs)Dired"), the Directory Editor

(leuven--chapter leuven-chapter-30-dired "30 Dired, the Directory Editor"
#+end_src

** Entering Dired

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Enter")

  ;; directory-browsing commands
  (with-eval-after-load "dired"

    (leuven--section "30.1 (emacs)Dired Enter")

    ;; switches passed to `ls' for Dired
    (setq dired-listing-switches
          ;; "-a -F --group-directories-first -l -p --time-style=long-iso"
          ;; causes display problems on Windows
          "-a -F -l -p"
          )
#+end_src

** Deleting Files with Dired

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Deletion")

    (leuven--section "30.3 (emacs)Dired Deletion")

    ;; recursive deletes allowed, after asking for each directory at top
    ;; level
    (setq dired-recursive-deletes 'top)
#+end_src

** Visiting Files in Dired

- =^= ::
     =dired-up-directory=

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Visiting")

    (leuven--section "30.5 (emacs)Dired Visiting")
#+end_src

*** Reuse Dired buffers

Single Dired buffer.

#+begin_src emacs-lisp
    ;; reuse Dired buffers, by running the command
    ;; `dired-find-alternate-file' (bound to `a') on a directory
    (put 'dired-find-alternate-file 'disabled nil)

    ;; reuse the current Dired directory buffer to visit another directory
    ;; (limit Dired to 1 single buffer)
    (when (try-require 'dired-single)

      (define-key dired-mode-map
        (kbd "<return>") 'joc-dired-single-buffer)

      (define-key dired-mode-map
        (kbd "<mouse-1>") 'joc-dired-single-buffer-mouse)

      (define-key dired-mode-map
        (kbd "^")
        (lambda ()
          (interactive)
          (joc-dired-single-buffer "..")))

      ;; (define-key dired-mode-map
      ;;   (kbd "C-x C-j")
      ;;   (lambda ()
      ;;     (interactive)
      ;;     (joc-dired-single-buffer "..")))
      )
#+end_src

*** Open file with default tool (open directory with Windows Explorer)

On top of the traditional ways, there are also these add-ons which open files
using external programs (such as PDF viewers), based on their extension.

One advantage is that using the traditional =!= (or =X=) switch with Dired locks
up Emacs until you close the other program. These add-ons do not and leave
Emacs free for continued used.

*************** TODO Read http://www.piprime.fr/1302/plus-qu-un-explorateur-de-fichiers-le-mode-dired-d-emacs/

#+begin_src emacs-lisp :tangle no
(defun helm-c-open-file-with-default-tool (file)
  "Open FILE with the default tool on this platform."
  (let (process-connection-type)
    (if (eq system-type 'windows-nt)
        (helm-w32-shell-execute-open-file file)
        (start-process "helm-c-open-file-with-default-tool"
                       nil
                       (cond ((eq system-type 'gnu/linux)
                              "xdg-open")
                             ((or (eq system-type 'darwin) ;; Mac OS X
                                  (eq system-type 'macos)) ;; Mac OS 9
                              "open"))
                       file))))
#+end_src

If =xdg-open= is not available, one can replace it with =gnome-open= or =kde-open=.

#+begin_src emacs-lisp :tangle no
(defun dired-launch-command ()
 (interactive)
 (dired-do-shell-command
  (case system-type
    (gnu/linux "gnome-open") ;; right for gnome (ubuntu), not for other systems
    (darwin "open"))
  nil
  (dired-get-marked-files t current-prefix-arg)))

(define-key dired-mode-map
  (kbd "F") 'dired-launch-command)
#+end_src

**** Ask a WWW browser to display file

Just ask a WWW browser to display the current file.

#+begin_src emacs-lisp
    (define-key dired-mode-map
      (kbd "e") 'browse-url-of-dired-file) ;; <C-RET>?
#+end_src

It works for files as well as for directories.

It opens the Windows explorer for:

- the *current directory* when invoked on =.=.
- the *parent directory* when invoked on =..=.

*************** TODO Mapcar on the browse-url function
See code of =w32-dired-open-files-externally=.
*************** END

*************** TODO =C-u <RET>= opens dired on Org link
We should probably have the same type of key binding for opening Explorer from
Dired.
*************** END

**** Many files at once (for Windows)

For those under Windows:

#+begin_src emacs-lisp
    ;; open files using Windows associations
    (GNUEmacs
      (when running-ms-windows
        (defun w32-dired-open-files-externally (&optional arg)
          "In Dired, open the marked files (or directories) with the default
        Windows tool."
          (interactive "P")
          (mapcar
           (lambda (file)
             (w32-shell-execute "open" (convert-standard-filename file)))
           (dired-get-marked-files nil arg)))

        ;; bind it to `E' in Dired mode
        (define-key dired-mode-map
          (kbd "E") 'w32-dired-open-files-externally)))
#+end_src

It works for files as well as for directories. It opens the Windows explorer
for the *current directory* when invoked on =.= (correct) or =..= (bug!!).

*** Open file with w3m

See news "Opening html-File in Dired with w3m" for extra info.

#+begin_src emacs-lisp
    ;; open current file with w3m
    (when (executable-find "w3m")
      (defun dired-find-w3m ()
        "In Dired, visit (with find-w3m) the file named on this line."
        (interactive)
        (w3m-find-file (file-name-sans-versions (dired-get-filename) t)))

      ;; add a binding "W" -> `dired-find-w3m' to Dired
      (define-key dired-mode-map
        "W" 'dired-find-w3m))
#+end_src

** Dired Marks vs. Flags

#+begin_src emacs-lisp
    (defun leuven-make-executable ()
      "Make a script executable, from the buffer in which you edit it."
      (interactive)
      (shell-command (concat "chmod +x " buffer-file-name)))
#+end_src

** Operating on Files

#+begin_src emacs-lisp
;;** (info "(emacs)Operating on Files")

    (leuven--section "30.7 (emacs)Operating on Files")

    ;; try to guess a default target directory
    (setq dired-dwim-target t)

    ;; copy recursively without asking
    (setq dired-recursive-copies 'always)
#+end_src

** Updating the Dired Buffer

Check this out as well: http://www.emacswiki.org/emacs/DiredSortMenu

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Updating")

    (leuven--section "30.15 (emacs)Dired Updating")

    ;; add-on for sorting
    (try-require 'dired-sort-map)
    ;; press `s' then `s', `x', `t', `n' or `d' to sort by
    ;; Size, eXtension, Time, Name or name grouping Dirs
#+end_src

** Dired and =find=

For searches in Dired, see =dired-do-search= (=A=).
- Search through all *marked files* for a match for regexp
- Stops when a match is found
- To continue searching for next match, use command "M-,"

#+begin_src emacs-lisp
;;** (info "(emacs)Dired and Find")

    (leuven--section "30.16 (emacs)Dired and Find")

    ;; ;; what to use in place of `-ls' as the final argument
    ;; (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
    ;; ;; quicker to collate the matches and then use `xargs' to run the
    ;; ;; command (variable defined in `find-dired.el')

;; (when Cygwin... XXX
    ;; search for files with names matching a wild card pattern and Dired
    ;; the output
    (global-set-key
      (kbd "C-c 1") 'find-name-dired)
      ;; case insensitive if `read-file-name-completion-ignore-case' is non-nil

    ;; `find-grep-dired' case insensitivity
    (setq find-grep-options "-i -q")

    ;; search for files with contents matching a wild card pattern and Dired
    ;; the output
    (global-set-key
      (kbd "C-c 2") 'find-grep-dired)
#+end_src

** Editing the Dired Buffer

=Wdired= mode is great for renaming (a lot of) files in a directory, as it
allows editing the Dired buffer like a text file, using all the power of
Emacs. That is, one can use keyboard macros, search and replace, rectangle
mode (great for adding prefixes to file names), flip mode bits with the mouse,
etc.!

To enter it, type =C-x C-q=.

#+begin_src emacs-lisp
;;** (info "(emacs)Wdired")

    (leuven--section "30.17 Editing the (emacs)Wdired Buffer")

    ;; put a Dired buffer in a mode in which filenames are editable
    (with-eval-after-load "wdired"

      ;; permissions bits of the files are editable
      (setq wdired-allow-to-change-permissions t))
#+end_src

** Viewing Image Thumbnails in Dired

=M-x image-dired= and choose a directory with images.

Prerequisites:
- [[http://www.imagemagick.org.][ImageMagick]] package
- JpegTRAN program
- [[http://www.sno.phy.queensu.ca/~phil/exiftool/][exiftool]] to *edit comments and tags* for each image.

Key bindings:

- C-t d ::
     =image-dired-display-thumbs= (on marked files)

- C-t e ::
     =image-dired-dired-edit-comment-and-tags=

For more information, see:
- http://www.emacswiki.org/Tumme
- http://wikemacs.org/wiki/Image-dired

#+begin_src emacs-lisp
;;** (info "(emacs)Image-Dired")

    (leuven--section "30.18 Viewing Image Thumbnails in Dired")

    ;; use Dired to browse and manipulate your images
    (with-eval-after-load "image-dired"

      ;; maximum number of files to show before warning the user
      (setq image-dired-show-all-from-dir-max-files 100)

      ;; size of button-like border around thumbnails
      (setq image-dired-thumb-relief 0)

      ;; size of the margin around thumbnails
      (setq image-dired-thumb-margin 4))
#+end_src

The following code block is currently disabled, because it causes problems
with Org and PDF LaTeX: when we've opened the TeX file, to compile it from
LaTeX because an error has been reported (with no details), then the TeX file
blocks the next automatic exports (=C-u C-c C-e=), asking for confirmation
because the TeX buffer is open...

#+begin_example
Reverting buffer `prestations/'.
prestations-2013-06.tex changed on disk; really edit the buffer? (y, n, r or C-h) n
#+end_example

#+begin_src emacs-lisp :tangle no
(add-hook 'dired-mode-hook
          (lambda ()

            ;; Auto-refresh dired on file change
            (auto-revert-mode)
            (setq-default auto-revert-interval 1)))
#+end_src

** Dired Extra

Extra Dired functionality

- =dired-x= has a feature to "guess" the right shell command and the right
  external viewer for documents (see =dired-guess-shell-alist-user=)

- You can also jump to the Dired buffer corresponding to the current buffer by
  pressing =C-x C-j= (=dired-jump=). If in Dired already, pop up a level and goto
  old directory's line.

  *Standard* alternative: =C-x d <RET>=, though it doesn't set point on the right
  file.

#+begin_src emacs-lisp
;;** Dired Extra

    (leuven--section "30.XX (dired-x)Top")

    ;; load `dired-x.el' when Dired is first invoked (for example, when
    ;; you first type `C-x d')
    (add-hook 'dired-load-hook
              (lambda ()
                (load "dired-x")))
#+end_src

#+begin_src emacs-lisp
    ) ;; with-eval-after-load "dired" ends here
#+end_src

** Dired+

#+begin_src emacs-lisp
;;** Dired+

  (leuven--section "30.XX Dired+")

  ;; extensions to Dired (provides fancy highlighting, etc.)
  (add-hook 'dired-load-hook
            (lambda ()
              (try-require 'dired+)))
#+end_src

** Emulation of =ls= on MS-Windows

#+begin_src emacs-lisp
;;** (info "(emacs)ls in Lisp")

  (leuven--section "G.4 (emacs)ls in Lisp")

  ;; emulate insert-directory completely in Emacs Lisp
  (with-eval-after-load "ls-lisp"

    ;; disable the case sensitive sort of file names
    (setq ls-lisp-ignore-case t)

    ;; sort directories first
    (setq ls-lisp-dirs-first t)

    ;; use ISO 8601 dates (on MS-Windows)
    (setq ls-lisp-format-time-list
          '("%Y-%m-%d %H:%M"
            "%Y-%m-%d %H:%M"))

    ;; use localized date/time format
    (setq ls-lisp-use-localized-time-format t))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 30 ends here
#+end_src

* The Calendar and the Diary

#+begin_src emacs-lisp
;;* 31 The (info "(emacs)Calendar/Diary")

(leuven--chapter leuven-chapter-31-calendar-diary "31 The Calendar and the Diary"
#+end_src

** Calendar Motion

#+begin_src emacs-lisp
;;** 31.1 (info "(emacs)Calendar Motion")

  (leuven--section "31.1 (emacs)Calendar Motion")

  ;; years must be written in full
  (setq diary-abbreviated-year-flag nil)

  ;; set the style of calendar and diary dates to ISO (how to interpret
  ;; the dates)
  (setq calendar-date-style 'iso)

  ;; week in the calendar begins on Monday
  (setq calendar-week-start-day 1)

  ;; mark all visible dates that have diary entries
  (when (file-exists-p "~/diary")
    (setq calendar-mark-diary-entries-flag t))

  ;; mark the current date (by changing its face) after generating a calendar,
  ;; if today's date is visible
  (add-hook 'calendar-today-visible-hook 'calendar-mark-today)
#+end_src

** Scroll Calendar

#+begin_src emacs-lisp
;;** 31.2 (info "(emacs)Scroll Calendar")

  (leuven--section "31.2 (emacs)Scroll Calendar")

  ;; fix foolish calendar-mode scrolling after loading `calendar.el'
  (add-hook 'calendar-load-hook
            (lambda ()
              (define-key calendar-mode-map
                (kbd ">") 'scroll-calendar-left)
              (define-key calendar-mode-map
                (kbd "<") 'scroll-calendar-right)))
#+end_src

** Times of Sunrise/Sunset

#+begin_src emacs-lisp
;;** 31.7 Times of (info "(emacs)Sunrise/Sunset")

  (leuven--section "31.7 Times of (emacs)Sunrise/Sunset")

  ;; calendar functions for solar events
  (with-eval-after-load "solar"

    ;; name of the calendar location
    (setq calendar-location-name "Leuven, BE")

    ;; latitude of `calendar-location-name'
    (setq calendar-latitude 50.88)

    ;; longitude of `calendar-location-name'
    (setq calendar-longitude 4.70))
#+end_src

** Diary

The Emacs diary keeps track of appointments or other events on a daily basis,
in conjunction with the calendar. To use the diary feature, you must first
create a "diary file" containing a list of events and their dates.

But [[id:737b836b-ac1f-4120-94ca-c9e0282268f0][Org]] outperforms it!

** Appointments

#+begin_src emacs-lisp
;;** 31.11 (info "(emacs)Appointments")

  (leuven--section "31.11 (emacs)Appointments")

  ;; insinuate appt if `diary-file' exists
  (if (file-readable-p "~/diary")
      (try-require 'appt) ;; requires `diary-lib', which requires `diary-loaddefs'
    (message "Appointment reminders library `appt' not loaded (no diary file found)"))

  (with-eval-after-load "appt"

    ;; send the first warning 60 minutes before an appointment
    (setq appt-message-warning-time 60) ; [default: 12]

    ;; warn every 15 minutes
    (setq appt-display-interval 15)     ; [default: 3]
#+end_src

Send notifications using =notifications-notify= (which was added in Emacs 24).
It uses =notify-send= (if the =libnotify-bin= Ubuntu package is installed).

*************** TODO For Windows users: use `todochicku.el' and the snarl notifier

*************** TODO Diff between shell-command and call-process?  Blocking call?

#+begin_src emacs-lisp
    ;; use a separate window to display appointment reminders
    (setq appt-display-format 'window)

    ;; function called to display appointment reminders *in a window*
    (setq appt-disp-window-function (function leuven--appt-display))

    (defun leuven--appt-display (mins-to-appt current-time notification-string)
      "Display a reminder for appointments.

    Use libnotify if available and if display is graphical, or fall back on a
    message in the echo area."
      (or (listp mins-to-appt)
          (setq notification-string (list notification-string)))
      (dotimes (i (length notification-string))
        (cond ((and (display-graphic-p)
                    (executable-find "notify-send"))
               (shell-command
                (concat "notify-send "
                        "-i /usr/share/icons/gnome/32x32/status/appointment-soon.png "
                        "-t 1000 "
                        "'Appointment' "
                        "'" (nth i notification-string) "'")))
              (t
               (message "%s" (nth i notification-string))
               (sit-for 1)))))
#+end_src

#+begin_src emacs-lisp
    ;; turn appointment checking on (enable reminders)
    (when leuven-load-verbose (message "(Info) Enable appointment reminders..."))
    (GNUEmacs
      (appt-activate 1))
    (XEmacs
      (appt-initialize))
    (when leuven-load-verbose (message "(Info) Enable appointment reminders... Done"))
#+end_src

#+begin_src emacs-lisp
    ;; enable appointment notification, several minutes beforehand
    (add-hook 'diary-hook 'appt-make-list)
#+end_src

#+begin_src emacs-lisp
    (with-eval-after-load "org-agenda"

      ;; keep your appointment list clean: if you delete an appointment from
      ;; your Org agenda file, delete the corresponding alert
      (defadvice org-agenda-to-appt (before leuven-org-agenda-to-appt activate)
        "Clear the existing appt-time-msg-list."
        (setq appt-time-msg-list nil))

      ;; add today's appointments (found in `org-agenda-files') each time the
      ;; agenda buffer is (re)built
      (add-hook 'org-finalize-agenda-hook
                'org-agenda-to-appt)
      ;;! don't use the `org-agenda-mode-hook' because the Org agenda files
      ;;! would be opened once by `org-agenda-to-appt', and then killed by
      ;;! `org-release-buffers' (because `org-agenda-to-appt' closes all the
      ;;! files it opened itself -- as they weren't already opened), to be
      ;;! finally re-opened!

      ;; add today's appointments (found in `org-agenda-files') each time such a
      ;; file is saved
      (add-hook 'after-save-hook
                (lambda ()
                  (when (and (eq major-mode 'org-mode)
                             (org-agenda-file-p))
                    (org-agenda-to-appt)))))
#+end_src

#+begin_src emacs-lisp
    ) ;; with-eval-after-load "appt" ends here
#+end_src

** Advanced Calendar/Diary Usage

#+begin_src emacs-lisp
;;** 31.15 (info "(emacs)Advanced Calendar/Diary Usage")

  (leuven--section "31.15 (emacs)Advanced Calendar/Diary Usage")

  ;; get rid of some holidays
  (setq holiday-general-holidays nil) ;; too U.S.-centric holidays
  (setq holiday-oriental-holidays nil) ;; Oriental holidays
  (setq holiday-hebrew-holidays nil) ;; religious holidays
  (setq holiday-islamic-holidays nil) ;; religious holidays
  (setq holiday-bahai-holidays nil) ;; Baha'i holidays
  (setq holiday-solar-holidays nil) ;; sun-related holidays

  ;; mark dates of holidays in the calendar window
  (setq calendar-mark-holidays-flag t)
#+end_src

After the calendar is loaded, =calendar-holidays= is the list of notable days
for the command =M-x holidays=.

#+begin_src emacs-lisp
  (defun leuven-insert-current-date (prefix)
    "Insert the current date in ISO format. With one PREFIX argument,
  add day of week. With two PREFIX arguments, add day of week and
  time."
    (interactive "P")
    (let ((format (cond ((not prefix) "%Y-%m-%d")
                        ((equal prefix '(4)) "%Y-%m-%d %a")
                        ((equal prefix '(16)) "%Y-%m-%d %a %H:%M"))))
      (insert (format-time-string format))))

  (global-set-key
    (kbd "C-c .") 'leuven-insert-current-date)
#+end_src

** Calendar framework

After displaying your =calfw= buffer, you can get a HTML buffer with =M-x
htmlfontify-buffer=.

#+begin_src emacs-lisp
;;* Calendar view framework on Emacs

  ;; calendar view framework on Emacs
  (with-eval-after-load "calfw"

    ;; Unicode characters
    (setq cfw:fchar-junction ?
          cfw:fchar-vertical-line ?
          cfw:fchar-horizontal-line ?
          cfw:fchar-left-junction ?
          cfw:fchar-right-junction ?
          cfw:fchar-top-junction ?
          cfw:fchar-top-left-corner ?
          cfw:fchar-top-right-corner ?))

  ;; calendar view for org-agenda
  (with-eval-after-load "calfw-org"

    ;; remove some strings (tags and filenames) from item summary
    (defun cfw:org-summary-format (item)
      "Format an item (How should it be displayed?)."
      (let* ((time (cfw:org-tp item 'time))
             (time-of-day (cfw:org-tp item 'time-of-day))
             (time-str (and time-of-day
                            (format "%02i:%02i "
                                    (/ time-of-day 100)
                                    (% time-of-day 100))))
             (category (cfw:org-tp item 'org-category))
             (tags (cfw:org-tp item 'tags))
             (marker (cfw:org-tp item 'org-marker))
             (buffer (and marker (marker-buffer marker)))
             (text (cfw:org-extract-summary item))
             (props (cfw:extract-text-props item 'face 'keymap)))
        (propertize
         (concat
          (if time-str (apply 'propertize time-str props)) text " "
          ;; (and buffer (buffer-name buffer))
          )
         'keymap cfw:org-text-keymap
         ;; Delete the display property, since displaying images will break our
         ;; table layout.
         'display nil))))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 31 ends here
#+end_src

* Sending Mail

Minimal configuration for sending a bug report, for example.

#+begin_src emacs-lisp
;;* 32 (info "(emacs)Sending Mail")

(leuven--chapter leuven-chapter-32-sending-mail "32 Sending Mail"

  ;; full name of this user
  (setq user-full-name "John Doe")

  ;; full mailing address of this user
  ;; (used in MAIL envelope FROM, and to select the default personality
  ;; ID)
  (setq user-mail-address "john@doe.com")

  ;; sending mail
  (setq send-mail-function 'smtpmail-send-it)

  (with-eval-after-load "smtpmail"

    ;; name of the host running SMTP server
    (setq smtpmail-smtp-server
          (or (getenv "SMTPSERVER")
              "mail"))

    ;; SMTP service port number
    (setq smtpmail-smtp-service 25))

) ;; chapter 32 ends here
#+end_src

* Gnus

#+begin_src emacs-lisp
;;* 34 (info "(emacs)Gnus")

(leuven--chapter leuven-chapter-34-gnus "34 Gnus"

  (global-set-key
    (kbd "C-c n")
    (lambda ()
      (interactive)
      (switch-or-start 'gnus "*Group*")))

  ;; directory beneath which additional per-user Gnus-specific files are
  ;; placed
  (setq gnus-directory "~/.gnus.d/")    ; this should end with a directory
                                        ; separator

  ;; a newsreader for GNU Emacs
  (with-eval-after-load "gnus"

    ;; package to compose an outgoing mail (Message, with Gnus paraphernalia)
    (setq mail-user-agent 'gnus-user-agent)
    (XEmacs
      (setq toolbar-mail-reader 'gnus))

    ;; reading mail with Gnus
    (setq read-mail-command 'gnus))
#+end_src

** BBDB

bbdb3: https://savannah.nongnu.org/projects/bbdb

#+begin_src emacs-lisp
;;** Insidious bbdb

  (leuven--section "Insidious bbdb")

;;* (info "(bbdb)Installation")

  (unless (ignore-errors (load-library "bbdb-autoloads")) ; "hand-made"
    (autoload 'bbdb "bbdb-com"
      "Insidious Big Brother Database." t)
    (autoload 'bbdb-name "bbdb-com"
      "Insidious Big Brother Database." t)
    (autoload 'bbdb-company "bbdb-com"
      "Insidious Big Brother Database." t)
    (autoload 'bbdb-net "bbdb-com"
      "Insidious Big Brother Database." t)
    (autoload 'bbdb-notes "bbdb-com"
      "Insidious Big Brother Database." t)

    (autoload 'bbdb-insinuate-gnus "bbdb-gnus"
      "Hook BBDB into Gnus.")
    ;; (autoload 'bbdb-insinuate-message "bbdb"
    ;;   "Hook BBDB into `message-mode'.") ;; BBDB 2.35
    (autoload 'bbdb-insinuate-message "bbdb-message"
      "Hook BBDB into `message-mode'."))

  ;; search the BBDB
  (global-set-key
    (kbd "<C-f11>") 'bbdb)

  (with-eval-after-load "bbdb"

    ;; coding system used for reading and writing `bbdb-file'
    (setq bbdb-file-coding-system 'utf-8)

    ;; ensure `~/.bbdb' never becomes non utf-8 again (it is defined with
    ;; `defconst', so it is reset whenever `bbdb.el' is loaded)
    (add-hook 'bbdb-load-hook
              (lambda ()
                (setq bbdb-file-coding-system 'utf-8)))

    ;; enable the various package-specific BBDB functions
    (bbdb-initialize 'gnus 'message)

    ;; - add bindings for the default keys to Gnus and configure Gnus to
    ;;   notify the BBDB when new messages are loaded (required if the
    ;;   BBDB is to be able to display BBDB entries for messages displayed
    ;;   in Gnus)
    (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)

    ;; - add a binding for `M-TAB' to Message mode. This will enable
    ;;   completion of addresses based on BBDB records
    (add-hook 'gnus-startup-hook 'bbdb-insinuate-message)


    ;; (bbdb-mua-auto-update-init 'gnus 'message)


    ;; (define-key gnus-summary-mode-map
    ;;   (kbd ":") 'bbdb-mua-display-sender)


    ;; ;; customizable completion in message headers
    ;; ;; (to avoid conflict between `flyspell' and `BBDB')
    ;; (try-require 'message-x)

    ;; FIXME Does not work (still ask to add address)
      ;; don't ask about fake addresses
      ;; NOTE: there can be only one entry per header (such as To, From)
      ;; http://flex.ee.uec.ac.jp/texi/bbdb/bbdb_11.html
      (setq bbdb-ignore-some-messages-alist
            '(("From" . "no.?reply\\|public.gmane.org")))
#+end_src

*** Interfaces

#+begin_src emacs-lisp
;;* (info "(bbdb)Interfaces")

    ;; mail aliases (local mailing lists)
    ;; (add-hook 'message-setup-hook 'bbdb-define-all-aliases) ; BBDB 2.35
    (add-hook 'message-setup-hook 'bbdb-get-mail-aliases) ; BBDB 3

    ;; always use full name when sending mail
    ;; (even if User Name has an address of the form <user.name@domain>)
    (setq bbdb-dwim-net-address-allow-redundancy t) ; BBDB 2.35
    (setq bbdb-mail-avoid-redundancy nil) ; BBDB 3

    ;; no popup on auto-complete
    (setq bbdb-completion-display-record nil)

    ;; completion is done across the set of all full-names and user-ids
    (setq bbdb-completion-type nil)
#+end_src

*** Reader-specific Features

#+begin_src emacs-lisp
;;* (info "(bbdb)Reader-specific Features")

    ;; marking posters with records in the BBDB
    (setq bbdb/gnus-summary-mark-known-posters t)

    ;; mark authors in the Summary Buffer who have records in the BBDB
    (setq bbdb/gnus-summary-known-poster-mark "B")

    ;; display the poster's name from the BBDB if we have one
    (setq bbdb/gnus-summary-prefer-real-names t)

    ;; replace the information provided in the From header with data from
    ;; the BBDB if we have one
    (setq bbdb/gnus-summary-prefer-bbdb-data t)

    (setq bbdb/gnus-summary-show-bbdb-names t)
#+end_src

*** Options

#+begin_src emacs-lisp
;;* (info "(bbdb)Options")

    ;; You can add the author of a mail or posting to the BBDB
    ;; by hitting `:'

    ;; name of the file which contains your personal database
    (setq bbdb-file "~/.bbdb")

    ;; no default area code to use when prompting for a new phone number
    (setq bbdb-default-area-code nil)

    ;; default country to use if none is specified
    (setq bbdb-default-country "")

    ;; disable syntax-checking of telephone numbers
    (setq bbdb-north-american-phone-numbers-p nil) ; BBDB 2.35
    (setq bbdb-phone-style nil)         ; BBDB 3

    ;; restoration of the window configuration
    (setq bbdb-electric-p t)            ; BBDB 2.35
    (setq bbdb-electric t)              ; BBDB 3

    ;; don't display a continuously-updating BBDB window while in GNUS
    ;; (setq bbdb-use-pop-up nil)       ; BBDB 2.35
    ;; (setq bbdb-pop-up-layout nil)    ; BBDB 3

    ;; desired number of lines in a GNUS pop-up BBDB window
    (setq bbdb-pop-up-target-lines 1)   ; BBDB 2.35
    (setq bbdb-pop-up-window-size 1)    ; BBDB 3

    ;; default display layout
    (setq bbdb-display-layout 'multi-line)

    ;; default display layout pop-up BBDB buffers
    (setq bbdb-pop-up-display-layout 'one-line)

    ;; omit creation-date and time stamp from BBDB display
    (setq bbdb-display-layout-alist
          '((one-line          (order     . (phones notes))
                               (name-end  . 24)
                               (toggle    . t)
                               (omit      . (net AKA mail-alias gnus-private
                                                 creation-date timestamp)))
            (multi-line        (indention . 14)
                               (toggle    . t)
                               (omit      . (AKA creation-date timestamp)))
            (pop-up-multi-line (indention . 14))))

    ;; allow cycling of email addresses while completing them
    (setq bbdb-complete-name-allow-cycling t) ; BBDB 2.35
    (setq bbdb-complete-mail-allow-cycling t) ; BBDB 3

    ;; save the database without asking (any time it would ask)
    (setq bbdb-offer-save 'auto)

    ;; automatically add some text to the notes field of the BBDB record
    (add-hook 'bbdb-notice-hook 'bbdb-auto-notes-hook)

    ;; capture auto-notes
    (setq bbdb-auto-notes-alist
          ;; organization
          `(("Organization" (".*" Organization 0))

            ;; X-Face bitmaps of the people
            ("x-face" ,(list (concat "[ \t\n]*\\([^ \t\n]*\\)"
                                     "\\([ \t\n]+\\([^ \t\n]+\\)\\)?"
                                     "\\([ \t\n]+\\([^ \t\n]+\\)\\)?"
                                     "\\([ \t\n]+\\([^ \t\n]+\\)\\)?")
                             'face
                             "\\1\\3\\5\\7")))))
#+end_src

*** Utilities

BBDB 3 has a dial interface which allows you to call an external interface to
make a call. This is done by modifying =bbdb-dial-function=. There are examples
which interface with Skype to make a phone call.

#+begin_src emacs-lisp
) ;; chapter 34 ends here
#+end_src

* Document Viewing

If =doc-view= is not showing the PDF files as images in Emacs, it may be
because:
- no PNG support is available in Emacs (see [[id:9432da83-fa9d-4466-a4da-57f33d662bbd][Images]]), or
- some conversion utility for PDF files (Ghostscript) is not on your =PATH=.

In that case, =doc-view= falls back to show you the plain text contents of the
PDF if =doc-view-pdftotext-program= is on your =PATH=.

#+begin_src emacs-lisp
;;* 35 (info "(emacs)Document View")

(leuven--chapter leuven-chapter-35-document-view "35 Document Viewing"

  ;; view PDF/PostScript/DVI files in Emacs
#+end_src

** Navigation

#+begin_src emacs-lisp
;;** 35.1 (info "(emacs)Navigation")

  (leuven--section "35.1 (emacs)Navigation")

  ;; `doc-view' integrates with the usual bookmark facility. So simply
  ;; use `C-x r m' (`bookmark-set') to jump back to the last page you've
  ;; read in a PDF document.
#+end_src

** Conversion

In =doc-view-mode=, you can use =C-s= to do regexp search on the page images.

In addition, by pressing =C-c C-t=, you can open the *text*-only representation
(actually, the output of the command =pdftotext=) of the current doc in a new
buffer, which is more suitable for heavy manipulation of the text of the PDF.

Another option, without =doc-view=, is =! pdtotext ? - <RET>=.

=doc-view-enlarge= (=+=) and =doc-view-shrink= (=-=) work fine to zoom in or out.

** XXX

#+begin_src emacs-lisp
  ;; antiword will be run on every `.doc' file you open
  ;; TODO sudo aptitude install antiword (or via Cygwin setup)
  (autoload 'no-word "no-word"
    "Word to txt.")
  (add-to-list 'auto-mode-alist '("\\.doc\\'" . no-word))



  (add-to-list 'auto-mode-alist '("\\.docx\\'" . docx2txt))

  (defun docx2txt ()
    "Run docx2txt on the entire buffer."
    (shell-command-on-region (point-min) (point-max) "docx2txt.pl" t t))



  ;; un-xls files
  ;; TODO sudo aptitude install xlhtml
  (add-to-list 'auto-mode-alist '("\\.xls\\'" . no-xls))
  (defun no-xls (&optional filename)
    "Run xlhtml and w3m -dump on the entire buffer.

  Optional FILENAME says what filename to use. This is only necessary for
  buffers without proper `buffer-file-name'. FILENAME should be a real filename,
  not a path."
    (interactive "fExcel File: ")
    (when (and filename
               (not (buffer-file-name)))
      (write-file (make-temp-file filename)))
    (erase-buffer)
    (shell-command
     (format "xlhtml -nc -te %s | w3m -dump -T text/html"
             (buffer-file-name))
     (current-buffer))
    (setq buffer-file-name nil)
    (set-buffer-modified-p nil))

  ;; no-ppt
  ;; TODO sudo aptitude install ppthtml
  ;; FIXME Not that good! (some text repeated multiple times)
  (defun no-ppt (&optional filename)
    "Run ppthtml and w3m -dump on the entire buffer.

  Optional FILENAME says what filename to use. This is only necessary for
  buffers without proper `buffer-file-name'.  FILENAME should be a real filename,
  not a path."
    (interactive "fPowerPoint File: ")
    (when (and filename
               (not (buffer-file-name)))
      (write-file (make-temp-file filename)))
    (erase-buffer)
    (shell-command
     (format "ppthtml %s | w3m -dump -T text/html" (buffer-file-name))
     (current-buffer))
    (setq buffer-file-name nil)
    (set-buffer-modified-p nil))
  (add-to-list 'auto-mode-alist '("\\.ppt\\'" . no-ppt))

) ;; chapter 35 ends here
#+end_src

* Running Shell Commands from Emacs

See customizations at http://snarfed.org/why_i_run_shells_inside_emacs.

#+begin_src emacs-lisp
;;* 36 Running (info "(emacs)Shell") Commands from Emacs

(leuven--chapter leuven-chapter-36-shell "36 Running Shell Commands from Emacs"
#+end_src

#+begin_src emacs-lisp
  ;; transform shell names to what they really are
  (with-eval-after-load "sh-script"

    (add-to-list 'sh-alias-alist '(sh . bash)))

  ;; XXX Test the following (added on 2011-08-03)
  ;; (when (eq system-type 'windows-nt)
  ;;   ;; Workaround for Cygwin shell, when set 'CYGWIN=noglob'. By default
  ;;   ;; shell-quote-argument' quoted by double '\' chars, this cause failure.
  ;;   (defun shell-quote-argument (argument)
  ;;     (concat "'" argument "'"))
  ;;   ;; Workaround for Cygwin when 'shell-file-name' is 'bash'.
  ;;   (setq null-device "/dev/null"))
  ;;
  ;; ;; Use shell from Cygwin/MinGW.
  ;; (setq shell-file-name "bash")
  ;; (setenv "SHELL" "/bin/bash")
  ;; (setq explicit-bash-args '("-i"))
  ;; (setq explicit-sh-args '("-i"))
#+end_src

** Single Shell

=M-!= (=shell-command=) reads a line of text using the minibuffer and executes it
as a shell command, in a subshell made just for that command.

=M-|= (=shell-command-on-region=) passes the contents of the region as the
standard input to the shell command. By prefixing it with =C-u=, it deletes the
old region and *replaces* it with the output from the shell command.

#+begin_src emacs-lisp
;;** 36.1 Single Shell

  (leuven--section "36.1 Single Shell")

  ;; force interactive behavior (to get my handy shell aliases)
  ;; FIXME Fix for Zsh (zsh:1: command not found: shopt)
  ;; (defadvice shell-command (before leuven-shell-command activate)
  ;;   (ad-set-arg 0
  ;;               (concat "source ~/.bashrc; shopt -s -q expand_aliases;\n "
  ;;                       (ad-get-arg 0))))

  ;; for single shell commands (= "the" reference)
  (setq shell-file-name                 ; must be in the `PATH'
        (or (ignore-errors
              (file-name-nondirectory (or (executable-find "zsh")
                                          (executable-find "bash")
                                          (executable-find "sh"))))
            (when running-ms-windows "cmdproxy.exe")))

  ;; use `shell-file-name' as the default shell
  (setenv "SHELL" shell-file-name)

  ;; switch used to have the shell execute its command line argument
  (setq shell-command-switch "-c")      ; `/c' does not work with XEmacs

  ;; quote process arguments to ensure correct parsing on Windows
  (setq w32-quote-process-args t)
#+end_src

The above assignments may *NOT* be done *in an eval-after-load* as those variables
are used by the (La)TeX modes (default + AUCTeX) among others.

** Interactive Shell

#+begin_src emacs-lisp
;;** 36.2 Interactive Shell

  (leuven--section "36.2 Interactive Shell")

  ;; for the interactive (sub)shell (and AUCTeX compilation?)
  (setq explicit-shell-file-name shell-file-name)

  ;; ;; args passed to inferior shell by `M-x shell', if the shell is bash
  ;; (setq explicit-bash-args '("--noediting" "--login"))
  ;; ;; FIXME This ensures that /etc/profile gets read (at least for Cygwin).
  ;; ;; Is this good?

  ;; regexp to match prompts in the inferior shell
  (setq shell-prompt-pattern "^[^#$%>\n]*[#$%>] *")
#+end_src

** Shell Mode

- =M-p= (or =<C-up>=, or =<up>= in Emacs Leuven) ::
     =comint-previous-input=

- =M-n= (or =<down>= in Emacs Leuven) ::
     =comint-next-input=

#+begin_src emacs-lisp
;;** 36.3 Shell Mode

  (leuven--section "36.3 Shell Mode")

  ;; general command-interpreter-in-a-buffer stuff (lisp, shell, R, ...)
  ;; (when (try-require 'comint)

    ;; regexp to recognize prompts in the inferior process
    ;; (set it for Org-babel sh session to work!)
    ;; (defun set-shell-prompt-regexp ()
      (setq comint-prompt-regexp shell-prompt-pattern)
    ;;   )
    ;; (add-hook 'shell-mode-hook 'set-shell-prompt-regexp)

    ;; no duplicates in command history
    (setq-default comint-input-ignoredups t)

    ;; input to interpreter causes windows showing the buffer to scroll
    ;; (inserting at the bottom)
    (setq-default comint-scroll-to-bottom-on-input t)

    ;; output to interpreter causes windows showing the buffer to scroll
    (setq-default comint-move-point-for-output t)

    ;; strip `^M' characters
    (add-to-list 'process-coding-system-alist
                 '("bash" . (undecided-dos . undecided-unix)))
    (add-to-list 'process-coding-system-alist
                 '("zsh" . (undecided-dos . undecided-unix)))

    ;; show completion list when ambiguous
    (setq comint-completion-autolist t)

    ;; use the `up' and `down' arrow keys to traverse through the previous
    ;; commands
    (defun leuven--up-down-keys ()
      "Customize my shell-mode."
      (local-set-key
        (kbd "<up>") 'comint-previous-input)
      (local-set-key
        (kbd "<down>") 'comint-next-input))

    (add-hook 'shell-mode-hook 'leuven--up-down-keys)
;; )

  ;; translate ANSI escape sequences into faces (within shell mode)
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src

If you ever tried to run a program like =git= under =M-x shell=, you will have
come across the warning "terminal is not fully functional" followed by
unusable behavior. This is because =git= sends its output through a pager
(probably =less=), which requires a real terminal emulator.

Setting the =PAGER= environment variable to =/bin/cat= (but only inside Emacs)
solves this problem:

#+begin_src emacs-lisp
  (setenv "PAGER" "/usr/bin/cat")
#+end_src

** Shell Prompts

#+begin_src emacs-lisp
;;** 36.4 Shell Prompts

  (leuven--section "36.4 Shell Prompts")
#+end_src

** History

#+begin_src emacs-lisp
;;** 36.5 History

  (leuven--section "36.5 History")
#+end_src

** Directory Tracking

#+begin_src emacs-lisp
;;** 36.6 Directory Tracking

  (leuven--section "36.6 Directory Tracking")
#+end_src

** Options

#+begin_src emacs-lisp
;;** 36.7 Options

  (leuven--section "36.7 Options")

  ;; disable command echoing
  (setq-default comint-process-echoes t) ; for Linux (not needed for Cygwin)
#+end_src

** Terminal emulator

#+begin_src emacs-lisp
;;** 36.8 Terminal emulator

  (leuven--section "36.8 Terminal emulator")
#+end_src

** Term Mode

See http://www.emacswiki.org/emacs/ShellMode#toc12 to switch between Term-mode
and Shell-mode, in the same buffer.

Mplayer commands do not work when I launch it in the Emacs shell. Use =term= for
"/" and "*" to decrease / increase volume.

#+begin_src emacs-lisp
;;** 36.9 Term Mode

  (leuven--section "36.9 Term Mode")
#+end_src

I could use Term mode, which provides a full terminal, but that
defeats the purpose of running inside Emacs.

I had similar gripes initially, but Term mode seems to do the job.
Switching between line-mode (`C-c C-j') and char-mode (`C-c C-k'),
you have a terminal emulator which you can treat as a Shell mode
buffer when you need to.

You can switch between term modes. Using `C-c c-j' will put you
in line mode where term is behaves like a buffer , then u can use
`C-c c-k' to switch back to char mode.


Emacs shell is a "dump" terminal which doesn't support (all) terminal
control codes. You need to use `M-x term' if you want a proper
terminal (but even that is not as good as the good old XTerm).

(term "bash")
If you do `M-x term', `bash' is offered as the default as well.

Need a good terminal emulation for applications that are interactive
with your terminal, in the same way `top' is working or `man' ... or
`less' ... or `unison'

"less" needs a _terminal_. Emacs's shell-mode is not a terminal so
"less" doesn't work. If the programs you use needs terminal features
then you must use a terminal, such as "M-x term".

This "page-at-a-time" feature comes with terminal emulation. There's
no need to make "M-x shell" a real terminal because there already is
one: "M-x term".

Try also to use `M-x ansi-term' that is much better than `term': with
M-x term, you can run only one shell; with `ansi-term' you can start
more than one (*ansi-term*<2>, *ansi-term*<3>).

One weird thing, is that 'M-x term' is a term emulation where less(1)
works and it has the 'C-c C-q' one-page-at-a-time thing as well...

M-x shell, has neither.

>> Or are there some things `M-x term' can't do while `M-x shell'
>> can?

> With M-x shell you're using emacs to construct the command to pass
> to the shell. This is an advantage if you shell doesn't keep a
> history or offers no completion mechanism. Also, you can use
> isearch to search through the command output, copy stuff into the
> kill ring or use the rectangle functions. Or you might just prefer
> the emacs key bindings over the one's your shell offers. 8-)

I'd like to point out that term-mode has also the so called "line
mode" (`C-c C-j') in which user can wander around the buffer pretty
much like anywhere else in Emacs. Kill-ring commands, isearch etc.
work. Then there is "char mode" (`C-c C-k'), the default, which is
like your normal terminal emulator except the escape key.

Actually you can read this in the emacs info pages: "In line mode,
Term basically acts like Shell mode".

The problem here is the word 'basically' which probably means
'almost'. So they differ in the details.

In my case, I started to use `M-x shell', and like it since I almost
never have to use applications that need a real term emulation. But
if you look at them (M-x term and M-x shell) carefully, then `M-x
term' has some weird behaviours when using the shell mode key
bindings; try for instance: `C-c C-e', `C-c C-a', `C-c C-o'... but as
I said they're details.

#+begin_src emacs-lisp
  ;; managing multiple terminal buffers in Emacs
  ;; (and fixing some troubles of `term-mode': key bindings, etc.)

  ;; "multi-term on POSIX hosts has let me switch from using screen, with
  ;; one Emacs screen and lots of shell screens; to just using Emacs, with
  ;; lots of terminals inside it."

  (when (locate-library "multi-term")

    (autoload 'multi-term "multi-term"
      "Create new term buffer." t)
    (autoload 'multi-term-next "multi-term"
      "Go to the next term buffer." t)

    (setq multi-term-program shell-file-name)

    ;; (global-set-key (kbd "C-c t") 'multi-term-next)
    (global-set-key
      (kbd "C-c T") 'multi-term)) ;; create a new one
#+end_src

#+begin_src emacs-lisp
  ;; ;; run an inferior shell, with I/O through buffer `*shell*'
  ;; (global-set-key
  ;;   (kbd "C-c !")
  ;;   (cond (running-ms-windows 'shell)
  ;;         (t 'term)))

  ;; toggle to and from the `*shell*' buffer
  (global-set-key
    (kbd "C-!")
    (lambda ()
      (interactive)
      (switch-or-start 'shell "*shell*")))
#+end_src

*************** TODO Terminal in Emacs in Windows - Error message: "Spawning child process; invalid argument"

*************** TODO Try /visual/ commands (like =top= or =less=) in =multi-term=

** Paging in Term

#+begin_src emacs-lisp
;;** 36.10 Paging in Term

  (leuven--section "36.10 Paging in Term")
#+end_src

** Remote Host

#+begin_src emacs-lisp
;;** 36.11 Remote Host

  (leuven--section "36.11 Remote Host")

  ;; load ssh.el file
  (add-to-list 'same-window-regexps "^\\*ssh-.*\\*\\(\\|<[0-9]+>\\)")
  (autoload 'ssh "ssh"
    "Open a network login connection via `ssh'." t)
    ;; this is to run ESS remotely on another computer in my own Emacs, or
    ;; just plain old reading remote files

  ;; See http://emacs.1067599.n5.nabble.com/SSH-inside-Emacs-td225528.html
  ;; - plink (with `dumb' terminal option?) as interactive shell
  ;; - ssh -t -t user@host
  ;; - Cygwin'ized Emacs
  ;; - MSYS (MinGW)
#+end_src

** Serial Terminal

Since GNU Emacs 23, there's now support for serial port access. The new
command =serial-term= starts an interactive terminal on a serial port.

** Helper for GNU Emacs on w32

Let Emacs, for example, find the program =/usr/bin/w3m=.

*But it causes problems (Emacs crashes or unable to connect) when reading mail
with Gnus...*

#+begin_src emacs-lisp
    ;; ;; let Emacs recognize Cygwin paths (e.g. /usr/local/lib)
    ;; (when (and running-ms-windows
    ;;            (executable-find "mount")) ;; Cygwin bin directory found
    ;;   (when (try-require 'cygwin-mount)
    ;;     (cygwin-mount-activate)))
#+end_src

#+begin_src emacs-lisp
)
#+end_src

** XXX

You're debugging bash code? I normally use =mode-compile.el= for this.
Basically, it runs bash with lots of debug output.

See =w32-settings.el= for more!

** Proced

#+begin_src emacs-lisp
;;* Proced

  ;; start Proced in a similar manner to Dired
  (global-set-key
    (kbd "C-x p") 'proced)

  (with-eval-after-load "proced"

    ;; current sort scheme for proced listing
    (setq-default proced-sort 'start)

    ;; display of Proced buffer as process tree
    (setq-default proced-tree-flag t))
#+end_src

* Using Emacs Server

The Emacs version you're using and the =emacsclient= version you're using must
be from the *same Emacs version*... If the latter is not the cause of a refused
connection, re-try =M-x server-start= in Emacs.


=emacsclient= is waiting for Emacs to tell it it's done editing that file.
That's important if you use =emacsclient= as your =EDITOR=. If you want
=emacsclient= to return immediately, use the =-n= option.

Do you use =emacsclient= in terminals? If not, just use parameter =-c -n=, which
creates an X Window and doesn't wait for =(server-edit)=.

#+begin_src emacs-lisp
;;* 37 (info "(emacs)Emacs Server")

(leuven--chapter leuven-chapter-37-emacs-server "37 Using Emacs as a Server"

  ;; use Emacs as a server (with the `emacsclient' program)
  (GNUEmacs
    (idle-require 'server) ;; after init
    (with-eval-after-load "server"

      ;; test whether server is (definitely) running, avoiding the message of
      ;; "server-start" while opening another Emacs session
      (or (equal (server-running-p) t)

          ;; start the Emacs server
          (server-start)))) ;; ~ 0.20 s

) ;; chapter 37 ends here
#+end_src

Since GNU Emacs 23, there is also a =--daemon= flag to start the server in a
convenient way.

*************** TODO Understand the following:

#+begin_src emacs-lisp :tangle no
        ;; (add-hook 'server-done-hook
        ;;        (lambda ()
        ;;          (shell-command "screen -r -X select `cat ~/tmp/emacsclient-caller`")))
#+end_src

and see
http://blog.jr0cket.co.uk/2012/10/using-emacs-24-server-on-mac-osx-for.html
for ideas about having the right =emacsclient= used to connect to the Emacs
server.

*************** END

* Printing Hard Copies

See function =--find-program= at http://www.visualco.de/src/elisp/.emacs.el.html
for finding executables.

You can print any buffer with =C-u M-x ps-print-buffer-with-faces <RET>=. Because
of the =C-u=, it will prompt for a file to place the PostScript into. You can
then convert PS to PDF, if so desired.

You can print without faces (i.e. no colour) with =ps-print-buffer=.

You may wish to set =ps-print-landscape= to =t=.

#+begin_src emacs-lisp
;;* 38 (info "(emacs)Printing")

(leuven--chapter leuven-chapter-38-printing "38 Printing Hard Copies"

  ;; print Emacs buffer on line printer
  ;; for {lpr,print}-{buffer,region}
  (with-eval-after-load "lpr"

    ;; name of program for printing a file
    (setq lpr-command (executable-find "enscript"))
                                    ; TODO Install `enscript'

    ;; list of strings to pass as extra options for the printer program
    (setq lpr-switches (list "--font=Courier8"
                             "--header-font=Courier10"
                             (format "--header=%s" (buffer-name))))

    ;; name of a printer to which data is sent for printing
    (setq printer-name
          (cond (running-ms-windows "//PRINT-SERVER/Brother HL-4150CDN") ; XXX
                (t t))))

  (defun leuven-ps-print-buffer-with-faces-query ()
    "Query user before printing the buffer."
    (interactive)
    (when (y-or-n-p "Are you sure you want to print this buffer? ")
      (ps-print-buffer-with-faces)))

  ;; generate and print a PostScript image of the buffer
  (GNUEmacs
    (when running-ms-windows
      ;; override `Print Screen' globally used as a hotkey by Windows
      (w32-register-hot-key (kbd "<snapshot>"))
      (global-set-key
        (kbd "<snapshot>") 'leuven-ps-print-buffer-with-faces-query)))

  (global-set-key
    (kbd "M-p") 'leuven-ps-print-buffer-with-faces-query)

  (XEmacs
    (setq toolbar-print-function 'ps-print-buffer-with-faces))

  ;; print text from the buffer as PostScript
  (with-eval-after-load "ps-print"

    (defvar gsprint-program
      (concat windows-program-files-dir "Ghostgum/gsview/gsprint.exe")
      "Defines the Windows path to the gsview executable.")

    (leuven--file-exists-and-executable-p gsprint-program)

    (if (and gsprint-program
             (executable-find gsprint-program))

        (progn
          ;; name of a local printer for printing PostScript files
          ;; adjusted to run Ghostscript
          (setq ps-printer-name t)

          ;; name of program for printing a PostScript file
          ;; tell Emacs where ghostscript print utility is located
          (setq ps-lpr-command gsprint-program)

          ;; list of extra switches to pass to `ps-lpr-command'
          ;; tell Ghostscript to query which printer to use
          (setq ps-lpr-switches '("-query"))) ;; '("-q" "-dNOPAUSE" "-dBATCH" "-sDEVICE=mswinpr2")

      (setq ps-printer-name "//PRINT-SERVER/Brother HL-4150CDN") ; XXX
      (setq ps-lpr-command "")
      (setq ps-lpr-switches '("raw")))

    ;; (setq ps-error-handler-message 'system)

    ;; size of paper to format for
    (setq ps-paper-type 'a4)
    (setq ps-warn-paper-type nil)

    ;; print in portrait mode
    (setq ps-landscape-mode nil)

    ;; (setq ps-print-control-characters nil)

    ;; number of columns
    (setq ps-number-of-columns 1)

    (setq ps-left-margin 40)
    (setq ps-right-margin 56)
    (setq ps-bottom-margin 22)
    (setq ps-top-margin 32)

    ;; Page layout: Header [file-name     2001-06-18 Mon]
    (setq ps-print-header-frame nil) ;; no box around the header
    ;; see http://www.emacswiki.org/emacs/PsPrintPackage-23
    (setq ps-header-frame-alist '((fore-color . "#CCCCCC")))
    (setq ps-header-lines 1)
    (setq ps-header-font-family 'Helvetica)
    ;; (setq ps-header-font-size 11)
    (setq ps-header-title-font-size 11)
    (defun ps-time-stamp-yyyy-mm-dd-aaa ()
      "Return date as \"2001-06-18 Mon\" (ISO date + day of week)."
      (format-time-string "%Y-%m-%d %a"))
    (setq ps-right-header '(ps-time-stamp-yyyy-mm-dd-aaa))

    ;; Page layout: Footer [                         n/m]
    (setq ps-footer-offset 14)
    (setq ps-footer-line-pad .50)
    (setq ps-print-footer t)
    (setq ps-print-footer-frame nil) ;; no box around the footer
    (setq ps-footer-frame-alist '((fore-color . "#666666")))
    (setq ps-footer-lines 1)
    (setq ps-footer-font-family 'Helvetica)
    (setq ps-footer-font-size 8)
    (setq ps-left-footer nil)
    (setq ps-right-footer (list "/pagenumberstring load")) ;; Page n of m

    (setq ps-font-family 'Courier) ;; see `ps-font-info-database'
    ;; legitimate values include Courier, Helvetica, NewCenturySchlbk,
    ;; Palatino and Times
    (setq ps-font-size 9.1)

    (setq ps-use-face-background t)

    (setq ps-line-spacing 3))

) ;; chapter 38 ends here
#+end_src

* Sorting Text

#+begin_src emacs-lisp
;;* 39 (info "(emacs)Sorting") Text

(leuven--chapter leuven-chapter-39-sorting "39 Sorting Text"

  ;; key binding
  (global-set-key
    (kbd "C-c ^") 'sort-lines)

) ;; chapter 39 ends here
#+end_src

* Saving Emacs Sessions

*************** TODO Check that there is no extra ~/.saves directory!

#+begin_src emacs-lisp
;;* 42 (info "(emacs)Saving Emacs Sessions")

(leuven--chapter leuven-chapter-42-saving-emacs-sessions "42 Saving Emacs Sessions"

  (idle-require 'saveplace)
  (with-eval-after-load "saveplace"

    ;; automatically save place in each file
    (setq-default save-place t) ;; default value for all buffers

    ;; name of the file that records `save-place-alist' value
    (setq save-place-file
          (convert-standard-filename "~/.emacs.d/.places"))
    ;;! a .txt extension would load Org at the time Emacs is killed (if not
    ;;! already loaded)!

    ;; do not make backups of master save-place file
    (setq save-place-version-control "never"))

) ;; chapter 42 ends here
#+end_src

* Hyperlinking and Navigation Features

#+begin_src emacs-lisp
;;* 45 (info "(emacs)Hyperlinking")

(leuven--chapter leuven-chapter-45-hyperlinking "45 Hyperlinking and Navigation Features"
#+end_src

#+begin_src emacs-lisp
;;** pass a URL to a WWW browser

  (leuven--section "pass a URL to a WWW browser")

  ;; default browser started when you click on some URL in the buffer
  (setq browse-url-browser-function
        (if (not (display-graphic-p))
            'w3m-browse-url
          (if running-ms-windows
              'browse-url-default-windows-browser
            'browse-url-generic)))
  ;; (setq browse-url-browser-function
  ;;       '(("file:///usr/share/doc/hyperspec/" . w3m-browse-url)
  ;;         ("emacswiki.org" . w3m-browse-url)
  ;;         ("lispdoc.com" . w3m-browse-url)
  ;;         ( "." . browse-url-firefox)))
  ;; that let me use `w3m' for EmacsWiki/Common Lisp documentation and
  ;; Firefox otherwise.

  ;; ;; name of the browser program used by `browse-url-generic'
  ;; (setq browse-url-generic-program
  ;;       (when (and (display-graphic-p)
  ;;                  (not running-ms-windows))
  ;;         (executable-find "firefox"))) ;; could be `google-chrome'

  (defun leuven--browse (url)
    "If prefix is specified, use the system default browser, else use the
  configured Emacs one."
    (require 'browse-url)
    (if current-prefix-arg
        ;; open in your desktop browser (firefox here)
        (when url (browse-url-default-browser url))
      ;; open using your Emacs browser (whatever that is configured to)
      (if url (browse-url url) (call-interactively 'browse-url))))

  (defun leuven-browse-url (&optional url)
    "Browse the URL passed in."
    (interactive)
    (require 'w3m)
    (require 'browse-url)
    (setq url (or url
                  (w3m-url-valid (w3m-anchor))
                  (browse-url-url-at-point)
                  (find-tag-default)))
    (setq url (read-string (format "URL \"%s\" :" url) url nil url))
    (leuven--browse url))
#+end_src

#+begin_src emacs-lisp
;;** Web search

  (leuven--section "Web search")

  (when t ;; (try-require 'browse-url)

    (defconst leuven--google-maxlen (* 32 7)
      "Maximum length of search string to send. This prevents you from
    accidentally sending a 5 MB query string.")

    (defun leuven-google-search ()
      "Prompt for a query in the minibuffer, launch the web browser and
    query Google."
      (interactive)
      (let ((query (read-from-minibuffer "Google Search: ")))
        (browse-url (concat "http://www.google.com/search?q="
                            (url-hexify-string query)))))

    ;; (defun google-it (search-string)
    ;;   "Search for SEARCH-STRING on Google."
    ;;   (interactive "sSearch for: ")
    ;;   (browse-url (concat "http://www.google.com/search?q="
    ;;                   (url-hexify-string
    ;;                     (encode-coding-string search-string 'utf-8)))))

    (defun leuven-google-search-word-at-point ()
      "Google the word at point."
      (interactive)
      (browse-url
       (concat "http://www.google.com/search?q=" (find-tag-default))))

    (defun leuven-google-search-region (prefix start end)
      "Create a search URL and send it to the web browser."
      (interactive "P\nr")
      (if (> (- end start) leuven--google-maxlen)
          (message "Search string too long!")
        (let ((query (buffer-substring-no-properties start end)))
          (browse-url
           (concat "http://www.google.com/search?q="
                   (url-hexify-string query))))))

    ;; (defun google-search-selection ()
    ;;   "Create a Google search URL and send it to your web browser."
    ;;   (interactive)
    ;;   (let (start end term url)
    ;;     (if (or (not (fboundp 'region-exists-p)) (region-exists-p))
    ;;         (progn
    ;;           (setq start (region-beginning)
    ;;                 end   (region-end))
    ;;           (if (> (- start end) leuven--google-maxlen)
    ;;               (setq term (buffer-substring start (+ start leuven--google-maxlen)))
    ;;             (setq term (buffer-substring start end)))
    ;;           (google-it term))
    ;;       (beep)
    ;;       (message "Region not active"))))


         (defun google (what)
           "Use Google to search for WHAT."
           (interactive "sSearch: ")
           (save-window-excursion
             (delete-other-windows)
             (let ((dir default-directory))
               (w3m-browse-url (concat "http://www.google.com/search?q="
                                       (w3m-url-encode-string what)))
               (cd dir)
               (recursive-edit))))
         (global-set-key
           (kbd "C-c g s") 'google)
#+end_src

If you know how to build the right url to the documentation of a given
operator, you can just replace the google url with the right one in the
following code:

# (defun w3m-active-region-or-url-at-point (&optional default=current)
#   "Return an active region or a url around the cursor.
# In Transient Mark mode, deactivate the mark.  If DEFAULT=CURRENT is
# non-nil, return the url of the current page by default."

#+begin_src emacs-lisp
  (defun pm/region-or-word (prompt)
    "Read a string from the minibuffer, prompting with PROMPT.

  If `transient-mark-mode' is non-nil and the mark is active,
  it defaults to the current region, else to the word at or before
  point. This function returns a list (string) for use in `interactive'."
    (list (read-string prompt (or (and (use-region-p)
                                       (buffer-substring-no-properties
                                        (region-beginning) (region-end)))
                                  (current-word)))))

  (defun pm/google (string)
    "Ask a WWW browser to Google STRING.

  Prompt for a string, defaulting to the active region or the current word at
  or before point."
    (interactive (pm/region-or-word "Google: "))
    (browse-url (concat "http://google.com/search?num=100&q=" string)))
#+end_src

(end of interrupt)

#+begin_src emacs-lisp
    (defvar leuven--google-prefix-map (make-sparse-keymap)
      "Keymap for my Google commands.")

    ;;     (global-set-key (kbd "M-s") 'leuven-google-search-region)

    (global-set-key
      (kbd "C-c g") leuven--google-prefix-map)

    (define-key leuven--google-prefix-map
      (kbd "g") 'leuven-google-search)

    (define-key leuven--google-prefix-map
      (kbd "w") 'leuven-google-search-word-at-point)

    (define-key leuven--google-prefix-map
      (kbd "r") 'leuven-google-search-region)
)
#+end_src

** Emacs-w3m

Emacs/W3 is dead, long live [[http://emacs-w3m.namazu.org/][Emacs-w3m]] (a terrific text-based web and file
browser).

For Win32, use the Cygwin version of the executable.

=w3m-browse-url= asks Emacs-w3m to browse a URL.

When JavaScript is needed or the "design" is just too bad, use an *external
browser*: you can open the current page in your graphical browser by hitting =M=
(bound to =w3m-view-url-with-external-browser=) -- at your own risk. For what
"risk" means, please see: =(info "(emacs-w3m)Gnus")=.

#+begin_src emacs-lisp
;;** Emacs-w3m

  (leuven--section "Emacs-w3m")

  ;; only use if `w3m' command is available on system
  (when (executable-find "w3m")

    ;; name of the executable file of the `w3m' command
    (setq w3m-command "w3m")
    ;; I don't want `/usr/bin/w3m' (which requires `cygwin-mount')

    ;; `w3m' slows down the startup process dramatically
    (unless (try-require 'w3m-autoloads)
      (autoload 'w3m "w3m"
        "Visit the WWW page using w3m." t)
      (autoload 'w3m-find-file "w3m"
        "Find a local file using emacs-w3m." t)
      (autoload 'w3m-browse-url "w3m"
        "Ask emacs-w3m to show a URL." t))

    (with-eval-after-load "w3m"
#+end_src

#+begin_src emacs-lisp
;;*** 3.1 Browsing Web Pages

      ;; go ahead, just try it
      (defun leuven-w3m-goto-url ()
        "Type in directly the URL to visit (avoiding to hit `C-k')."
        (interactive)
        (let ((w3m-current-url ""))
          (call-interactively 'w3m-goto-url)))

      ;; make w3m stop "stealing" my arrow keys, allowing to move the
      ;; cursor down the lines of an HTML email (in Gnus)
      (setq w3m-minor-mode-map nil)

      (define-key w3m-mode-map
        (kbd "U") 'leuven-w3m-goto-url)

      ;; fix inappropriate key bindings for moving from place to place in a
      ;; page (let the cursor keys behave normally, don't jump from link to
      ;; link)
      (define-key w3m-mode-map
        (kbd "<up>") 'previous-line)
      (define-key w3m-mode-map
        (kbd "<down>") 'next-line)
      (define-key w3m-mode-map
        (kbd "<left>") 'backward-char)
      (define-key w3m-mode-map
        (kbd "<right>") 'forward-char)

      (define-key w3m-mode-map
        (kbd "<tab>") 'w3m-next-anchor)

      ;; moving from page to page
      (define-key w3m-mode-map
        (kbd "F") 'w3m-view-next-page)

;;*** 3.5 Using Tabs

      (define-key w3m-mode-map
        (kbd "<C-tab>") 'w3m-next-buffer)
      (define-key w3m-mode-map
        (kbd "<C-S-tab>") 'w3m-previous-buffer)

      (defun w3m-new-tab ()
        (interactive)
        (w3m-copy-buffer nil nil nil t))

      (define-key w3m-mode-map
        (kbd "C-t") 'w3m-new-tab)

      (define-key w3m-mode-map
        (kbd "C-w") 'w3m-delete-buffer)
#+end_src

#+begin_src emacs-lisp
;;*** 5.1 General Variables

      ;; send referers only when both the current page and the target
      ;; page are provided by the same server
      (setq w3m-add-referer 'lambda)

      ;; home page
      (setq w3m-home-page "http://www.emacswiki.org/")

      ;; number of steps in columns used when scrolling a window
      ;; horizontally
      (setq w3m-horizontal-shift-columns 1)  ; 2

      ;; proxy settings
      (when (string= (upcase (system-name)) "PC3701")
        (setq w3m-command-arguments
                 (nconc w3m-command-arguments
                        '("-o" "http_proxy=proxy:8080"))))
                                 ; FIXME https_proxy for HTTPS support

      (setq w3m-no-proxy-domains '("localhost" "127.0.0.1"))

;;*** 5.2 Image Variables

      ;; always display images
      (setq w3m-default-display-inline-images t)

      ;; show favicon images if they are available
      (setq w3m-use-favicon t)

;;*** 5.4 Cookie Variables

      ;; functions for cookie processing
      (with-eval-after-load "w3m-cookie"

        ;; ask user whether accept bad cookies or not
        (setq w3m-cookie-accept-bad-cookies 'ask)

        ;; list of trusted domains
        (setq w3m-cookie-accept-domains
              '("google.com" "google.be"
                "yahoo.com" ".yahoo.com" "groups.yahoo.com"
                "www.dyndns.org")))

      ;; enable cookies (mostly required to use sites such as Gmail)
      (setq w3m-use-cookies t)

;;*** 5.14 Other Variables

      ;; list of content types, regexps (matching a url or a file
      ;; name), commands to view contents, and filters to override the
      ;; content type specified at first
      (setq w3m-content-type-alist
            (append '(("text/html" "\\.xhtml\\'" nil nil))
                    w3m-content-type-alist))

      ;; toggle a minor mode showing link numbers
      (when (try-require 'w3m-lnum)

        (defun leuven-w3m-go-to-link-number ()
          "Turn on link numbers and ask for one to go to."
          (interactive)
          (let ((active w3m-lnum-mode))
            (when (not active) (w3m-lnum-mode))
            (unwind-protect
                (w3m-move-numbered-anchor (read-number
                                           "Anchor number: "))
              (when (not active) (w3m-lnum-mode))
              (w3m-view-this-url))))

        (define-key w3m-mode-map
          (kbd "f") 'leuven-w3m-go-to-link-number)

        ;; enable link numbering mode by default
        (add-hook 'w3m-mode-hook 'w3m-lnum-mode))

      ))
#+end_src

*** 9.1 Turning Gnus into a web browser!

=nnshimbun= is a Gnus back end, but it is distributed with emacs-w3m, not Gnus,
exceptionally.

=Nnshimbun= allows you to turn Gnus into an exceptionally useful web browser.
You can skim through the articles on a newspaper's web server without having
to see all the advertisement. You can read articles in mailing list archives
as if you were subscribed to the list. You can also read submissions in
bulletin boards, etc...

*** EWW (Emacs Web Browser)

=eww= is the new web-browser for Emacs. See
http://lars.ingebrigtsen.no/2013/06/eww.html.

** Google Maps

#+begin_src emacs-lisp :tangle no
  (GNUEmacs
    ;; Google maps
    (try-require 'google-maps))
#+end_src

** Babel

#+begin_src emacs-lisp
;;** Babel

  (leuven--section "Babel")

  (when (locate-library "babel")

    (autoload 'babel "babel"
      "Use a web translation service to translate the message MSG." t)
    (autoload 'babel-region "babel"
      "Use a web translation service to translate the current region." t)
    (autoload 'babel-as-string "babel"
      "Use a web translation service to translate MSG, returning a string." t)
    (autoload 'babel-buffer "babel"
      "Use a web translation service to translate the current buffer." t)

    (defun leuven-babel-translate ()
      "Translate using many online translators."
      (interactive)
      (require 'babel)
      (let (source)
        (switch-to-buffer "*leuven--translate*")
        (erase-buffer)
        (yank)
        (setq source (buffer-substring-no-properties (point-min) (point-max)))
        (erase-buffer)
        (insert "--- Source ---\n\n")
        (insert source)
        (insert "\n\n\n--- Translation FR -> EN done by FreeTranslation ---\n\n")
        (insert (babel-work source "fr" "en" 'babel-free-fetch 'babel-free-wash))
        (insert "\n\n\n--- Translation EN -> FR done by FreeTranslation ---\n\n")
        (insert (babel-work source "en" "fr" 'babel-free-fetch 'babel-free-wash))))

    (global-set-key
      (kbd "<f7>") 'leuven-babel-translate))
)
#+end_src

* Other Amusements

#+begin_src emacs-lisp
;;* 46 Other (info "(emacs)Amusements")

(leuven--chapter leuven-chapter-46-amusements "46 Other Amusements"

  ;; define a default menu bar
  (with-eval-after-load "menu-bar"

    ;; get rid of the Games in the Tools menu
    (define-key menu-bar-tools-menu
      [games] nil))

) ;; chapter 46 ends here
#+end_src

* Customization

Emacs 24 custom themes allow loading multiple themes simultaneously. If you
don't want the previous theme to stay in effect, you will need to unload it
first.

Install Leuven Theme via the [[*Emacs%20Lisp%20Packages][Emacs Lisp Packages]] (or use the one bundled in
GNU Emacs 24.4)

#+begin_src emacs-lisp
;;* 48 (info "(emacs)Customization")

(leuven--chapter leuven-chapter-48-customization "48 Customization"

  (GNUEmacs24
    (ignore-errors
      (load-theme 'leuven t)))
#+end_src

** Color

You can govern the sort order of colors now such as HSV or RGB distance from a
particular color...

#+begin_src emacs-lisp
  ;; color sort order for `list-colors-display'
  (setq list-colors-sort '(rgb-dist . "#FFFFFF"))
#+end_src

** Color theme

#+begin_src emacs-lisp
  (XEmacs
    ;; the real color theme functions
    (when (try-require 'color-theme-autoloads)

      ;; `color-theme-print' allows to keep what you see

      ;; initialize the color theme package
      (if (fboundp 'color-theme-initialize)
          (color-theme-initialize))

      ;; color themes will be installed for all frames
      (setq color-theme-is-global t)

      ;; set my default color theme
      (when (try-require 'color-theme-leuven)
        (color-theme-leuven)))

    (setq options-save-faces t))
#+end_src

** Not sorted

#+begin_src emacs-lisp
  ;; ;; limit serving to catch infinite recursions for you before they
  ;; ;; cause actual stack overflow in C, which would be fatal for Emacs
  ;; (setq max-lisp-eval-depth 600) ;; 1000?

  ;; limit on number of Lisp variable bindings & unwind-protects
  (setq max-specpdl-size 3000) ;; XEmacs 21.5.29

  ;; speed up things by preventing garbage collections
  (setq gc-cons-threshold 3500000) ;; make Gnus fast
  ;; from (info "(gnus)FAQ 9-2")

  ;; don't display messages at start and end of garbage collection (as it
  ;; hides too many interesting messages)
  (setq garbage-collection-messages nil)
#+end_src

** Variables

#+begin_src emacs-lisp
;;** 48.3 (info "(emacs)Variables")

  (leuven--section "48.3 (emacs)Variables")

  ;; file local variables specifications are obeyed, without query --
  ;; RISKY!
  (setq enable-local-variables t)

  ;; obey `eval' variables -- RISKY!
  (setq enable-local-eval t)

  ;; record safe values for some local variables
  (setq safe-local-variable-values
        '((TeX-master . t)
          (ac-sources . (ac-source-words-in-buffer ac-source-dictionary))
          ;; (ac-user-dictionary-files . ("../dictionary.txt"))
          (flyspell-mode . -1)
          (flyspell-mode . 1)
          (ispell-local-dictionary . "american")
          (ispell-local-dictionary . "francais")
          (org-tags-column . -80)       ; org-issues.org
          (outline-minor-mode)
          (whitespace-style face tabs spaces trailing lines
                            space-before-tab::space newline indentation::space
                            empty space-after-tab::space space-mark tab-mark
                            newline-mark)))
#+end_src

Have a look at (info "(emacs)Directory Variables").

** Key Bindings

The keys =C-c LETTER= are reserved for user functions.

You can get a list of all the disabled functions by typing:

#+begin_src emacs-lisp :tangle no
M-: (let(lst)(mapatoms(lambda(x)(if(get x 'disabled)(push x lst))))lst) <RET>
#+end_src

#+begin_src emacs-lisp
;;** 48.4 Customizing (info "(emacs)Key Bindings")

  (leuven--section "48.4 Customizing (emacs)Key Bindings")
#+end_src

See as well Print keybindings (pkb).

#+begin_src emacs-lisp
  ;; print the key bindings in a tabular form
  (GNUEmacs
   (defun leuven-keytable (arg)
     "Print the key bindings in a tabular form."
     (interactive "sEnter a modifier string:")
     (with-output-to-temp-buffer "*Key table*"
       (let* ((i 0)
              (keys (list "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l"
                          "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x"
                          "y" "z" "<return>" "<down>" "<up>" "<right>"
                          "<left>" "<home>" "<end>" "<f1>" "<f2>" "<f3>"
                          "<f4>" "<f5>" "<f6>" "<f7>" "<f8>" "<f9>"
                          "<f10>" "<f11>" "<f12>" "1" "2" "3" "4" "5" "6"
                          "7" "8" "9" "0" "`" "~" "!" "@" "#" "$" "%" "^"
                          "&" "*" "(" ")" "-" "_" "=" "+" "\\" "|" "{" "["
                          "]" "}" ";" "'" ":" "\"" "<" ">" "," "." "/" "?"
                          ))
              (n (length keys))
              (modifiers (list "" "S-" "C-" "M-" "M-C-"))
              (k))
         (or (string= arg "") (setq modifiers (list arg)))
         (setq k (length modifiers))
         (princ (format " %-10.10s |" "Key"))
         (let ((j 0))
           (while (< j k)
             (princ (format " %-28.28s |" (nth j modifiers)))
             (setq j (1+ j))))
         (princ "\n")
         (princ (format "_%-10.10s_|" "__________"))
         (let ((j 0))
           (while (< j k)
             (princ (format "_%-28.28s_|"
                            "_______________________________"))
             (setq j (1+ j))))
         (princ "\n")
         (while (< i n)
           (princ (format " %-10.10s |" (nth i keys)))
           (let ((j 0))
             (while (< j k)
               (let* ((binding
                       (key-binding (read-kbd-macro
                                     (concat (nth j modifiers)
                                             (nth i keys)))))
                      (binding-string "_"))
                 (when binding
                   (if (eq binding 'self-insert-command)
                       (setq binding-string (concat "'" (nth i keys) "'"))
                     (setq binding-string (format "%s" binding))))
                 (setq binding-string
                       (substring binding-string 0
                                  (min (length binding-string) 28)))
                 (princ (format " %-28.28s |" binding-string))
                 (setq j (1+ j)))))
           (princ "\n")
           (setq i (1+ i)))
         (princ (format "_%-10.10s_|" "__________"))
         (let ((j 0))
           (while (< j k)
             (princ (format "_%-28.28s_|"
                            "_______________________________"))
             (setq j (1+ j))))))
     (delete-window)
     (setq truncate-lines t)))
#+end_src

#+begin_src emacs-lisp
  (defmacro rloop (clauses &rest body)
    (if (null clauses)
        `(progn ,@body)
      `(loop ,@(car clauses) do (rloop ,(cdr clauses) ,@body))))

  (defun leuven-all-bindings ()
    (interactive)
    (message "leuven-all-bindings: wait a few seconds please...")
    (let ((data
           (with-output-to-string
             (let ((bindings '()))
               (rloop ((for C in '("" "C-")) ;; Control
                       (for M in '("" "M-")) ;; Meta
                       (for A in '("" "A-")) ;; Alt
                       (for S in '("" "S-")) ;; Shift
                       (for H in '("" "H-")) ;; Hyper
                       (for s in '("" "s-")) ;; super
                       (for x from 32 to 127))
                      (let* ((k (format "%s%s%s%s%s%s%c" C M A S H s x))
                             (key (ignore-errors (read-kbd-macro k))))
                        (when key
                          (push
                           (list k
                                 (format "%-12s  %-12s  %S\n" k key
                                         (or
                                          ;; (string-key-binding key)
                                          ;; What is this string-key-binding?
                                          (key-binding key))))
                           bindings))))
               (dolist (item
                        (sort bindings
                              (lambda (a b)
                                (or (< (length (first a))
                                       (length (first b)))
                                    (and (= (length (first a))
                                            (length (first b)))
                                         (string< (first a)
                                                  (first b)))))))
                 (princ (second item)))))))
      (switch-to-buffer (format "Key bindings in %s" (buffer-name)))
      (erase-buffer)
      (insert data)
      (goto-char (point-min))
      (values)))
#+end_src

** Syntax Table

The syntax table contains information that tells Emacs how to operate on text,
words, sentences etc. It will make Emacs know enough about all the symbols in
a buffer. Syntax table is used for example for:

- commands like =forward-word= (=M-f=) or =backward-kill-word= (=M-DEL=),
- spell-checking of words,
- expansion commands of abbrevs,
- etc.

Evaluate =current-word= and see whether characters such as =-= and =_= are
considered part of the word (depending on the current major mode).

#+begin_src emacs-lisp
;;** 48.5 The (info "(emacs)Syntax") Table

  (leuven--section "48.5 The (emacs)Syntax Table")

  ;; now '-' is not considered a word-delimiter
  ;; (add-hook 'emacs-lisp-mode-hook
  ;;           (lambda ()
  ;;             (modify-syntax-entry ?- "w")))
#+end_src

#+begin_src emacs-lisp
) ;; chapter 48 ends here
#+end_src

* Emacs Display

#+begin_src emacs-lisp
;;* Emacs Display

(leuven--chapter leuven-chapter-XX-emacs-display "XX Emacs Display"
#+end_src

** Faces

You can get text properties of any char by typing =C-u C-x ==.

Under Windows, you can get the current *font* by typing =(w32-select-font)=
followed by =C-x C-e=.

You can find the current *font string* by typing
=M-x ielm <RET> (frame-parameters) <RET>= -- see the line =font=.

To check if some font is available in Emacs do following:

1. Switch to the =*scratch*= buffer.

2. Type
   =(prin1-to-string (x-list-fonts "font-you-want-to-check or pattern"))=.

3. Place the cursor after the last closing paren and hit =C-j=. List of
   the names of available fonts matching given pattern will appear in the
   current buffer (=*scratch*=).

4. For listing of all available fonts, use
   =(prin1-to-string (x-list-fonts "*"))=
   or
   =(dolist (i (x-list-fonts "*")) (princ i) (terpri))=
   for a better output.

Format is =-a-b-c-d-e-f-g-h-i-j-k-l-= where:

- a ::
     foundry

- b ::
     font family <<<

- c ::
     weight

     Valid options: =bold=, =demibold=, =light=, =medium=, =normal=.

- d ::
     slant

     Valid options: =i= for italic and =r= for roman.

- e ::
     set width

     Ignored by NT-Emacs.

- f ::
     pixels

     Nominal font height in pixels. (Eg. 13 pixels roughly corresponds to 10
     points (a point is 1/72 of an inch) on a 96dpi monitor, so the font spec
     above is selecting a 10 point bold Courier font)

- g ::
     points in tenths of a point

     10 point is 100

- h ::
     horiz resolution in dpi

     I think these numbers represent the "design resolution" of the font - on
     X, fonts are typically designed for 75dpi or 100dpi screens (under
     Windows,most monitors are assumed to be 96dpi I believe). NT-Emacs
     ignores these values.

- i ::
     vertical resolution in dpi

     I think these numbers represent the "design resolution" of the font - on
     X, fonts are typically designed for 75dpi or 100dpi screens (under
     Windows,most monitors are assumed to be 96dpi I believe). NT-Emacs
     ignores these values.

- j ::
     spacing

     Spacing as in mono-spaced or proportionally spaced. Values are =c=
     (constant) or =m= (monospace) to mean fixed-width or =p= for proportionally
     spaced.

- k ::
     average width in tenths of a pixel

- l ::
     character set

     NT-Emacs understands: =ansi=, =oem=, =symbol= to refer to the standard Windows
     character sets (the first two, at least, are locale dependant). =iso8859=
     and =iso8859-1= are accepted as synonyms for ansi.

Under Linux, use the =xfontsel= utility (or the command-line =xlsfonts=) to try
out different fonts. After choosing a font, click the select button in
=xfontsel= window. This will copy font name you choose to copy & paste buffer.

Now Emacs should start with that font.

#+begin_src emacs-lisp
;;** (info "(elisp)Faces")

  (leuven--section "Faces")

  ;; enable more bold and italic fonts to be displayed
  (setq w32-enable-synthesized-fonts t)
#+end_src

For reasons unknown to me, Emacs takes a long time to change fonts in an X
environment.

Rather than using =(set-default-font ...)= in ~.emacs~, stick the font definition
in your ~.Xresources~ file (key 'Emacs*font') and then use =xrdb -load= to
activate it. You will find that startup time is greatly improved!

Edit your =~/.Xresources= file to have a line with "Emacs.font". Then do a =xrdb
-merge ~/.Xresources= or restart your X11 to validate the modification. I let
Emacs do this for me:

#+begin_src emacs-lisp
  (defun merge-x-resources ()
    (let ((file (file-name-nondirectory (buffer-file-name))))
      (when (or (string= file ".Xdefaults")
                (string= file ".Xresources"))
        (start-process "xrdb" nil "xrdb" "-merge" (buffer-file-name))
        (message (format "Merged %s into X resource database" file)))))

  (add-hook 'after-save-hook 'merge-x-resources)
#+end_src

#+begin_src emacs-lisp
  ;; allow any scalable font
  (when running-ms-windows
    (setq scalable-fonts-allowed t))
#+end_src

*** UTF-8

Fonts that have a good UTF-8 coverage are:

- DejaVu Sans Mono
- DejaVu Sans
- FreeMono (FreeSans, FreeSerif)
- Monospace

None of them has all four variants, some have regular (medium) and bold or
light and regular, one regular and oblique.

*** Anti-aliasing

To see if anti-aliasing is active, use =xmag= (under Linux) or any of the other
magnifier applications. The fonts should have gray edges.

*** Adjust the height of the default face

There are a few commands to adjust the font sizes:

- =C-x C-+= ::
     Increase the default face height by one step

- =C-x C--= ::
     Decrease the default face height by one step

- =C-x C-0= ::
     Resets to defaults

#+begin_src emacs-lisp
)
#+end_src

** Images
   :PROPERTIES:
   :ID:       9432da83-fa9d-4466-a4da-57f33d662bbd
   :END:

#+begin_src emacs-lisp
;;** 38.16 (info "(elisp)Images")
#+end_src

How do I get image support? See =image-library-alist=, a list of image types vs
external libraries needed to display them.

#+begin_src emacs-lisp :tangle no
(describe-variable 'image-library-alist)
#+end_src

#+results:
#+begin_example
image-library-alist is a variable defined in `C source code'.
Its value is shown below.

  This variable is potentially risky when used as a file local variable.

Documentation:
Alist of image types vs external libraries needed to display them.

Each element is a list (IMAGE-TYPE LIBRARY...), where the car is a symbol
representing a supported image type, and the rest are strings giving
alternate filenames for the corresponding external libraries.

Emacs tries to load the libraries in the order they appear on the
list; if none is loaded, the running session of Emacs won't
support the image type.  Types 'pbm and 'xbm don't need to be
listed; they are always supported.

Value: ((xpm "libxpm.dll" "xpm4.dll" "libXpm-nox4.dll")
 (png "libpng14-14.dll" "libpng14.dll")
 (jpeg "jpeg62.dll" "libjpeg.dll" "jpeg-62.dll" "jpeg.dll")
 (tiff "libtiff3.dll" "libtiff.dll")
 (gif "giflib4.dll" "libungif4.dll" "libungif.dll")
 (svg "librsvg-2-2.dll")
 (gdk-pixbuf "libgdk_pixbuf-2.0-0.dll")
 (glib "libglib-2.0-0.dll")
 (gobject "libgobject-2.0-0.dll"))

#+end_example

If you use compiled Emacs binaries (available on Gnu), eventually, copy those
DLLs (=libpng14-14.dll=, for example) from an old EmacsW32 installation to your
Emacs =bin= directory, and restart Emacs for image support to be enabled.

If you use Cygwin Emacs, install =libpng= via Cygwin as well.

You can do:

#+begin_src emacs-lisp :results silent :tangle no
(image-type-available-p 'png)
#+end_src

to check if you have =png= image support in your Emacs.

* Calc

=C-x *= invokes the GNU Emacs Calculator.

** Introduction

*** Basic Commands

Start the Calc: =C-x * c=.

*** "Quick Calculator" Mode

Run the Calculator in the minibuffer: =C-x * q= (=M-x quick-calc=).

** Embedded Mode

Try the Embedded mode of Calc: =C-x * e= (no need to mark the region).

Similar commands: in place of =e=,

- =w= ::
     start Embedded mode on the current "word".

- =j= ::
     operate on *assignments*.

You need to type =C-x * e= again to exit the Embedded mode.

* IRC client for Emacs

See [[http://en.wikipedia.org/wiki/List_of_IRC_commands][List of Internet Relay Chat commands]]:
- =/whois=
- =/leave=

#+begin_src emacs-lisp :tangle no
;;* Emacs IRC client

;; Other IRC for Emacs: rcirc, circe, bitlbee, liece, riece, zenirc, erc
;; Circe is advised by Tassilo (contributor)

  (autoload 'circe "circe"
    "Connect to an IRC server." t)

  ;; connect to the Freenode network
  (defun leuven-irc-connect ()
    "Connect to Freenode."
    (interactive)
    (circe "irc.freenode.net" "6667" "freenode"))

  ;; ... upon hitting `C-c i'
  (global-set-key
    (kbd "C-c i")
    (lambda ()
      (interactive)
      (switch-or-start 'leuven-irc-connect
                       "irc.freenode.net:6667")))

  (with-eval-after-load "circe"

;;** 1 Basics

    ;; default channels to join whenever connecting to Freenode
    (setq circe-server-auto-join-channels
          '(("^freenode$"
             ;; "#emacs"
             ;; "#gnus"
             ;; "#latex"
             ;; "#ledger"
             "#org-mode"
             ;; "#stumpwm"
             ;; "#zsh"
             "#xemacs"
             )))

;;** 2 Reference

;;*** 2.3 Configuration

    ;; default nick
    (setq circe-default-nick "john_doe")

    ;; your "real name" on IRC
    (setq circe-default-realname "John Doe")

    ;; authentication info
    (setq freenode-passwd "")
    (setq circe-nickserv-passwords
          `(("freenode" ,freenode-passwd)))

;;** 3 Fighting Information Overload

;;*** 3.1 Channels

    ;; When other people say things in buffers that are currently buried (no
    ;; window is showing them), the mode line will now show you the
    ;; abbreviated channel or nick name. Use `C-c C-SPC' to switch to these
    ;; buffers.

;;*** 3.3 Keywords

    ;; list of keywords to highlight
    (setq lui-highlight-keywords
          '(
            ;; "[^<]vauban"
            "org" "beamer" "ledger" "tikz"))

    ;; add IRC color support to LUI
    (when (try-require 'lui-irc-colors)
      (add-to-list 'lui-pre-output-hook 'lui-irc-colors))

;;** 4 Hacking and Tweaking

;;*** 4.2 Using fly spell mode

    ;; check if `ispell-program-name' seems correct
    (when (ispell-check-program-name)
      (setq lui-flyspell-p t)
      (setq lui-flyspell-alist '(("." "american"))))

;;** Others

    (setq circe-highlight-nick-type 'occurrence)

    (when (try-require 'circe-highlight-all-nicks)
      (enable-circe-highlight-all-nicks))

    ;; format for messages to queries or channels
    (setq circe-format-self-say "<{nick}> {body}")

    ;; truncate the buffer (at the top) if it grows too much
    (setq lui-max-buffer-size 30000)

    ;; column at which Lui should break output
    (setq lui-fill-column 79)

    ) ;; eval-after-load "circe" ends here
#+end_src

#+begin_src emacs-lisp :tangle no
  ;; Jabber (GTalk)
  (when (try-require 'jabber-autoloads-XXX)
    (setq jabber-account-list '(("john.doe@gmail.com"
                                 (:network-server . "talk.google.com")
                                 (:connection-type . ssl)
                                 (:port . 443))))

    (setq jabber-history-enabled t)

    (setq jabber-use-global-history nil)

    (setq jabber-history-dir "~/.emacs.d/jabber")

    (setq jabber-vcard-avatars-retrieve nil)

    (setq jabber-chat-buffer-show-avatar nil))
#+end_src

* Utilities

** Emacs Speaks Statistics (ESS)

http://ess.r-project.org/Manual/ess.html

To run statistical processes under ESS, Windows users will need to make sure
that the directories for =R= and =Rterm= are in their =PATH= environment variable.

Start an R session with =M-x R=.

#+begin_src emacs-lisp
  (leuven--section "Utilities -- ESS")

  (add-to-list 'auto-mode-alist '("\\.[rR]\\'" . R-mode))

  (autoload 'R "ess-site"
    "Call 'R', the 'GNU S' system from the R Foundation." t)

  (autoload 'R-mode "ess-site"
    "Major mode for editing R source." t)
#+end_src

Customize variables for ESS (set these variables *before* loading ~ess-site~).

#+begin_src emacs-lisp
  ;; don't request the process directory each time R is run
  (setq ess-ask-for-ess-directory nil)

  ;; ;; add to list of prefixes recognized by ESS
  ;; (setq ess-r-versions '("R-2.15.2"))   ; R-current
  ;; ;; matching versions will appear after doing M-x R <tab> <tab>
#+end_src

#+begin_src emacs-lisp
  ;; ESS: Emacs Speaks Statistics
  (with-eval-after-load "ess-site"

    ;; use eldoc to report R function names
    (require 'ess-eldoc)
    (add-hook 'inferior-ess-mode-hook 'ess-use-eldoc)
)
#+end_src

#+begin_src emacs-lisp :tangle no
  (global-set-key
    (kbd "M--") 'ess-smart-underscore)

  ;; Use `<S-RET>' to split window & launch R (if not running), execute
  ;; highlighted region (if R running & area highlighted), or execute current
  ;; line (and move to next line, skipping comments). Nice.
  ;;
  ;; See http://www.emacswiki.org/emacs/EmacsSpeaksStatistics,
  ;; FelipeCsaszar. Adapted to split vertically instead of
  ;; horizontally.

  ;; XXX This should be useless, at least if R code is well written
  ;; inside Org documents!
  (defun leuven--ess-start-R ()
    (interactive)
    (let (w1 w1name w2)
      (if (not (member "*R*"
                       (mapcar (function buffer-name) (buffer-list))))
          (progn
            (delete-other-windows)
            (setq w1 (selected-window))
            (setq w1name (buffer-name))
            (setq w2 (split-window w1 nil t))
            (R)
            (set-window-buffer w2 "*R*")
            (set-window-buffer w1 w1name)))))

  (defun leuven-ess-eval ()
    (interactive)
    (leuven--ess-start-R)
    (if (use-region-p)
        (call-interactively 'ess-eval-region)
      (call-interactively 'ess-eval-line-and-step)))

  (add-hook 'ess-mode-hook
            (lambda ()
              (local-set-key
                (kbd "<S-return>") 'leuven-ess-eval)))

  (add-hook 'inferior-ess-mode-hook
            (lambda ()
              (local-set-key
                (kbd "<C-up>") 'comint-previous-input)
              (local-set-key
                (kbd "<C-down>") 'comint-next-input)))
#+end_src

Get info for object at point, and display it in an electric buffer with the
command =ess-describe-object-at-point= (bound to =C-c C-d C-e=, repeat =C-e= or =e= to
cycle between =str()=, =head()=, =tail()= and =summary()=). Use =other-window= to switch
to =*ess-describe*= window.

It was inspired by Erik Iverson's =ess-R-object-tooltip=.

* Emacs and Microsoft Windows/MS-DOS

Eventually have a look as well at =input-decode-map=.

#+begin_src emacs-lisp
;;* App G Emacs and (info "(emacs)Microsoft Windows/MS-DOS")

(leuven--chapter leuven-chapter-AppG-ms-dos "Appendix G Emacs and MS-DOS"

  ;; divide key (needed in GNU Emacs for Windows)
  (GNUEmacs
    (global-set-key
      (kbd "<kp-divide>") (kbd "/")))

  ;; numeric keypad (needed in XEmacs for Windows)
  (XEmacs
    ;; keys to the right of the regular keyboard
    (define-key key-translation-map [kp-divide]     [?/])
    (define-key key-translation-map [kp-multiply]   [?*])
    (define-key key-translation-map [kp-subtract]   [?-])
    (define-key key-translation-map [kp-add]        [?+])
    (define-key key-translation-map [kp-enter]     [?\r])
    (define-key key-translation-map [kp-decimal]    [?.])

    ;; keys with digits
    (define-key key-translation-map [kp-0]          [?0])
    (define-key key-translation-map [kp-1]          [?1])
    (define-key key-translation-map [kp-2]          [?2])
    (define-key key-translation-map [kp-3]          [?3])
    (define-key key-translation-map [kp-4]          [?4])
    (define-key key-translation-map [kp-5]          [?5])
    (define-key key-translation-map [kp-6]          [?6])
    (define-key key-translation-map [kp-7]          [?7])
    (define-key key-translation-map [kp-8]          [?8])
    (define-key key-translation-map [kp-9]          [?9])

    ;; additional keypad duplicates of keys ordinarily found elsewhere
    (define-key key-translation-map [kp-left]     [left])
    (define-key key-translation-map [kp-right]   [right])
    (define-key key-translation-map [kp-up]         [up])
    (define-key key-translation-map [kp-down]     [down])
    (define-key key-translation-map [kp-begin]   [begin])
    (define-key key-translation-map [kp-home]     [home])
    (define-key key-translation-map [kp-end]       [end])
    (define-key key-translation-map [kp-next]     [next])
    (define-key key-translation-map [kp-prior]   [prior])
    (define-key key-translation-map [kp-insert] [insert])
    (define-key key-translation-map [kp-delete] [delete]))

) ;; chapter G ends here
#+end_src

* Reporting Bugs

To get a backtrace when a specific regexp is displayed in the echo area
(through calls to message), set the variable =debug-on-message=.

#+begin_src emacs-lisp
;; Recovery from Problems

;;* Reporting Bugs

(leuven--chapter leuven-chapter-99-debugging "99 Debugging"

  ;; get the backtrace when uncaught errors occur
  (setq debug-on-error nil))            ; was set to `t' at beginning of buffer
#+end_src

#+begin_src emacs-lisp
(when (and (string-match "GNU Emacs" (version))
           leuven-load-verbose)
  (ad-disable-advice 'message 'before 'leuven-when-was-that)
  (ad-update 'message))
#+end_src

#+begin_src emacs-lisp
(when leuven-load-verbose
  (message "| Chapter | Time |")
  (message "|---------+------|")
  (mapcar (lambda (el)
            (message el))
          (nreverse leuven--load-times-list))
  (message "|---------+------|")
  (message "|         | =vsum(@-I..@-II) |"))
#+end_src

#+begin_src emacs-lisp
;; warn that some packages were missing
(when leuven-load-verbose
  (dolist (pkg leuven--missing-packages)
    (message "(warning) Package `%s' not found" pkg)))

(message "Loading `%s'...done (in %.3f s)"
         load-file-name
         (- (float-time) leuven-before-time))
(sit-for 0.3)
#+end_src

#+begin_src emacs-lisp :tangle no
(let ((elapsed (float-time (time-subtract (current-time)
                                          emacs-start-time))))
  (message "Loading `%s'...done (%.3fs)" load-file-name elapsed))

(add-hook 'after-init-hook
          `(lambda ()
             (let ((elapsed (float-time (time-subtract (current-time)
                                                       emacs-start-time))))
               (message "Loading %s...done (%.3fs) [after-init]"
                        ,load-file-name elapsed)))
  t)
#+end_src

#+begin_src emacs-lisp :tangle no
(message "Emacs initialization: %s" (emacs-init-time))
#+end_src

#+begin_src emacs-lisp :noweb yes
(message "* --[ Loaded Emacs Leuven <<time-stamp()>>]--")

(provide 'emacs-leuven)


;; This is for the sake of Emacs.
;; Local Variables:
;; coding: utf-8
;; eval: (when (locate-library "rainbow-mode") (require 'rainbow-mode) (rainbow-mode))
;; ispell-local-dictionary: "american"
;; End:

;;; emacs-leuven.el ends here
#+end_src

* Startup time
  :PROPERTIES:
  :tangle:   no
  :END:

** Context

Identify what parts of your =.emacs= take so long. You can do this e.g. by
starting Emacs with =emacs -q=, set up your =load-path=, and then evaluate

#+begin_src emacs-lisp
(benchmark-run
  (require 'some-package))
#+end_src

The first number appearing in the echo area will be the time needed to run
that command.

Use autoloads, which delay the loading of the complete package until one of
the interactive functions is used.

If you want to set options which need to be evaluated after a package is
loaded, you can use =eval-after-load=.

** Timings from my system

After much optimization...

  $ time emacs -f kill-emacs
  real    0m0.157s
  user    0m0.140s
  sys     0m0.012s
  $ time emacs -q -f kill-emacs
  real    0m0.137s
  user    0m0.116s
  sys     0m0.016s
  $ time emacs -Q -f kill-emacs
  real    0m0.051s
  user    0m0.028s
  sys     0m0.020s

#+begin_src sh
time emacs -f kill-emacs 2>&1
#+end_src

#+begin_src sh
time emacs -q -f kill-emacs 2>&1
#+end_src

#+begin_src sh
time emacs -Q -f kill-emacs 2>&1
#+end_src

Note that your first test is going to be dramatically slower than subsequent
tests.

# This is for the sake of Emacs.
# Local Variables:
# coding-system-for-write: utf-8-unix
# End:

# emacs-leuven.txt ends here
