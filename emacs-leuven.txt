# Hey Emacs, this is a -*- org -*- file ...
#+TITLE:     Emacs-Leuven
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:  emacs, dotfile, config
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:2
#+EXCLUDE_TAGS: noexport

#+PROPERTY:  header-args :eval never :padline yes :tangle yes

#+SETUPFILE: ~/org/theme-readtheorg.setup

* Evaluating the current setup

To evaluate the current setup you'll need to launch Emacs in a special way.
Do so by issuing the following commands:

#+begin_src shell :tangle no
git clone https://github.com/fniessen/emacs-leuven
cd emacs-leuven
emacs -Q -l ./emacs-leuven.el
#+end_src

You are now running my "improved" Emacs default experience.

* Description

Emacs can be very difficult for the beginner, as many of the default choices may
seem (and sometimes are) ugly or awkward.

But -- that's the joy of Emacs -- nearly everything can be adjusted!  Hence,
this set of customizations (from one pathological Emacs tweaker) to "short-cut"
that initial process.

Quotations:

- "Show me your ~/.emacs and I will tell you who you are." \\
  -- Bogdan Maryniuk

- "Emacs is like a laser guided missile.  It only has to be slightly
  mis-configured to ruin your whole day." \\
  -- Sean McGrath

- "While any text editor can save your files, only Emacs can save your soul." \\
  -- Per Abrahamsen

* Header

#+name: current-time
#+begin_src emacs-lisp :eval yes :results silent :tangle no :exports none
(format-time-string "%Y%m%d.%H%M")
#+end_src

#+begin_src emacs-lisp :noweb yes
;;; emacs-leuven.el --- Emacs configuration file with more pleasant defaults

;; Copyright (C) 1999-2020 Fabrice Niessen

;; Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
;; URL: https://github.com/fniessen/emacs-leuven
;; Version: <<current-time()>>
;; Keywords: emacs, dotfile, config

;;
;;    ___ _ __ ___   __ _  ___ ___
;;   / _ \ '_ ` _ \ / _` |/ __/ __|
;;  |  __/ | | | | | (_| | (__\__ \
;; (_)___|_| |_| |_|\__,_|\___|___/
;;

;; This file is NOT part of GNU Emacs.

;; This file is free software: you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation, either version 3 of
;; the License, or (at your option) any later version.
;;
;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this file. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Emacs 24.4+ configuration file with many packages already enabled and a more
;; pleasant set of defaults.
;;
;; Operating systems: supposed to work both for Windows and for Linux.
;;
;; Minimal .emacs configuration file:
;;
;;     (add-to-list 'load-path "/path/to/emacs-leuven/")
;;     (require 'emacs-leuven)
;;
;; To get more debug info about the packages getting loaded, add the following
;; line before requiring Emacs-Leuven.
;;
;;     ;; Show messages describing progress of loading Emacs-Leuven.
;;     (setq leuven-verbose-loading t)
;;
;; To avoid being questioned about packages to add to your local Emacs
;; installation (though, I think you should install them), add the following
;; line before requiring Emacs-Leuven.
;;
;;     ;; Do not (try to) install extra Emacs packages.
;;     (setq package-selected-packages nil)
;;
;; To install all the extra packages used hereunder, without being questioned,
;; add the following line before requiring Emacs-Leuven.
;;
;;     ;; Install all extra Emacs packages without asking for confirmation.
;;     (setq leuven-install-all-missing-elpa-packages t)
;;
;; For help on the Emacs Editor, see (info "(emacs)")  <== `C-x C-e' here!

#+end_src

* Code

Some things are "activated" by default in =lisp/loaddefs.el=.

#+begin_src emacs-lisp
;;; Code:

;; This file is only provided as an example.  Customize it to your own taste!
#+end_src

* Pre-init

** Startup Time

#+begin_src emacs-lisp
;; Time the loading of Emacs Leuven.  Keep this on top of your .emacs.
(defconst leuven--start-time (current-time)
  "Value of `current-time' before loading the Emacs-Leuven library.")
#+end_src

** GNU Emacs Internals: Garbage Collection

By default Emacs will initiate GC every 0.76 MB allocated (~gc-cons-threshold~ ==
800,000 B).

If you have a modern machine, I encourage you to add the following:

#+begin_src emacs-lisp
;; Speed up things by preventing garbage collections.
(setq gc-cons-threshold most-positive-fixnum)
(add-hook 'after-init-hook
          #'(lambda ()
              (garbage-collect)
(message "XXX Set GC back to initial value XXX")
(sit-for 2)
              (setq gc-cons-threshold
                    (car (get 'gc-cons-threshold 'standard-value)))))

;; Don't display messages at start and end of garbage collection (as it hides
;; too many interesting messages).
(setq garbage-collection-messages nil)
#+end_src

* Init

#+begin_src emacs-lisp :noweb yes
(defconst leuven--emacs-version "<<current-time()>>"
  "Emacs-Leuven version (date of the last change).")

(message "* --[ Loading Emacs-Leuven %s]--" leuven--emacs-version)
#+end_src

#+begin_src emacs-lisp
(defmacro measure-time (message &rest body)
  "Measure the time it takes to evaluate BODY."
  `(let ((start (current-time)))
     ,@body
     (message "[__%s (in %.02f s)___________________________]"
              ,message (float-time (time-since start)))))
#+end_src

#+begin_src emacs-lisp
;;; User Customizable Internal Variables

(defgroup leuven nil
  "Set of Emacs customizations (better defaults)."
  :group 'convenience
  :group 'text)

(defcustom leuven-verbose-loading nil
  "If non-nil, means show messages describing progress of loading Emacs-Leuven."
  :group 'emacs-leuven
  :type 'integer)
#+end_src

#+begin_src emacs-lisp
(when (and (string-match "GNU Emacs" (version))
           leuven-verbose-loading)
  (defadvice message (before leuven-when-was-that activate)
    "Add time stamps to `message' output."
    (ad-set-arg 0 (concat (format-time-string "[%Y-%m-%d %T.")
                          (substring (format-time-string "%N") 0 3)
                          (format-time-string "] ")
                          (ad-get-arg 0)))))
#+end_src

#+begin_src emacs-lisp
;; Allow quick include/exclude of setup parts -- DO NOT EDIT the DEFVAR!
(defvar leuven-load-chapter-0-environment t) ; required
(defvar leuven-load-chapter-0-loading-libraries t) ; required
(defvar leuven-load-chapter-0-debugging t)
(defvar leuven-load-chapter-48-packages t)
(defvar leuven-load-chapter-1-screen t)
(defvar leuven-load-chapter-6-exiting t)
(defvar leuven-load-chapter-7-basic t)
(defvar leuven-load-chapter-8-minibuffer t)
(defvar leuven-load-chapter-10-help t)
(defvar leuven-load-chapter-11-mark t)
(defvar leuven-load-chapter-12-killing t)
(defvar leuven-load-chapter-13-registers t)
(defvar leuven-load-chapter-14-display t)
(defvar leuven-load-chapter-15-search t)
(defvar leuven-load-chapter-16-fixit t)
(defvar leuven-load-chapter-17-keyboard-macros t)
(defvar leuven-load-chapter-18-files t)
(defvar leuven-load-chapter-19-buffers t)
(defvar leuven-load-chapter-20-windows t)
(defvar leuven-load-chapter-21-frames t)
(defvar leuven-load-chapter-22-international t)
(defvar leuven-load-chapter-23-major-and-minor-modes t)
(defvar leuven-load-chapter-24-indentation t)
(defvar leuven-load-chapter-25-text t)
(defvar leuven-load-chapter-25.11-tex-mode t)
(defvar leuven-load-chapter-26-programs t)
(defvar leuven-load-chapter-27-building t)
(defvar leuven-load-chapter-28-maintaining t)
(defvar leuven-load-chapter-29-abbrevs t)
(defvar leuven-load-chapter-30-dired t)
(defvar leuven-load-chapter-31-calendar-diary t)
(defvar leuven-load-chapter-32-sending-mail t)
(defvar leuven-load-chapter-34-gnus t)
(defvar leuven-load-chapter-36-document-view t)
(defvar leuven-load-chapter-38-shell t)
(defvar leuven-load-chapter-39-emacs-server t)
(defvar leuven-load-chapter-40-printing t)
(defvar leuven-load-chapter-41-sorting t)
(defvar leuven-load-chapter-44-saving-emacs-sessions t)
(defvar leuven-load-chapter-46-hyperlinking t)
(defvar leuven-load-chapter-47-amusements t)
(defvar leuven-load-chapter-49-customization t)
(defvar leuven-load-chapter-AppG-ms-dos t)
(defvar leuven-load-chapter-XX-emacs-display t)
(defvar leuven-load-chapter-99-debugging t)
#+end_src

#+begin_src emacs-lisp
(defvar leuven--load-times-list nil
  "List of chapters and time to load them.")

(defmacro leuven--chapter (chapterid chaptername &rest body)
  "When CHAPTERID is not nil, report as CHAPTERNAME the evaluation of BODY.
Save execution times in the global list `leuven--load-times-list'."
  `(when ,chapterid
     (let (before-chapter-time
           this-chapter-time)
       (when leuven-verbose-loading
         (message "[** %s]" ,chaptername))
       (setq before-chapter-time (float-time))
       (setq leuven--before-section-time (float-time)) ; Init section time.
       (progn ,@body)
       (leuven--section (concat "[" ,chaptername " ends here]") 'end-of-chapter)
                                        ; Add fake closing section.
       (setq this-chapter-time
             (format "%.2f" (- (float-time) before-chapter-time)))
       (add-to-list 'leuven--load-times-list
                    (concat "| " ,chaptername " "
                            "| " this-chapter-time " |")))))

(defvar leuven--before-section-time (float-time)
  "Value of `float-time' before loading some section.")

(defun leuven--section (sectionname &optional end-of-chapter)
  "Report under SECTIONNAME the time taken since it was last saved.
Last time is saved in global variable `leuven--before-section-time'."
  (let ((this-section-time (- (float-time)
                              leuven--before-section-time)))
    (when leuven-verbose-loading
      (when (not (equal this-section-time 0.00))
        (message "[    Section time: %.2f s]" this-section-time))
      (unless end-of-chapter (message "[*** %s]" sectionname)))
    ;; For next one.
    (setq leuven--before-section-time (float-time))))
#+end_src

* Loading Libraries of Lisp Code for Emacs

Adding the right Lisp directories to your ~load-path~ (list of directories where
Emacs Lisp libraries -- ~.el~ and ~.elc~ files -- are installed) must be the very
*first thing* in your =.emacs= file, before the first time packages are required, to
make sure that you're not picking up bits and pieces from older files (bundled
with Emacs, and loaded before the path to the *newest* versions are set).

The most important directories are the last to be added to ~load-path~ (so that
they become the first of the list)!

Use ~M-x list-load-path-shadows RET~ to display a list of external Emacs Lisp
files that shadow Emacs builtins (listing potential load path problems).

Some Emacs modes are over 10K lines of code (e.g. ~nxml-mode~, ~CEDET~).  Many
packages (e.g. ~Org~, ~Gnus~) make use of the ~autoload~ feature, so that you only
need to load a single file that define autoloaded functions.

#+begin_src emacs-lisp
;;* Loading Libraries of Lisp Code for Emacs

(leuven--chapter leuven-load-chapter-0-loading-libraries "0 Loading Libraries"
#+end_src

#+begin_src emacs-lisp
  ;; Load-path enhancement.
  (defun leuven--add-to-load-path (this-directory)
    "Add THIS-DIRECTORY at the beginning of the load-path, if it exists."
    (when (and this-directory
               (file-directory-p this-directory))
      ;; TODO Add warning if directory does not exist.
      (let* ((this-directory (expand-file-name this-directory)))

        ;; Directories containing a `.nosearch' file (such as
        ;; `auctex-11.88.6\style') should not made part of `load-path'.
        ;; TODO `RCS' and `CVS' directories should also be excluded.
        (unless (file-exists-p (concat this-directory "/.nosearch"))
          (add-to-list 'load-path this-directory)
          (when leuven-verbose-loading
            (message "[Added `%s' to `load-path']" this-directory))))))
#+end_src

#+begin_src emacs-lisp
  ;; Remember this directory.
  (defconst leuven--directory
    (file-name-directory (or load-file-name (buffer-file-name)))
    "Directory path of Emacs-Leuven installation.")

  (leuven--add-to-load-path
   (concat leuven--directory "site-lisp"))
#+end_src

~leuven--local-repos-directory~ is where you put Emacs Git/SVN/CSV repositories.

#+begin_src emacs-lisp
  (defvar leuven--local-repos-directory "~/Public/Repositories/"
    "Directory containing additional Emacs Lisp public repositories.")

  (leuven--add-to-load-path
   (concat leuven--local-repos-directory "babel"))
  (leuven--add-to-load-path
   (concat leuven--local-repos-directory "emacs-bookmark-extension") ; XXX?
   )
#+end_src

*************** TODO Specify variables using `defcustom'

~leuven-user-lisp-directory~ is there so that you have an easy way of installing
*your own Emacs add-ons* (which may be specific to the version of Emacs you're
running).  This keeps your local add-ons apart from distro supplied ones.

It also means you can do a complete re-install of Emacs (or even your Linux
distro) without impacting on stuff you have added by hand.

#+begin_src emacs-lisp
  (defvar leuven-user-lisp-directory (concat user-emacs-directory "lisp/")
    "Directory containing personal additional Emacs Lisp packages.")

  (leuven--add-to-load-path leuven-user-lisp-directory)
#+end_src

#+begin_src emacs-lisp
  ;; Require a feature/library if available; if not, fail silently.
  (unless (fboundp 'try-require)
    (defun try-require (feature)
      "Attempt to load a FEATURE (or library).
Return true if the library given as argument is successfully loaded.
If not, just print a message."
      (condition-case err
          (progn
            (if (stringp feature)
                (load-library feature)
              (require feature))
            t)                          ; Necessary for correct behavior in
                                        ; conditional expressions.
        (file-error
         (message "[Requiring `%s'... missing]" feature)
         nil))))
#+end_src

#+begin_src emacs-lisp
  ;; TEMPORARY.
  (unless (fboundp 'with-eval-after-load)
    ;; Wrapper around `eval-after-load' (added in GNU Emacs 24.4).
    (defmacro with-eval-after-load (mode &rest body)
      "`eval-after-load' MODE evaluate BODY."
      (declare (indent defun))
      `(eval-after-load ,mode
         '(progn ,@body))))
#+end_src

** Creating and selecting buffers

#+begin_src emacs-lisp
  (defun switch-or-start (function buffer)
    "If the BUFFER is current, bury it.  If there is a buffer with that name,
  switch to it; otherwise, invoke the FUNCTION."
    (if (equal (buffer-name (current-buffer)) buffer)
        (bury-buffer)
      (if (get-buffer buffer)
          (switch-to-buffer buffer)
        (funcall function))))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 0-loading-libraries ends here.
#+end_src

* Environment

#+begin_src emacs-lisp
;;* Environment

(leuven--chapter leuven-load-chapter-0-environment "0 Environment"

;;** Type of OS

  (leuven--section "Type of OS")

  (defconst leuven--linux-p
    (eq system-type 'gnu/linux)
    "Running a GNU/Linux version of Emacs.")

  (defconst leuven--mac-p
    (eq system-type 'darwin)
    "Running a Mac OS version of Emacs.")

  (defconst leuven--win32-p
    (eq system-type 'windows-nt)
    "Running a native Microsoft Windows version of Emacs.")

  (defconst leuven--cygwin-p
    (eq system-type 'cygwin)
    "Running a Cygwin version of Emacs.")

;;** MS Windows

  (defconst leuven--windows-program-files-dir ; sys-path.
    (cond (leuven--win32-p
           (file-name-as-directory (or (getenv "ProgramFiles(x86)")
                                       (getenv "ProgramFiles"))))
          (leuven--cygwin-p
           "/cygdrive/c/Program Files/")
          (t
           "/usr/local/bin/"))
    "Default Windows Program Files folder.")
#+end_src

Use ~(display-graphic-p)~ (instead of ~window-system~) in conditions.

#+begin_src emacs-lisp
;;** Window system

  (leuven--section "Window system")

  (defconst leuven--console-p
    (eq window-system nil)
    "Running a text-only terminal.")

  (defconst leuven--x-window-p
    (eq window-system 'x)
    "Running a X Window system.")

;;** Testing file accessibility

  (defun leuven--file-exists-and-executable-p (file)
    "Make sure the file FILE exists and is executable."
    (if file
        (if (file-executable-p file)
            file
          (message "[WARN- Can't find executable `%s']" file)
          ;; Sleep 1.5 s so that you can see the warning.
          (sit-for 1.5))
      (error "Missing argument to \"leuven--file-exists-and-executable-p\"")))

;;** Init

  (leuven--section "Init")

  ;; Ensure that the echo area is always visible during the early stage of
  ;; startup (useful in case of error).
  (modify-all-frames-parameters
   '((height . 32)))

)                                       ; Chapter 0 ends here.
#+end_src

*************** TODO Function for finding executables
See function ~--find-program~ at http://www.visualco.de/src/elisp/.emacs.el.html.
*************** END

* Debugging

#+begin_src emacs-lisp
;;* Debugging

(leuven--chapter leuven-load-chapter-0-debugging "0 Debugging"
#+end_src

#+begin_src emacs-lisp
  ;; Get the backtrace when uncaught errors occur.
  (setq debug-on-error t)               ; Will be unset at the end.

  ;; Hit `C-g' while it's frozen to get an Emacs Lisp backtrace.
  (setq debug-on-quit t)                ; Will be unset at the end.
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 0 ends here.
#+end_src

* Emacs Lisp Packages
:PROPERTIES:
:ID:       8c71fa50-b62e-49ae-bcbb-2ed1ee7a5d65
:END:

Installed packages are now activated *before* loading the init file.
-- https://github.com/emacs-mirror/emacs/blob/master/etc/NEWS.27

** The Package Menu Buffer

#+begin_src emacs-lisp
;;* 48 Emacs Lisp (info "(emacs)Packages")

(leuven--chapter leuven-load-chapter-48-packages "48 Emacs Lisp Packages"
#+end_src

To upgrade packages after running ~package-list-packages~, type:

- ~U~ (/mark Upgradable packages/) and then
- ~x~ (/eXecute the installs and deletions/).

When it's done installing all the packages, you delete the obsolete packages by
hitting ~y~ (/Yes/) when asked.

** Package Installation

The first time you start emacs, it will install some additional packages that
are best handled by the package manager.

- User's Emacs Lisp packages in ~package-user-dir~ (=~/.emacs.d/elpa=)
- System-wide Emacs Lisp packages in ~package-directory-list~

HTTP frontends for the Emacs repositories:
- http://elpa.gnu.org/packages/
- http://melpa.org/packages/

In Marmalade, the developers themselves do the packaging.  In MELPA, packages
are generated programmatically from upstream Git-based sources.

#+begin_note
The Marmalade repository is not recommended by Flycheck (due to frequent
outages).
#+end_note

To list packages which should /not/ be installed by Emacs-Leuven, add something
like this into your configuration file:

#+begin_example
(setq leuven-excluded-packages '(ess flycheck-ledger))
#+end_example

#+begin_src emacs-lisp
;;** 48.2 Package Installation

  (leuven--section "48.2 Package Installation")

  ;; Simple package system for GNU Emacs.
  (try-require 'package)
  (with-eval-after-load "package"

    ;; Archives from which to fetch.
    (setq package-archives
          (append '(("org"   . "http://orgmode.org/elpa/")
                    ("melpa" . "http://melpa.org/packages/"))
                  package-archives))

    ;; Packages which were installed by the user (as opposed to installed as
    ;; dependencies).
    (setq package-selected-packages
          '(ag
            ant
            anzu
            auctex
            ;; auto-complete
            auto-highlight-symbol
            auto-package-update
            avy
            back-button
            bbdb
            boxquote
            ;; calfw
            circe
            color-identifiers-mode
            company
            company-quickhelp
            csv-mode
            dashboard
            diff-hl
            diminish
            docker-compose-mode
            dumb-jump
            ;; emacs-eclim
            emr
            expand-region
            fancy-narrow
            flycheck
            flycheck-color-mode-line
            fuzzy
            git-commit
            git-commit-insert-issue
            git-messenger
            git-timemachine
            google-this
            google-translate
            goto-chg
            graphviz-dot-mode
            helm
            helm-ag
            helm-descbinds
            helm-ls-git
            helm-projectile ; Obsolete package?
            helm-swoop
            hide-lines
            highlight-numbers
            hl-anything                 ; Better than `highlight-symbol'.
            howdoi
            htmlize
            indent-guide
            ;; jabber
            jquery-doc
            js2-mode
            js2-refactor
            json-mode
            key-chord
            litable
            idle-require
            interaction-log
            leuven-theme
            ;; magit
            markdown-mode
            ;; multi-term
            multiple-cursors
            pager
            ;; paredit
            ;; pdf-tools
            powerline
            rainbow-delimiters
            ;; rainbow-mode
            ;; redshank
            skewer-mode
            smart-comment
            smartparens
            ;; sql-indent
            sqlup-mode
            symbol-overlay
            tern
            ;; undo-tree
            volatile-highlights
            web-mode
            which-key
            ws-butler
            yasnippet
            ztree))

    ;; (when (fboundp 'package-install-selected-packages) ; Emacs-v25
    ;;   (package-install-selected-packages))

    (defcustom leuven-excluded-packages
      nil
      "List of packages that should be ignored by Emacs-Leuven."
      :group 'emacs-leuven
      :type '(repeat (string)))

    (defcustom leuven-install-all-missing-elpa-packages
     nil
      "Force the installation (without query) of all missing packages."
      :group 'emacs-leuven
      :type '(repeat (string)))

    (defun leuven--missing-elpa-packages ()
      "List packages to install for a full blown Leuven installation.
These packages are neither built-in nor already installed nor ignored."
      (let (missing-elpa-packages)
        (dolist (pkg package-selected-packages)
          (unless (or (package-installed-p pkg)
                      (locate-library (symbol-name pkg))
                      (member pkg leuven-excluded-packages))
            (push pkg missing-elpa-packages)))
        missing-elpa-packages))

    ;; Propose to install all the packages specified in
    ;; `package-selected-packages' which are missing and which shouldn't be
    ;; ignored.
    (let ((missing-elpa-packages (leuven--missing-elpa-packages)))
      (when missing-elpa-packages

        (when (or leuven-install-all-missing-elpa-packages
                  (yes-or-no-p
                   (format "Install the %s missing ELPA package(s) without confirming each? "
                           (length missing-elpa-packages))))
          (setq leuven-install-all-missing-elpa-packages t))

        ;; ;; Download once the ELPA archive description.
        ;; (package-refresh-contents)      ; Ensure that the list of packages is
        ;;                                 ; up-to-date.  Otherwise, new packages
        ;;                                 ; (not present in the cache of the ELPA
        ;;                                 ; contents) won't install.
        (dolist (pkg (reverse missing-elpa-packages))
          (if (or leuven-install-all-missing-elpa-packages
                  (yes-or-no-p (format "Install ELPA package `%s'? " pkg)))
              (ignore-errors
                (package-install pkg))
            (message (concat "[Customize Emacs-Leuven to ignore the `%s' package next times...]") pkg)
            (sit-for 1.5)))))

    )
#+end_src

#+begin_src emacs-lisp
  ;; Automatically update Emacs packages.
  (with-eval-after-load "auto-package-update-autoloads"

    (setq auto-package-update-delete-old-versions t)

    (add-hook 'auto-package-update-before-hook
              #'(lambda ()
                  (message "[Updating (M)ELPA packages now...]")))

    ;; "It looks like there's a problem with your network connection."
    ;; (auto-package-update-maybe)
  )
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 48 ends here.
#+end_src

~Idle-require~ should not be cancelable; hence, we put it out of a "chapter".

#+begin_src emacs-lisp
  ;; Load elisp libraries while Emacs is idle.
  (try-require 'idle-require) ; XXX

  ;; Fail-safe for `idle-require'.
  (if (not (featurep 'idle-require))
    (defun idle-require (feature &optional file noerror)
      (try-require feature)))

  (with-eval-after-load "idle-require"

    ;; Idle time in seconds after which autoload functions will be loaded.
    (setq idle-require-idle-delay 5)

    ;; Time in seconds between automatically loaded functions.
    (setq idle-require-load-break 2)

    ;; Starts loading.
    (add-hook 'after-init-hook #'idle-require-mode))
#+end_src

* The Organization of the Screen

#+begin_src emacs-lisp
;;* 1 The Organization of the (info "(emacs)Screen")

(leuven--chapter leuven-load-chapter-1-screen "1 The Organization of the Screen"

;;** 1.2 The (info "(emacs)Echo Area")

  (leuven--section "1.2 (emacs) The Echo Area")

  ;; Don't truncate the message log buffer when it becomes large.
  (setq message-log-max t)

)                                       ; Chapter 1 ends here.
#+end_src

* Exiting Emacs

#+begin_src emacs-lisp
;;* 6 (info "(emacs)Exiting") Emacs

(leuven--chapter leuven-load-chapter-6-exiting "6 Exiting Emacs"

  ;; Unbind "minimize".
  (global-unset-key (kbd "C-z"))

  ;; Quit with Alt + F4.
  (global-set-key (kbd "<M-f4>") #'save-buffers-kill-terminal)

)                                       ; Chapter 6 ends here.
#+end_src

* Basic Editing Commands

#+begin_src emacs-lisp
;;* 7 (info "(emacs)Basic") Editing Commands

(leuven--chapter leuven-load-chapter-7-basic "7 Basic Editing Commands"
#+end_src

** Inserting Text

#+begin_src emacs-lisp
;;** 7.1 (info "(emacs)Inserting Text")

  (leuven--section "7.1 (emacs)Inserting Text")

  ;; Enter characters by their code in octal (for `C-q NNN RET').
  (setq read-quoted-char-radix 8)       ; 16 for hexadecimal (for Unicode char)
#+end_src

** Moving Point Location

- ~M-r~ ::
     ~move-to-window-line~.

- ~M-g g~ ::
     *Jump to* the beginning of *line* number /N/ (~goto-line~).

#+begin_src emacs-lisp
;;** 7.2 (info "(emacs)Moving Point") Location

  (leuven--section "7.2 (emacs)Moving Point Location")

  ;; Don't add newlines to end of buffer when scrolling.
  (setq next-line-add-newlines nil)

  ;; Print the current buffer line number.
  (global-set-key (kbd "M-G") #'what-line)
#+end_src

Show line numbers temporarily -- just when you're going to a line number with
~goto-line~.

#+begin_src emacs-lisp
  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (linum-mode 1)
          (goto-line (read-number "Goto line: ")))
      (linum-mode -1)))

  (global-set-key [remap goto-line] #'goto-line-with-feedback)
#+end_src

** Basic Undoing Changes

Shortcuts:

| Command | Emacs | Emacs-Leuven   |
|---------+-------+----------------|
| Undo    | C-/   | <f11>          |
| Redo    |       | C-S-z, <S-f11> |

#+begin_src emacs-lisp
;;** 7.4 (info "(emacs)Basic Undo")ing Changes

  (leuven--section "7.4 (emacs)Basic Undoing Changes")

  ;; Undo changes.
  (global-set-key (kbd "<f11>") #'undo)
#+end_src

#+begin_src emacs-lisp
  ;; Treat undo history as a tree.
  (with-eval-after-load "undo-tree-autoloads"

    ;; Enable Global-Undo-Tree mode.
    (global-undo-tree-mode 1))

  (with-eval-after-load "undo-tree"

    (with-eval-after-load "diminish-autoloads"
      (diminish 'undo-tree-mode))

    ;; Display times relative to current time in visualizer.
    (setq undo-tree-visualizer-relative-timestamps t)

    ;; Display time-stamps by default in undo-tree visualizer.
    (setq undo-tree-visualizer-timestamps t)
                                        ; Toggle time-stamps display using `t'.

    ;; Display diff by default in undo-tree visualizer.
    (setq undo-tree-visualizer-diff t)  ; Toggle the diff display using `d'.

    ;; Redo changes.
    (global-set-key (kbd "C-S-z")   #'undo-tree-redo)
    (global-set-key (kbd "<S-f11>") #'undo-tree-redo))
#+end_src

Visual feedback on some operations (~undo~, ~yank~, etc.).

#+begin_src emacs-lisp
  (with-eval-after-load "volatile-highlights-autoloads"
    (volatile-highlights-mode 1))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 7 ends here.
#+end_src

* The Minibuffer

#+begin_src emacs-lisp
;;* 8 The (info "(emacs)Minibuffer")

(leuven--chapter leuven-load-chapter-8-minibuffer "8 The Minibuffer"

  ;; How long to display an echo-area message when the minibuffer is active.
  (setq minibuffer-message-timeout 0.5)
#+end_src

** Editing in the Minibuffer

If the output is short enough to display in the echo area (which is determined
by the variables ~resize-mini-windows~ and ~max-mini-window-height~), it is shown in
echo area.

#+begin_src emacs-lisp
;;** 8.3 (info "(emacs)Minibuffer Edit")ing

  (leuven--section "8.3 (emacs)Minibuffer Editing")

  ;; Minibuffer and echo area windows resize vertically as necessary to fit
  ;; the text displayed in them.
  (setq resize-mini-windows t)
#+end_src

** Completion

#+begin_src emacs-lisp
;;** 8.4 (info "(emacs)Completion")

  (leuven--section "8.4 (emacs)Completion")

  ;; Ignore case differences when completing file names.
  (setq read-file-name-completion-ignore-case t)

  ;; Don't consider case significant in completion.
  (setq completion-ignore-case t)
#+end_src

Within ~read-file-name~, this variable is overridden by
~read-file-name-completion-ignore-case~.

#+begin_src emacs-lisp
  ;; Ignore case when reading a file name.
  (setq read-file-name-completion-ignore-case t) ; [Default: t on Windows]
#+end_src

Within ~read-buffer~, ~completion-ignore-case~ is overridden by
~read-buffer-completion-ignore-case~.

#+begin_src emacs-lisp
  ;; Ignore case when reading a buffer name.
  (setq read-buffer-completion-ignore-case t) ; [Default: nil].
#+end_src

#+begin_src emacs-lisp
  ;; Provide the same facility of `ls --color' inside Emacs.
  (when (locate-library "dircolors")
    (autoload 'dircolors "dircolors" nil t)
    (add-hook 'completion-list-mode-hook #'dircolors))
#+end_src

** Minibuffer History

#+begin_src emacs-lisp
  ;; Delete duplicates in history.
  (setq history-delete-duplicates t)
#+end_src

** Repeating Minibuffer Commands

Use ~M-x list-command-history~ to display the entire command history, showing all
the commands ~C-x <ESC> <ESC>~ can repeat, most recent first.

#+begin_src emacs-lisp
)                                       ; Chapter 8 ends here.
#+end_src

* Help

In general, the following functions are very interesting for finding useful
functions and documentation.

- ~apropos-documentation~ (~C-h d~) ::
     *Show symbols whose documentation contains matches for PATTERN.*
     For example, ~C-h d yank properties RET~.

- ~describe-function~ (~C-h f~) ::
     Used with TAB completion to show documentation of functions.

- ~elisp-index-search~ (~C-h E~ in Emacs-Leuven) ::
     Look up documentation on broad Emacs Lisp topics (in the indices of the
     Emacs Lisp Reference Manual).

- ~info-lookup-symbol~ (~C-h S~, or ~C-<F1>~ in Emacs-Leuven) ::
     *Bring the relevant section from the manual, which describes the topic in
     more detail.*

XXX Since Emacs 25.1, C-h o = describe-symbol

With all prefix keys, if you follow them with ~C-h~ (~h~ for help), a list of key
bindings in that prefix map is displayed.  This is automatic and is one of the
self-documenting features of Emacs.

Try, for example ~C-x C-h~ or ~C-c C-x C-h~ to see what it does.  I do use it to
remind myself of rarely used rectangle commands: ~C-x r C-h~.

FYI, ~catman~ create the database files that are used by ~apropos~ or ~man -k~.

Note about PHP documentation lookup -- PHP Mode has a nice feature to lookup the
function's definition in PHP's manual in your web browser (~M-x
php-search-documentation~ or ~C-c C-f~).  You can combine it with EWW to get the
relevant manual page without leaving Emacs.

*Close* the help buffer by pressing ~Q~.

#+begin_src emacs-lisp
;;* 10 (info "(emacs)Help")

(leuven--chapter leuven-load-chapter-10-help "10 Help"
#+end_src

** Help Summary

#+begin_src emacs-lisp
;;** 10.1 (info "(emacs)Help Summary")

  (leuven--section "10.1 (emacs)Help Summary")

  ;; Avoid the description of all minor modes.
  (defun leuven-describe-major-mode ()
    "Describe only `major-mode'."
    (interactive)
    (describe-function major-mode))

  ;; Look up subject in (the indices of the) Emacs Lisp manual.
  (global-set-key (kbd "C-h E") #'elisp-index-search)
#+end_src

** Apropos

You can ask what pertains to a given topic by typing ~M-x apropos RET pattern
RET~.

#+begin_src emacs-lisp
;;** 10.4 (info "(emacs)Apropos")

  (leuven--section "10.4 (emacs)Apropos")

  (with-eval-after-load "apropos"

    ;; Apropos commands will search more extensively, checking all variables and
    ;; non-interactive functions as well.
    (setq apropos-do-all t))

  ;; (defun apropos-user-option (string)
  ;;   "Like apropos, but lists only symbols that are names of user
  ;; modifiable variables.  Argument REGEXP is a regular expression.
  ;;    Returns a list of symbols, and documentation found"
  ;;   (interactive "sVariable apropos (regexp): ")
  ;;   (let ((message
  ;;          (let ((standard-output (get-buffer-create "*Help*")))
  ;;            (print-help-return-message 'identity))))
  ;;     (if (apropos string  'user-variable-p)
  ;;         (and message (message message)))))

  ;; Show all variables whose name matches the pattern.
  (define-key help-map (kbd "A") #'apropos-user-option)
#+end_src

** Misc Help Commands

~update-info-dir~

The utility ~install-info~ is used to maintain the =info/dir= file.

~C-h K~ goes to the node in the Emacs manual describing the command bound to
a key.

In a manual, these key bindings will make your life easier:

- ~^~ ::
     Move "up" from this node.

- ~]~ ::
     Go forward one node, considering all nodes as forming one sequence.

- ~l~ ::
     Move back in history to the last node you were at.

- ~L~ ::
     Go to menu of visited nodes.

- ~i~ ::
     *Search for a topic in this manual's Index* and go to index entry.

- ~s~ ::
     *Search for a regexp* and select node it's found in.

#+begin_src emacs-lisp
;;** 10.8 (info "(emacs)Misc Help")

  (leuven--section "10.8 (emacs)Misc Help")

  ;; Enter Info documentation browser.
  (global-set-key (kbd "<f1>") #'info)

  (defun leuven-describe-elisp-symbol-at-point ()
    "Get help for the symbol at point."
    (interactive)
    (let ((sym (intern-soft (current-word))))
      (unless
          (cond ((null sym))
                ((not (eq t (help-function-arglist sym)))
                 (describe-function sym))
                ((boundp sym)
                 (describe-variable sym)))
        (message "[nothing]"))))

  (global-set-key (kbd "<f1>") #'leuven-describe-elisp-symbol-at-point)

  ;; Display symbol definitions, as found in the relevant manual
  ;; (for AWK, C, Emacs Lisp, LaTeX, M4, Makefile, Sh and other languages that
  ;; have documentation in Info).
  ;; (global-set-key (kbd "<C-f1>") #'info-lookup-symbol)
#+end_src

When Info is called, the variable ~Info-directory-list~ is populated from:

1. the ~INFOPATH~ environment variable, or /(if unset)/

2. the ~Info-default-directory-list~ variable -- non-existent directories will be
   removed when copied to ~Info-directory-list~

The best would be to set the ~INFOPATH~ environment variable so that you see the
same manuals outside of Emacs, in the same shell from which you invoke Emacs.

However, as Windows Emacs doesn't see that Cygwin environment variable (it would
well work with a Windows environment variable), I prefer to try and put the
Windows configuration inside the Emacs configuration files.

Normally, ~Info-directory-list~ is not intended to be settable by the user. But we
must do so if we want to force our Info manuals before the standard ones (from
Emacs). XXX Could we set ~Info-default-directory-list~ instead???

#+begin_src emacs-lisp
  (with-eval-after-load "info"
    ;; List of directories to search for Info documentation files (in the order
    ;; they are listed).
    (when leuven--win32-p
      ;; (info-initialize)
      (setq Info-directory-list
            `(,(expand-file-name
                (concat (file-name-directory (locate-library "org")) "../doc/"))
              "c:/cygwin/usr/share/info/"
              ,@Info-directory-list)))

    ;; XXX Replace by add-to-list to ensure we don't insert duplicates (if Cygwin was already there).
#+end_src

~Info+~ fontifies entries for reference items (functions, macros, commands,
special forms, constants, options, other variables), and that includes their
parameters, even those on continuation lines.

With ~Info+~, you can also merge an Info node with its subnodes into the same
buffer, by calling ~Info-merge-subnodes~ (bound to ~+~).

#+begin_src emacs-lisp
    (with-eval-after-load "info+-autoloads"
      (idle-require 'info+))

    (with-eval-after-load "info+"

      ;; Show breadcrumbs in the header line.
      (setq Info-breadcrumbs-in-header-flag t)

      ;; Don't show breadcrumbs in the mode line.
      (setq Info-breadcrumbs-in-mode-line-mode nil))
#+end_src

In an Info page, ~w~ will copy the reference to the current node (the ~(%s)%s~ part
of your format string).

When called with a 0 argument (~M-0 w~), you get ~(info \"(%s)%s\")~.

#+begin_src emacs-lisp
    )
#+end_src

#+begin_src emacs-lisp
  ;; Get a Unix manual page of the item under point.
  ;; (global-set-key (kbd "<S-f1>") #'man-follow)

  (with-eval-after-load "man"
    ;; Make the manpage the current buffer in the current window.
    (setq Man-notify-method 'pushy))

  ;; Alias man to woman.
  (defalias 'man 'woman)

  ;; Decode and browse Unix man-pages "W.o. (without) Man".
  (with-eval-after-load "woman"
    (defalias 'man 'woman)

    ;; WoMan adds a Contents menu to the menubar.
    (setq woman-imenu t))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 10 ends here.
#+end_src

* The Mark and the Region

#+begin_src emacs-lisp
;;* 11 The (info "(emacs)Mark") and the Region

(leuven--chapter leuven-load-chapter-11-mark "11 The Mark and the Region"
#+end_src

** Setting the Mark

Instead of setting the *mark* in order to operate on a region, you can also type:

-  ~C-SPC C-SPC~ ::
     *"Remember" a position* in the buffer (pushes the current position to the
     *mark ring*, by setting the mark where point is without leaving it active),
     and

- ~C-u C-SPC~ ::
     Later *jump* back *to the* previous *mark* in the buffer.  You can use this
     repeatedly to *navigate* through the entire *mark ring*.

#+begin_tip
Many commands (especially ones which are liable to move you an an unknown or
arbitrary distance from your original location, like ~isearch-forward~,
~beginning-of-buffer~, ~avy~) automatically save the previous position in the mark
ring -- you don't have to use ~C-SPC C-SPC~ before, but only ~C-u C-SPC~ to return
afterwards.

So, after using ~C-s~ to go somewhere, you can easily jump back again.
#+end_tip

*** Navigating to Previous Change

*Go to* the *place* where you *last changed* something ("last edit location"):

#+begin_src emacs-lisp
  ;; Go to Last (buffer-local) Edit Location.
  (with-eval-after-load "goto-chg-autoloads"
    (global-set-key (kbd "<C-S-backspace>") #'goto-last-change))
#+end_src

It moves point through ~buffer-undo-list~ positions.

*** Navigating to Navigated Items

#+begin_src emacs-lisp
  (with-eval-after-load "back-button-autoloads"
    (back-button-mode 1)
#+end_src

You can go back and forth along the items that have been marked.

- C-x <left> ::
     Go back in buffer-local ~mark-ring~.

- C-x <right> ::
     Go forward in buffer-local ~mark-ring~.

- C-x C-<left> (or <C-M-left> in Emacs Leuven) ::
     Go back in ~global-mark-ring~.

- C-x C-<right> (or <C-M-right> in Emacs Leuven) ::
     Go forward in ~global-mark-ring~.

When the ~smartrep~ package is installed, the ~C-x~ prefix need not be used for
consecutive ~back-button~ commands.

You can also use keyboard shortcuts ~C-M-left~, or ~C-M-right~:

#+begin_src emacs-lisp
    ;; Navigate backward.
    (global-set-key (kbd "<C-M-left>")  #'back-button-global-backward) ; IntelliJ IDEA.

    ;; Navigate forward.
    (global-set-key (kbd "<C-M-right>") #'back-button-global-forward)) ; IntelliJ IDEA.
#+end_src

** Commands to Mark Textual Objects

- ~M-@~ ::
     Set mark after end of next *word* (~mark-word~) without moving point.

- ~C-M-@~ ::
     Set mark after end of following *balanced expression* (~mark-sexp~) without
     moving point.

Shortcuts:

| Command          | Emacs-Leuven |
|------------------+--------------|
| Extend Selection | C-M-w        |
| Shrink Selection | C-S-w        |

#+begin_src emacs-lisp
  ;; Increase selected region by semantic units.
  (with-eval-after-load "expand-region-autoloads"

    ;; ;; Key to use after an initial expand/contract to undo.
    ;; (setq expand-region-reset-fast-key "<escape> <escape>")

    (global-set-key (kbd "C-M-w") #'er/expand-region)    ; See key-chord `hh'.
    (global-set-key (kbd "C-S-w") #'er/contract-region)) ; See key-chord `HH'.
#+end_src

** Operating on the Region

#+begin_src emacs-lisp
  ;; Inserting text while the mark is active causes the text in the region to be
  ;; deleted first.
  (delete-selection-mode 1)             ; Overwrite region.
#+end_src

** Shift Selection

Shifted motion keys activate the mark momentarily.

** Multiple selections

You can [[http://www.emacsrocks.com/e13.html][watch an intro to multiple-cursors at Emacs Rocks]].

In other editors:

- https://www.sublimetext.com/docs/2/multiple_selection_with_the_keyboard.html
- https://docs.c9.io/multiple_cursors.html
- http://komodoide.com/screencasts/watch/87286656-multiple-selections/

#+begin_src emacs-lisp
  ;; Multiple cursors for Emacs.
  (with-eval-after-load "multiple-cursors-autoloads"
#+end_src

*** Splitting the selection into lines

Make *batch edits* with Multiple Cursors: select a block of lines, and then *split
the region into lines* which are then *edited simultaneously*.

#+begin_src emacs-lisp
    ;; Add a cursor to each (continuous) line in the current region.
    (global-set-key (kbd "C-S-c C-S-c") #'mc/edit-lines) ;!
#+end_src

*** Quick add next/previous

Use Multiple Cursors to *rename variables quickly*: *add the next* or previous
*occurrence of the current word to the selection*, and then type the new name.
Done.

#+begin_src emacs-lisp
    ;; Add a cursor and region at the next/previous part of the buffer that
    ;; matches the current region.
    (global-set-key (kbd "C->") #'mc/mark-next-like-this) ;!
    (global-set-key (kbd "C-<") #'mc/mark-previous-like-this) ;!

    ;; Add Selection for Next Occurrence.
    (global-set-key (kbd "M-j") #'mc/mark-next-like-this) ; IntelliJ.

    ;; Unselect Occurrence. XXX
    ;; (global-set-key (kbd "M-J") #'mc/unmark-next-like-this) ; IntelliJ.

    ;; Skip the current one and select the next/previous part of the buffer that
    ;; matches the current region.
    (global-set-key (kbd "C-M->") #'mc/skip-to-next-like-this)
    (global-set-key (kbd "C-M-<") #'mc/skip-to-previous-like-this)

    ;; Add or remove caret.
    (global-set-key (kbd "<C-S-mouse-1>") #'mc/add-cursor-on-click)
    (global-set-key (kbd "<M-mouse-1>")   #'mc/add-cursor-on-click) ; XXX DOES NOT WORK.
#+end_src

*** Find All

*Add all occurrences of the current word to the selection.*

#+begin_src emacs-lisp
    ;; Select All Occurrences.
    (global-set-key (kbd "C-M-S-j") #'mc/mark-all-like-this-dwim) ;! IntelliJ.
#+end_src

#+begin_src emacs-lisp
    ;; Tries to guess what you want to mark all of.
    (global-set-key (kbd "C-;")     #'mc/mark-all-like-this-dwim) ;! Like Iedit.
    ;; (global-set-key (kbd "C-c C-w") #'mc/mark-all-like-this-dwim)
    ;; (global-set-key (kbd "C-x C-;") #'mc/mark-all-like-this-dwim)

    ;; Mark all parts of the buffer that matches the current region.
    (global-set-key (kbd "C-c C-<") #'mc/mark-all-like-this) ;!
#+end_src

#+begin_src emacs-lisp
    (global-set-key (kbd "C-!") #'mc/mark-next-symbol-like-this)
#+end_src

#+begin_src emacs-lisp
    ;; (global-set-key (kbd "<C-RET>") #'mc/mark-more-like-this-extended) ; useful for completion
#+end_src

#+begin_src emacs-lisp
    ;; Insert increasing numbers for each cursor.
    (global-set-key (kbd "C-M-=") #'mc/insert-numbers)
  )
#+end_src

*** Single Selection

To go from multiple selections to a single selection, press ~C-g~ or ~RET~.

*** Commands to run in multiple-cursors-mode

#+begin_src emacs-lisp
  ;; Multiple cursors for Emacs.
  (with-eval-after-load "multiple-cursors-core"

    ;; Commands to run for all cursors in multiple-cursors-mode.
    (setq mc/cmds-to-run-for-all        ; See .mc-lists.el.
          '(c-electric-slash
            cycle-spacing
            emr-show-refactor-menu
            isearch-abort
            isearch-printing-char
            js2-mode-show-node
            just-one-space
            kill-region
            leuven-fill-or-unfill-paragraph
            leuven-smart-punctuation-quotation-mark
            org-beginning-of-line
            org-end-of-line
            org-kill-line
            org-self-insert-command
            org-shiftdown
            org-shiftleft
            org-shiftright
            org-shiftup
            org-yank
            orgtbl-self-insert-command
            yas-expand))

    ;; Commands to run only once in multiple-cursors-mode.
    (setq mc/cmds-to-run-once
          '()))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 11 ends here.
#+end_src

* Killing and Moving Text

#+begin_src emacs-lisp
;;* 12 (info "(emacs)Killing") and Moving Text

(leuven--chapter leuven-load-chapter-12-killing "12 Killing and Moving Text"
#+end_src

** Deletion and Killing

- ~C-S-backspace~ ::
     Kill an entire line at once.

#+begin_src emacs-lisp
;;** 12.1 (info "(emacs)Deletion and Killing")

  (leuven--section "12.1 (emacs)Deletion and Killing")

  ;; Manipulate whitespace around point in a smart way.
  (global-set-key (kbd "M-SPC") #'cycle-spacing) ; vs `just-one-space'.
#+end_src

With the following gems, you can kill or copy the line point is on with a single
keystroke:

- ~C-w~ kills the current line
- ~M-w~ copies the current line

#+begin_note
If there is an active region, ~kill-region~ and ~kill-ring-save~ will continue to do
what they normally do: kill or copy it.
#+end_note

#+begin_src emacs-lisp
  ;; Add the ability to cut the current line without marking it (no selection).
  (defun kill-region--slick-cut (beg end &optional region)
    "When called with no active region, kill the current line instead."
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (line-beginning-position) (line-beginning-position 2)))))
  (advice-add 'kill-region :before #'kill-region--slick-cut)

  ;; Add the ability to copy the current line without marking it (no selection).
  (defun kill-ring-save--slick-copy (beg end &optional region)
    "When called with no active region, copy the current line instead."
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (message "[Copied the current line]")
       (list (line-beginning-position) (line-beginning-position 2)))))
  (advice-add 'kill-ring-save :before #'kill-ring-save--slick-copy)
#+end_src

| Command        | Emacs | Sublime Text | TextMate |
|----------------+-------+--------------+----------|
| Duplicate line | C-S-d | C-S-d        | C-S-d    |

#+begin_src emacs-lisp
  (defun duplicate-current-line ()
    "Duplicate the line containing point."
    (interactive)
    (save-excursion
      (let (line-text)
        (goto-char (line-beginning-position))
        (let ((beg (point)))
          (goto-char (line-end-position))
          (setq line-text (buffer-substring beg (point))))
        (if (eobp)
            (insert ?\n)
          (forward-line))
        (open-line 1)
        (insert line-text))))

  (global-set-key (kbd "C-S-d") #'duplicate-current-line)
#+end_src

To *highlight duplicate lines*, see
https://emacs.stackexchange.com/questions/13092/how-can-i-highlight-duplicate-lines

In Emacs 24.4+, the cleanest way to *uniquify lines* (~uniq-lines~) is the
~delete-duplicate-lines~ function.

Note that:
- this works on a region, not a buffer, so select the desired text first,
- it maintains the relative order of the originals, killing the duplicates.

For example, if your input is:

#+begin_example
test
dup
dup
one
two
one
three
one
test
five
#+end_example

~M-x delete-duplicate-lines~ would make it:

#+begin_example
test
dup
one
two
three
five
#+end_example

That is, it does remove all *duplicate lines* in region, not only the *consecutive*
ones.

** Yanking

#+begin_src emacs-lisp
;;** 12.2 (info "(emacs)Yanking")

  (leuven--section "12.2 (emacs)Yanking")
#+end_src

Auto-indent on paste.

#+begin_src emacs-lisp
  ;; Auto-indentation of pasted code in the programming modes
  ;; (fall back to default, non-indented, yanking by preceding the yanking
  ;; command `C-y' with `C-u').
  (dolist (command '(yank
                     yank-pop))
    (eval `(defadvice ,command (after leuven-indent-region activate)
             "Indent `yank'ed text if programming mode (and no prefix)."
             (let ((mark-even-if-inactive t))
               (and (not current-prefix-arg)
                    (derived-mode-p 'prog-mode)
                    (indent-region (region-beginning) (region-end) nil))))))
#+end_src

#+begin_src emacs-lisp
  ;; Save clipboard strings into kill ring before replacing them.
  (setq save-interprogram-paste-before-kill t)

  ;; ;; Rotating the kill ring changes the window system selection.
  ;; (setq yank-pop-change-selection t)
#+end_src

*** Yanking Earlier Kills

Interactively insert items from kill ring with ~M-x helm-show-kill-ring~ (see
[[id:59418189-b87e-45a2-b128-5cbdc8a16430][Helm]]).

** Cutting and Pasting on Graphical Displays

#+begin_src emacs-lisp
;;** 12.3 (info "(emacs)Cut and Paste")

  (leuven--section "12.3 (emacs)Cut and Paste on Graphical Displays")

  ;; Make cut, copy and paste (keys and menu bar items) use the clipboard.
  (menu-bar-enable-clipboard)
#+end_src

** Rectangles

To kill the text of a rectangular area (vertically selected text), use ~C-x r k~
(~kill-rectangle~).  Or just "delete" the "region-rectangle" (without "killing"
it) with ~C-x r d~.

To copy a (series of) Org column(s) while avoiding the use of registers:
1. select the region-rectangle,
2. use the command ~copy-rectangle-as-kill~ (bound to ~C-x r M-w~), then
3. paste the copied rectangle by doing ~yank-rectangle~ (~C-x r y~).

To do the same with registers:
1. select the region-rectangle,
2. use ~C-x r r R~ to copy the rectangle to the register named ~R~,
3. use ~C-x r i R~ to insert the rectangle that is being held in the register
   named ~R~.

To shift cells up/down within a column of an Org table while leaving remaining
columns intact, use ~kill-rectangle~ and ~yank-rectangle~.

To delete whitespace in each of the lines on the specified rectangle, use
~M-x delete-whitespace-rectangle~.

Use ~C-x r t STRING RET~ to replace each line of a region-rectangle with a given
string.

#+begin_note
Since Emacs 24.4, you can use ~rectangle-mark-mode~ (~C-x SPC~) and do:
- ~C-x SPC~ <...move around...> ~DEL~ to delete the rectangle and
- ~C-x SPC~ <...move around...> ~C-t~ to invoke ~string-rectangle~.
#+end_note

** CUA Bindings

CUA mode sets up key bindings used in many other applications (~C-x~, ~C-c~, ~C-v~ and
~C-z~).

The ~C-x~ and ~C-c~ keys only do cut and copy when the region is active, so in most
cases, they do not conflict with the normal function of these prefix keys.

If you really need to perform a command which starts with one of the prefix keys
even when the region is active, you have three options:

- press the prefix key twice very quickly (within 0.2 seconds),
- press the prefix key and the following key within 0.2 seconds, or
- use the Shift key with the prefix key, i.e. ~C-S-x~ or ~C-S-c~.

You can customize ~cua-enable-cua-keys~ to completely disable the CUA bindings, or
~cua-prefix-override-inhibit-delay~ to change the prefix fallback behavior.

CUA mode also provides enhanced rectangle support with visible rectangle
highlighting.  Though, since Emacs 24.4, ~rectangle-mark-mode~ is the new way.

- ~<C-RET>~ runs the command ~cua-set-rectangle-mark~
- ~M-n~ runs the command ~cua-sequence-rectangle~

#+begin_src emacs-lisp
)                                       ; Chapter 12 ends here.
#+end_src

* Registers (Navigation)

#+begin_src emacs-lisp
;;* 13 (info "(emacs)Registers")

(leuven--chapter leuven-load-chapter-13-registers "13 Registers"
#+end_src

** Saving Positions in Registers

#+begin_src emacs-lisp
;;** 13.1 (info "(emacs)Position Registers")

  (leuven--section "13.1 (emacs)Position Registers")
#+end_src

*Registers:*

- ~C-x r SPC~ ::
     ~point-to-register~.  Store point in a register.  Type any character to
     specify a register when prompted.

- ~C-x r j~ ::
     ~jump-to-register~.  Jump to a point stored in a register.

Setup registers for files I commonly edit.

#+begin_src emacs-lisp :tangle no
  (set-register ?a '(file . "/sudo::/etc/apt/sources.list"))
  (set-register ?b '(file . "~/.bashrc"))
  (set-register ?e `(file . ,(concat leuven--directory "emacs-leuven.txt")))
  (when (file-exists-p "~/4-Admin/0-refile.org")
    (set-register ?r '(file . "~/4-Admin/0-refile.org"))) ; Open my CollectBox.
  (set-register ?z '(file . "~/.zshrc"))
#+end_src

** Navigating with Bookmarks

*** Bookmark

If you need to *move to somewhere in your document* and want a *quick way to
return*, you can create a *bookmark WITH MNEMONIC* on the current line.

#+begin_note
Emacs bookmarks positions, not (just) lines!
#+end_note

*Bookmarks:*

- C-x r m ::
     ~C-x r m RET~ or ~C-x r m BOOKMARK RET~ (~M-x bookmark-set~).  Save a named
     bookmark.

- C-x r b ::
     ~bookmark-jump~.  Jump to a named bookmark.

- C-x r l ::
     List all bookmarks.

#+begin_note
Bookmarks are *persistent* across sessions and they have *names*; not /markers/.
Bookmarked positions can also be *relocated* (found) if they move slightly because
of text changes.
#+end_note

#+begin_src emacs-lisp
;;** 13.7 (info "(emacs)Bookmarks")

  (leuven--section "13.7 (emacs)Bookmarks")

  (with-eval-after-load "bookmark"

    ;; Where to save the bookmarks.
    (setq bookmark-default-file (concat user-emacs-directory "bookmarks.bmk"))
                                        ;! A `.txt' extension would load Org at
                                        ;! the time `bookmark' is required!

    ;; Each command that sets a bookmark will also save your bookmarks.
    (setq bookmark-save-flag 1)
#+end_src

*** Bookmark+

With *Bookmark+* (which offers quite a bit more than =bm.el=):

- Bookmarks are *visible* in the buffer.

- Bookmarks can be as simple as marks -- *no naming needed*.

- You can *cycle* among them.

- You can bookmark arbitrary sets of files, from any locations.

- You can bookmark Dired buffers (which, again, can actually list arbitrary
  files, not even necessarily in the same directory).  Markings, subdir
  inclusions, and omissions are all recorded, and restored when you access the
  bookmark.

- You can tag bookmarks or files, using arbitrary strings as tags.  You can do
  this programmatically and interactively, by regexp, name, or Dired markings.
  Tags give you a great way to define sets of bookmarks or files -- sets that
  can overlap, etc.  They serve to categorize, but they can do more than that.
  You can use tags to, in effect, merge projects, split projects, define
  subprojects, and so on.

Key shortcuts:

| Command                       | Sublime Text | IntelliJ | Atom   | Webstorm |
|-------------------------------+--------------+----------+--------+----------|
| View All bookmarks            | M-F2         | S-F11    | C-F2   | S-F11    |
| Toggle bookmark               | C-F2         | F11      | C-M-F2 | F11      |
| Toggle bookmark with mnemonic |              | C-F11    |        | C-S-F11  |
| Jump to Next bookmark         | F2           | -        | F2     |          |
| Jump to Previous bookmark     | S-F2         | -        | S-F2   |          |
| Clear All Bookmarks           | C-S-F2       |          |        |          |

- ~C-x p RET~ (~C-<F2>~ in Emacs-Leuven, Sublime Text and TextMate) ::
     *Toggle* (*set* or delete) an *ANONYMOUS bookmark* at point.

- M-x bmkp-set-autonamed-regexp-buffer ::
     Set *ANONYMOUS bookmarks* at matches for REGEXP in the buffer.

- ~C-x p C-down~ (~S-<F2>~ in Emacs-Leuven, ~F2~ in Sublime Text and TextMate) ::
     Navigate to the *next bookmark* within the current buffer.

- ~C-x p C-up~ (~S-<F2>~ in Sublime Text and TextMate) ::
     Navigate to the *previous bookmark* within the current buffer.

- ~C-x j h~ ::
     Jump to a bookmark.

- C-x p , ::
     *Show all bookmarks* for the current file/buffer.

- C-x p DEL ::
     *Delete bookmark* (*ANONYMOUS* or *WITH MNEMONICS*) *at point*.

- ~C-S-<F2>~ (in Emacs-Leuven) ::
     *Delete all ANONYMOUS bookmarks* for the current file/buffer.

Buffer-local nature of the bookmarks.

Annotating bookmarks.

#+begin_src emacs-lisp
    ;; Extensions to standard library `bookmark.el'.
    (when (try-require 'bookmark+) ; XXX + needs bookmark+-mac

      ;; Toggle an ANONYMOUS bookmark on the current line.
      (global-set-key (kbd "<C-f2>") #'bmkp-toggle-autonamed-bookmark-set/delete)

      (global-set-key (kbd "<S-f2>") #'bmkp-next-bookmark-this-file/buffer-repeat)

      ;; Delete all ANONYMOUS bookmarks in a buffer.
      (global-set-key (kbd "<C-S-f2>") #'bmkp-delete-all-autonamed-for-this-buffer))

    (when (fboundp 'helm-bookmarks)
      ;; View all bookmarks.
      (global-set-key (kbd "<M-f2>") #'helm-bookmarks))

    (with-eval-after-load "bookmark+"

      (add-hook 'find-file-hook #'bmkp-light-this-buffer)

      ;; Priorities of bookmark highlighting overlay types.
      (setq bmkp-light-priorities '((bmkp-autonamed-overlays     . 150)
                                    (bmkp-non-autonamed-overlays . 160)))

      ;; Symbols for the fringe bitmaps to use to highlight a bookmark.
      (setq bmkp-light-left-fringe-bitmap 'filled-square)
      (setq bmkp-light-right-fringe-bitmap 'filled-square)

      ;; Default highlight style for ANONYMOUS (= default) bookmarks.
      (setq bmkp-light-style-autonamed 'line+lfringe)

      ;; Default highlight style for bookmarks WITH MNEMONICS.
      (setq bmkp-light-style-non-autonamed 'line+lfringe)

      ;; Automatically highlight bookmarks when set.
      (setq bmkp-auto-light-when-set 'all-in-buffer)

      ;; Automatically highlight bookmarks when jumped to.
      (setq bmkp-auto-light-when-jump 'all-in-buffer)

      ;; Don't propertize bookmark names to hold full bookmark data.
      (setq bmkp-propertize-bookmark-names-flag nil)
                                        ; We will often be going back and forth
                                        ; between using Bookmark+ and using
                                        ; vanilla Emacs.

      (setq bmkp-last-as-first-bookmark-file nil)

      ;; Name ANONYMOUS bookmarks with buffer name and line number.
      (setq bmkp-autoname-format "^%B:[0-9]+: %s")

      (setq bmkp-autoname-bookmark-function #'leuven-bmkp-autoname-line)

      (defun leuven-bmkp-autoname-line (position)
        "Name autonamed bookmark at POSITION using line number."
        (let ((line  (line-number-at-pos position)))
          ;; (format "%s:%d (%s)" (buffer-name) line (buffer-file-name))
          (format "%s:%d: %s"
                  (buffer-name)
                  line
                  (buffer-substring-no-properties
                   (line-beginning-position)
                   (1- (line-beginning-position 2))))))))
#+end_src

XXX They should always be in color when opening a buffer... not only when
jumping onto them...

#+begin_src emacs-lisp
    (with-eval-after-load "helm-autoloads"
      ;; Helm for bookmarks (filtered by category).
      (global-set-key (kbd "C-x r l") #'helm-filtered-bookmarks))
#+end_src

** Avy (alternative to Ace Jump)

#+begin_src emacs-lisp
  (with-eval-after-load "avy-autoloads"

    ;; ;; Quickly jump to a position in the current view. XXX Conflict with Org mode (in tables).
    ;; (global-set-key (kbd "C-c SPC") #'avy-goto-word-or-subword-1)

    ;; Jump back to previous position.
    (global-set-key (kbd "C-c C-SPC") #'avy-pop-mark)

    ;; Jump during Isearch to one of the current candidates.
    (define-key isearch-mode-map (kbd "C-'") #'avy-isearch)
    ;; (define-key isearch-mode-map (kbd "@")   #'avy-isearch)
  )
#+end_src

#+begin_src emacs-lisp
  ;; Jump to things.
  (with-eval-after-load "avy"

    ;; Default keys for jumping.
    (setq avy-keys (number-sequence ?a ?z))

    ;; Determine the list of windows to consider in search of candidates.
    (setq avy-all-windows 'all-frames)

    ;; Highlight the first decision char with `avy-lead-face-0'.
    (setq avy-highlight-first t))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 13 ends here.
#+end_src

* Controlling the Display

#+begin_src emacs-lisp
;;* 14 Controlling the (info "(emacs)Display")

(leuven--chapter leuven-load-chapter-14-display "14 Controlling the Display"
#+end_src

** Scrolling

#+begin_src emacs-lisp
;;** 14.1 (info "(emacs)Scrolling")

  (leuven--section "14.1 (emacs)Scrolling")

  ;; When scrolling, point preserves the cursor position in the buffer if the
  ;; original position is still visible.
  (setq scroll-preserve-screen-position t)
#+end_src

#+begin_src emacs-lisp
  ;; Better scrolling in Emacs (doing a <PageDown> followed by a <PageUp> will
  ;; place the point at the same place).
  (with-eval-after-load "pager-autoloads"

    (autoload 'pager-page-up "pager"
      "Like scroll-down, but moves a fixed amount of lines." t)
                                        ; These autoloads aren't defined in
                                        ; `pager-autoloads'!
    (autoload 'pager-page-down "pager"
      "Like scroll-up, but moves a fixed amount of lines." t)

    (global-set-key (kbd "<prior>") #'pager-page-up)
    (global-set-key (kbd "<next>")  #'pager-page-down))
#+end_src

** Automatic Scrolling

"Smooth" (civilized) scrolling.

#+begin_src emacs-lisp
;;** 14.3 (info "(emacs)Auto Scrolling")

  (leuven--section "14.3 (emacs)Auto Scrolling")

  ;; Scroll only one line at a time (redisplay will never recenter point).
  (setq scroll-conservatively 10000)    ; Or `most-positive-fixnum'.

  ;; Number of lines of margin at the top and bottom of a window.
  (setq scroll-margin 4)                ; Also for `isearch-forward'.

  ;; Scrolling down looks much better.
  (setq auto-window-vscroll nil)
#+end_src

** Horizontal Scrolling

How to automatically add/remove horizontal scrollbars as needed by text width?

** Narrowing

- ~C-x n n~ ::
     *Narrow* down to between point and mark.

- ~C-x n d~ ::
     *Narrow* down to the current *defun*.

- ~C-x n s~ ::
     *Narrow* buffer to the current *subtree* (bound in Org mode).

- ~C-x n w~ ::
     *Widen* to make the entire buffer accessible again.

#+begin_src emacs-lisp
;;** 14.5 (info "(emacs)Narrowing")

  (leuven--section "14.5 (emacs)Narrowing")

  ;; Enable the use of the command `narrow-to-region' without confirmation.
  (put 'narrow-to-region 'disabled nil)

  ;; (with-eval-after-load "fancy-narrow-autoloads"
  ;;   (fancy-narrow-mode)) ; perf problems when calling `helm-for-files' from a big file?
#+end_src

** Font Lock mode

#+begin_src emacs-lisp
;;** 14.12 (info "(emacs)Font Lock")

  (leuven--section "14.12 (emacs)Font Lock")
#+end_src

Prior to running their own mode hooks,
- all text-based major modes run ~text-mode-hook~, and
- all programming language modes run ~prog-mode-hook~.

Add font locking for the following patterns in upper case:

- ~TODO~,
- ~FIXME~,
- ~XXX~ and
- ~BUG~

to all modes except Diff mode and Org mode.

#+begin_note
In Eclipse, they are all *case in-sensitive* by default.
In IntelliJ IDEA, the are recognized in both lower and upper case.
#+end_note

#+begin_example
// TODO(fni) Please make sure that everything works
// FIXME[fni] Main method
// XXX-fni: Add comments
// BUG Review script body

/* TODO this is the normal way */
/* todo this is another to-do */
/*! \todo this is a doxygen to-do */
// TODO this is a C++ to-do comment
#+end_example

#+begin_src emacs-lisp
  (defface leuven-todo-patterns-face
    '((t :weight bold :box "#FF3125" :foreground "#FF3125" :background "#FFFF88"))
    "Face for making TODO items stand out.")

  ;; Highlight tasks.
  (defvar leuven-todo-patterns-in-org
    "\\<\\(\\(FIXME\\|XXX\\|BUG\\)\\(([^)]*)\\)?:?.*\\)" ; Start of word.
    "TODO patterns to highlight (for Org mode only).
  The goal is to ensure no conflict with the Org mode TODO keyword.")

  (defvar leuven-todo-patterns-anywhere
    "\\<\\(\\(TODO\\|FIXME\\|XXX\\|BUG\\)\\(([^)]*)\\)?:?.*\\)"
    "TODO patterns to highlight (for all modes).")

  ;; Add highlighting keywords.
  (defun leuven--highlight-todo-patterns ()
    "Highlight TODO patterns."
    (cond
     ((derived-mode-p 'org-mode)
      (font-lock-add-keywords nil         ; In the current buffer.
       `((,leuven-todo-patterns-in-org 1 'leuven-todo-patterns-face prepend)) 'end))
     ((not (derived-mode-p 'diff-mode))
      (font-lock-add-keywords nil         ; In the current buffer.
       `((,leuven-todo-patterns-anywhere 1 'leuven-todo-patterns-face prepend)) 'end))))

  (add-hook 'find-file-hook #'leuven--highlight-todo-patterns)
#+end_src

See doc of ~font-lock-keywords~ and ~font-lock-add-keywords~.

Check out ~log4j-mode~ instead?  And nice colors at
https://www.jetbrains.com/resharper/help/Regular_Expressions_Assistance.html.

#+begin_src emacs-lisp
  (global-set-key (kbd "<M-f6>")
                  #'(lambda ()
                      (interactive)
                      (occur "TODO\\|FIXME\\|XXX\\|BUG")))
#+end_src

#+begin_src emacs-lisp
  ;; Just-in-time fontification.
  (with-eval-after-load "jit-lock"

    ;; Stealth fontification should show status messages.
    (setq jit-lock-stealth-verbose t)

    ;; ;; Idle time after which deferred fontification should take place.
    ;; (setq jit-lock-defer-time 0.05)     ; Improve the scrolling speed in large
    ;;                                     ; files.
    )
#+end_src

** Interactive Highlighting

#+begin_src emacs-lisp
;;** 14.13 (info "(emacs)Highlight Interactively") by Matching

  (leuven--section "14.13 (emacs)Highlight Interactively by Matching")
#+end_src

#+begin_src emacs-lisp
  ;; Highlight-Changes mode.
  (with-eval-after-load "hilit-chg"
    (defvar highlight-fringe-mark 'filled-rectangle
      "The fringe bitmap name marked at changed line.
Should be selected from `fringe-bitmaps'.")

    (defun hilit-chg-make-ov--add-fringe ()
      (mapc #'(lambda (ov)
                (if (overlay-get ov 'hilit-chg)
                    (let ((fringe-anchor (make-string 1 ?x)))
                      (put-text-property 0 1 'display
                                         (list 'left-fringe highlight-fringe-mark)
                                         fringe-anchor)
                      (overlay-put ov 'before-string fringe-anchor))))
            (overlays-at (ad-get-arg 1))))
    (advice-add 'hilit-chg-make-ov :after #'hilit-chg-make-ov--add-fringe))

  ;; ;; Enable Global-Highlight-Changes mode.
  ;; (global-highlight-changes-mode 1)

  ;; ;; Changes are initially NOT visible in Highlight Changes mode.
  ;; (setq highlight-changes-visibility-initial-state nil)
#+end_src

You can use *Hi Lock* (part of Emacs) to highlight a regexp (identical tokens)
throughout a buffer.

- ~M-x hi-lock-mode RET~ ::
     Enable or disable Hi Lock mode.

- ~M-s h .~ ::
      *Highlight* each instance of the *symbol at point*.

- ~M-s h r REGEXP RET~ (~highlight-regexp~) ::
     Highlight text that *matches REGEXP*.

- ~M-s h l REGEXP RET~ ::
     Highlight *entire lines* containing a match for REGEXP.

- ~M-s h p~ (~highlight-phrase~) ::
     When called interactively, replace whitespace in user-provided
     regexp with arbitrary whitespace, and make initial lower-case
     letters case-insensitive, before highlighting with ~hi-lock-set-pattern~.

     ~highlight-phrase~ is just a bit of sugar around ~highlight-regexp~ that

     ignores case and translates a space in the regex to match arbitrary
     whitespace. Handy.

     Also, ~highlight-phrase~ is not fully case insensitive. Only initial
     lower-case letters (of words) ae made case insensitive. (I suppose it was
     intended to deal with fred vs Fred) .. eg it generates a regex like:
     ~[Cc]at[ ]+[Dd]og~

- ~M-s h u REGEXP RET~ ::
     *Unhighlight* REGEXP.

#+begin_src emacs-lisp
  ;; Do not prompt for the face to use. Instead, cycle through them.
  (setq hi-lock-auto-select-face t)

  ;; ;; Enable Hi Lock mode for all buffers.
  ;; (global-hi-lock-mode 1)
#+end_src

It is complementary to the features of the library *Hl-anything*.

- Hi Lock uses *text properties*.  Copying and pasting text will also paste the
  highlighting.

- Hl-anything uses *overlays*.  It prevents highlighted things to be hidden by
  hl-line mode.

  #+begin_note
  As *overlay highlighting* (used by ~hl-line~) *always takes priority over
  text-property highlighting*, the highlighting of symbols should use overlays at
  all times, and thus have higher priority over ~hl-line~ (because shorter
  overlays have an implicitly higher priority, given the same value of
  priority).

  *Use highlighting that is produced by an overlay!*

  + Highlight from Drew Adams
  + highlight-symbol from Nicolas
  + Symbol-overlay from Wolray
  #+end_note

- Hi Lock and Hl-anything both *highlight new text* as you type it.

- Hl-anything lets you *navigate among highlights*: ~hl-find-next-thing~,
  ~hl-find-prev-thing~.

- ~Hl-anything~ automatically chooses *rainbow colors* and makes it much easier to
  follow some key variables through a block of code.

#+begin_note
We tend to think of highlighting a buffer region with a background as putting
such a background behind or underneath the text.  Think of a marker pen
(highlighter) instead: the highlighting goes on top.
#+end_note

#+begin_src emacs-lisp
  ;; ;; Highlight symbols, selections, enclosing parens and more.
  ;; (with-eval-after-load "hl-anything-autoloads"
  ;;
  ;;   (setq hl-highlight-background-colors '("#C7FF85" "#FFFA85" "#85FFFA" "#FCACFF"))
  ;;   ;; See the very good hl-paren-mode.
  ;;
  ;;   ;; Don't save and restore highlight.
  ;;   (setq hl-highlight-save-file nil)
  ;;
  ;;   ;; Emulation of Vim's `*' search.
  ;;   (global-set-key (kbd "C-*")      #'hl-highlight-thingatpt-global)
  ;;   (global-set-key (kbd "C-<f4>")   #'hl-find-next-thing)
  ;;   (global-set-key (kbd "S-<f4>")   #'hl-find-prev-thing)
  ;;   (global-set-key (kbd "C-M-*")    #'hl-unhighlight-all-global))
  ;;
  ;;   ;; ;; Find Next / Move to Next Occurrence.
  ;;   ;; (global-set-key (kbd "<f3>")     #'hl-find-next-thing)
  ;;   ;;
  ;;   ;; ;; Find Previous / Move to Previous Occurrence.
  ;;   ;; (global-set-key (kbd "<S-f3>")   #'hl-find-prev-thing)
  ;;   ;;
  ;;   ;; ;; Find Word at Caret.
  ;;   ;; (global-set-key (kbd "<C-f3>")   #'hl-highlight-thingatpt-global)
  ;;   ;;
  ;;   ;; ;; Highlight Usages in File.
  ;;   ;; (global-set-key (kbd "<C-S-f7>") #'hl-highlight-thingatpt-global)


(when (try-require 'symbol-overlay) ; XXX
  (global-set-key (kbd "<C-S-f7>") 'symbol-overlay-put)
  (global-set-key (kbd "<f3>") 'symbol-overlay-switch-forward)
  (global-set-key (kbd "<S-f3>") 'symbol-overlay-switch-backward)
  ;; (global-set-key (kbd "<f7>") 'symbol-overlay-mode)
  ;; (global-set-key (kbd "<f8>") 'symbol-overlay-remove-all)
  )
#+end_src

Use Auto-Highlight-Symbol to *automatically highlight* all found *usages of* the
*symbol at point* in the current file (if you pause on a symbol).  When you move
point, the highlighting goes away.

#+begin_tip
~ahs~ can find the *definition* of a symbol, and colors it differently!
#+end_tip

#+begin_src emacs-lisp
  ;; Automatic highlighting occurrences of the current symbol under cursor.
  (when (try-require 'auto-highlight-symbol) ; XXX

    ;; Add major modes Auto-Highlight-Symbol can run on.
    (mapc #'(lambda (mode)
              (add-to-list 'ahs-modes mode t))
          '(js2-mode
            ess-mode))                  ; R.

    ;; Number of seconds to wait before highlighting the current symbol.
    (setq ahs-idle-interval 0.2) ; 0.35.

    ;; Unset AHS key bindings that override Org key bindings.
    (define-key auto-highlight-symbol-mode-map (kbd "<M-left>")    nil)
    (define-key auto-highlight-symbol-mode-map (kbd "<M-right>")   nil)
    (define-key auto-highlight-symbol-mode-map (kbd "<M-S-left>")  nil)
    (define-key auto-highlight-symbol-mode-map (kbd "<M-S-right>") nil)

    ;; ;; Toggle Auto-Highlight-Symbol mode in all buffers.
    ;; (global-auto-highlight-symbol-mode t)

    ;; Enable Auto-Highlight-Symbol mode in all programming mode buffers.
    (add-hook 'prog-mode-hook #'auto-highlight-symbol-mode)

    ;; Enable Auto-Highlight-Symbol mode in LaTeX mode.
    (add-hook 'latex-mode-hook #'auto-highlight-symbol-mode)
    )
#+end_src

XXX Check out ~light-symbol~.

Color Identifiers Mode: *color* every *variable* in its own, consistent color.

#+begin_src emacs-lisp
;; XXX Impact on Org's HTML export?
  ;; (with-eval-after-load "color-identifiers-mode-autoloads"
  ;;
  ;;   (add-hook 'after-init-hook #'global-color-identifiers-mode))
#+end_src

** Window Fringes

Show an icon in the fringe of version-controlled files indicating which *lines*
have been *edited* (inserted, modified or deleted) *since the last commit*.  Similar
to Git Gutter.

This feature gives you a really nice at-a-glance view of where you've made
changes.

#+begin_tip
If you need to know what lines changed in latest commit as well, you can enable
~diff-hl-amend-mode~ to *show changes against the second-last revision*.
#+end_tip

#+begin_src emacs-lisp
  (with-eval-after-load "diff-hl-autoloads"
    (idle-require 'diff-hl))

  ;; Indicate changes in the fringe.
  (with-eval-after-load "diff-hl"

    (global-diff-hl-mode 1)
#+end_src

If you're using some package other than ~vc~ to commit changes, it might not run
~vc-checkin-hook~ after commits.  In that case, you'll need to either add
~diff-hl-update~ to the hook it does run, or advise some function that's called in
the buffer after its state has changed.

#+begin_note
Of course, ~diff-hl~ is not updated when we commit changes with our ~sendpatch~
utility...
#+end_note

Jump between changes:

#+begin_src emacs-lisp
    ;; Move to Next Change (also on `C-x v ]').
    (define-key diff-hl-mode-map (kbd "C-x v >")      #'diff-hl-next-hunk)
    (define-key diff-hl-mode-map (kbd "M-g <down>")   #'diff-hl-next-hunk)
    (define-key diff-hl-mode-map (kbd "<C-M-S-down>") #'diff-hl-next-hunk) ;; IntelliJ IDEA.

    ;; Move to Previous Change (also on `C-x v [').
    (define-key diff-hl-mode-map (kbd "C-x v <")      #'diff-hl-previous-hunk)
    (define-key diff-hl-mode-map (kbd "M-g <up>")     #'diff-hl-previous-hunk)
    (define-key diff-hl-mode-map (kbd "<C-M-S-up>")   #'diff-hl-previous-hunk) ;; IntelliJ IDEA.
#+end_src

Act on changes:

#+begin_src emacs-lisp
    ;; Popup current diff.
    (define-key diff-hl-mode-map (kbd "C-x v =") #'diff-hl-diff-goto-hunk)

    ;; Revert current hunk (also on `C-x v n').
    (define-key diff-hl-mode-map (kbd "C-x v u") #'diff-hl-revert-hunk))
#+end_src

#+begin_src emacs-lisp :tangle no
    (defun magit-refresh--diff-hl-refresh-after ()
      (dolist (buffer (buffer-list))
        (with-current-buffer buffer
          (when diff-hl-mode
            (diff-hl-update)))))
    (advice-add 'magit-refresh :after #'magit-refresh--diff-hl-refresh-after)
#+end_src

#+begin_src emacs-lisp :tangle no
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
#+end_src

#+begin_tip
Is It Possible To Replace Fringe Bitmaps With Text in Emacs?
http://stackoverflow.com/questions/16114700/is-it-possible-to-replace-fringe-bitmaps-with-text-in-emacs
#+end_tip

** Displaying Boundaries

#+begin_src emacs-lisp
;;** 14.15 (info "(emacs)Displaying Boundaries")

  (leuven--section "14.15 (emacs)Displaying Boundaries")

  ;; Visually indicate buffer boundaries and scrolling in the fringe.
  (setq-default indicate-buffer-boundaries '((top . left) (t . right)))
#+end_src

XXX display-fill-column-indicator-mode in Emacs 27

** Useless Whitespace

#+begin_src emacs-lisp
;;** 14.16 (info "(emacs)Useless Whitespace")

  (leuven--section "14.16 (emacs)Useless Whitespace")
#+end_src

Make trailing whitespace at the end of a line visible.

#+begin_src emacs-lisp
  ;; ;; Highlight trailing whitespaces in all modes.
  ;; (setq-default show-trailing-whitespace t)
#+end_src

Remove trailing whitespace (right trim lines) *in all lines*:

#+begin_src emacs-lisp :tangle no
  ;; Nuke all trailing whitespaces in the buffer.
  (add-hook 'before-save-hook
            #'(lambda ()                  ; Except for ...
                (let ((buffer-undo-list buffer-undo-list)) ; For goto-chg.
                  (unless (or (derived-mode-p 'message-mode)
                                        ; ... where "-- " is the signature
                                        ; separator (for when using emacsclient
                                        ; to compose emails and doing C-x #).
                              (derived-mode-p 'diff-mode))
                                        ; ... where the patch file can't be
                                        ; changed!
                    (delete-trailing-whitespace)))))
#+end_src

This command also deletes all *empty lines at the end of the buffer*.

Remove trailing whitespace *in edited lines* with ~ws-butler~:

#+begin_src emacs-lisp
  ;; Unobtrusively remove trailing whitespace.
  (with-eval-after-load "ws-butler-autoloads"
    (add-hook 'text-mode-hook #'ws-butler-mode)
    (add-hook 'prog-mode-hook #'ws-butler-mode))

  (with-eval-after-load "ws-butler"

    ;; ;; Remove all tab/space indent conversion.
    ;; (defun ws-butler-clean-region (beg end)
    ;;   "Delete trailing blanks in region BEG END."
    ;;   (interactive "*r")
    ;;   (ws-butler-with-save
    ;;    (narrow-to-region beg end)
    ;;    ;;  _much slower would be:       (replace-regexp "[ \t]+$" "")
    ;;    (goto-char (point-min))
    ;;    (while (not (eobp))
    ;;      (end-of-line)
    ;;      (delete-horizontal-space)
    ;;      (forward-line 1)))
    ;;   ;; clean return code for hooks
    ;;   nil)

    (diminish 'ws-butler-mode))
#+end_src

#+begin_warning
If ~indent-tabs-mode~ is nil, then *tabs in indentation is replaced by spaces* (only
for lines modified by you).
#+end_warning

#+begin_src emacs-lisp
  ;; Visually indicate empty lines after the buffer end in the fringe.
  (setq-default indicate-empty-lines t)
#+end_src

When Whitespace mode is on, it takes care of highlighting some special
characters over the default mechanism of ~nobreak-char-display~ and
~show-trailing-whitespace~.

#+begin_src emacs-lisp
  ;; Enable Whitespace mode in all file buffers (not in *vc-dir*, etc.).
  (add-hook 'text-mode-hook #'whitespace-mode)
  (add-hook 'prog-mode-hook #'whitespace-mode)

  (with-eval-after-load "whitespace"

    ;; Which kind of blank is visualized (Show Invisibles).
    (setq whitespace-style
          '(face
            trailing
            tabs
            ;; lines-tail
            indentation::space
            space-mark
            tab-mark))

    ;; Column beyond which the line is highlighted.
    (setq whitespace-line-column 80)

    ;; Mappings for displaying characters.
    (setq whitespace-display-mappings
          '((space-mark ?\u00A0         ; No-break space.
                        [?_]            ; Spacing underscore.
                        [?_])           ; Spacing underscore.

            (space-mark ?\u202F         ; Narrow no-break space.
                        [?\u00B7]       ; Middle dot.
                        [?.])

            (tab-mark ?\t               ; Tabulation.
                      [?\u25BA ?\t]     ; Black right-pointing pointer.
                      [?\\ ?\t]))))
#+end_src

Example :
VPATH=		/home/jt/src/cygwin/cygwin-packages/1.7/python-2.6.8-2/python-2.6.8-2/src/Python-2.6.8
LDLAST=
SGI_ABI=
PYTHON_OBJS=	\
                Python/pythonrun.o \
                Python/random.o \
                Python/structmember.o

#+begin_src emacs-lisp
  ;; ;; Control highlighting of non-ASCII space and hyphen chars, using the
  ;; ;; `nobreak-space' or `escape-glyph' face respectively.
  ;; (setq nobreak-char-display t)      ; [Default]
#+end_src

#+begin_src emacs-lisp
  ;; ;; Show zero-width spaces.
  ;; (font-lock-add-keywords nil
  ;;  `((,(format "\\(%c\\)" ?\u200B) ; #\ZERO_WIDTH_SPACE
  ;;     (1 (progn (compose-region (match-beginning 1) (match-end 1)
  ;;                               ?\u2B1B ; #\BLACK_LARGE_SQUARE
  ;;                               'decompose-region)
  ;;               nil)))))
#+end_src

** Selective Display

Emacs has the ability to *hide lines indented more than a given number of
columns*.  You can use this to get an overview of a part of a program.

To hide lines with at least 1 column of indentation (replacing them by an
ellipsis), type ~C-1 C-x $~ (or ~C-x $~ and give it ~1~ as depth argument).  It gives
a quick overview any source file.

To make all lines visible again, type ~C-x $~ with no argument.

See also *Outline Mode* for another way to hide part of the text in a buffer.

** Optional Mode Line Features

#+begin_src emacs-lisp
;;** 14.18 (info "(emacs)Optional Mode Line") Features

  (leuven--section "14.18 (emacs)Optional Mode Line Features")

  ;; Show the column number in each mode line.
  (column-number-mode 1)
#+end_src

#+begin_src emacs-lisp
  ;; Unclutter the mode line.
  (with-eval-after-load "diminish-autoloads"
    (with-eval-after-load "abbrev"       (diminish 'abbrev-mode " Ab"))
    (with-eval-after-load "back-button"  (diminish 'back-button-mode))
    (with-eval-after-load "volatile-highlights" (diminish 'volatile-highlights-mode))
    (with-eval-after-load "checkdoc"     (diminish 'checkdoc-minor-mode " Cd"))
    ;; (with-eval-after-load "company"      (diminish 'company-mode " Cp"))
                                        ; Company displays the currently used
                                        ; backend in the mode-line.
    (with-eval-after-load "eldoc"        (diminish 'eldoc-mode))
    (with-eval-after-load "color-identifiers-mode" (diminish 'color-identifiers-mode))
    (with-eval-after-load "fancy-narrow" (diminish 'fancy-narrow-mode))
    (with-eval-after-load "flycheck"     (diminish 'flycheck-mode " fC")) ; Wanna see FlyC:1/1.
    (with-eval-after-load "flyspell"     (diminish 'flyspell-mode " fS"))
    (with-eval-after-load "google-this"  (diminish 'google-this-mode))
    (with-eval-after-load "hilit-chg"    (diminish 'highlight-changes-mode))
    ;; (with-eval-after-load "isearch"      (diminish 'isearch-mode (string 32 ?\u279c)))
    (with-eval-after-load "paredit"      (diminish 'paredit-mode " Pe"))
    (with-eval-after-load "rainbow-mode" (diminish 'rainbow-mode))
    (with-eval-after-load "simple"       (diminish 'auto-fill-function))
    (with-eval-after-load "whitespace"   (diminish 'whitespace-mode))
    ;; (diminish-on-load hs-minor-mode-hook hs-minor-mode)
    (with-eval-after-load "glasses"      (diminish 'glasses-mode))
    ;; (with-eval-after-load "redshank"     (diminish 'redshank-mode))
    ;; (with-eval-after-load "smartparens"  (diminish 'smartparens-mode)) ;; Don't hide it, as it impacts perf on big files (must see it!)
    (with-eval-after-load "which-key"    (diminish 'which-key-mode)))
    ;; (with-eval-after-load "whitespace"   (diminish 'whitespace-mode))
#+end_src

See https://powerline.readthedocs.org/en/latest/overview.html#vim-statusline for screenshots.

See https://github.com/bling/vim-airline for the original author.

We build our mode line:

- Git/SVN branch
- buffer-read-only / buffer-modified-p
- mule environment
- buffer name
- which function information
- major mode
- minor modes
- line number, column number
- percent
- buffer size
- dictionary

#+begin_src emacs-lisp
  (defface powerline-modified-face
    '((((class color))
       (:background "#FFA335" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify modified files."
    :group 'powerline)

  (defface powerline-normal-face
    '((((class color))
       (:background "#4F9D03" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify unchanged files."
    :group 'powerline)

  (defface powerline-default-dictionary-active-face
    '((((class color))
       (:background "#8A2BE2" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify default dictionary in the active buffer."
    :group 'powerline)

  (defface powerline-default-dictionary-inactive-face
    '((((class color))
       (:background "thistle" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify default dictionary in inactive buffers."
    :group 'powerline)

  (defface powerline-other-dictionary-active-face
    '((((class color))
       (:background "yellow" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify another dictionary in the active buffer."
    :group 'powerline)

  (defface powerline-other-dictionary-inactive-face
    '((((class color))
       (:background "LightYellow1" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify another dictionary in inactive buffers."
    :group 'powerline)

  (defface powerline-buffer-position-face
    '((((class color))
       (:background "#D2D2D2" :foreground "#282828"))
      (t (:weight bold)))
    "Face to fontify buffer position."
    :group 'powerline)

  (defun powerline-simpler-vc-mode (s)
    (if s
        (replace-regexp-in-string "\\(Git\\|SVN\\)[-:]" "" s)
      s))

  (defun powerline-leuven-theme ()
    "Setup the leuven mode-line."
    (interactive)
    (setq-default mode-line-format
     '("%e"
       (:eval
        (let* ((active (powerline-selected-window-active))
               (mode-line (if active
                              'mode-line
                            'mode-line-inactive))
               (face1 (if active
                          'powerline-active1
                        'powerline-inactive1))
               (face2 (if active
                          'powerline-active2
                        'powerline-inactive2))
               (default-dictionary-face
                 (if active
                     'powerline-default-dictionary-active-face
                   'powerline-default-dictionary-inactive-face))
               (other-dictionary-face
                (if active
                    'powerline-other-dictionary-active-face
                  'powerline-other-dictionary-inactive-face))
               (separator-left
                (intern
                 (format "powerline-%s-%s"
                         powerline-default-separator
                         (car powerline-default-separator-dir))))
               (separator-right
                (intern
                 (format "powerline-%s-%s"
                         powerline-default-separator
                         (cdr powerline-default-separator-dir))))
               (lhs (list
                     ;; VC mode.
                     (when (and (fboundp 'vc-switches)
                                buffer-file-name
                                vc-mode)
                       (if (eq (vc-state buffer-file-name) 'up-to-date)
                           (powerline-simpler-vc-mode (powerline-vc 'powerline-normal-face 'r))
                         (powerline-simpler-vc-mode (powerline-vc 'powerline-modified-face 'r))))

                     (when (and (not (fboundp 'vc-switches))
                                buffer-file-name
                                vc-mode)
                       (powerline-simpler-vc-mode (powerline-vc face1 'r)))

                     (when (and buffer-file-name
                                vc-mode)
                       (if (eq (vc-state buffer-file-name) 'up-to-date)
                           (funcall separator-left 'powerline-normal-face mode-line)
                         (funcall separator-left 'powerline-modified-face mode-line)))

                     ;; "Modified" indicator.
                     (if (not (buffer-modified-p))
                         (powerline-raw "%*" nil 'l)
                       (powerline-raw "%*" 'mode-line-emphasis 'l))

                     (powerline-raw mode-line-mule-info nil 'l)

                     (powerline-buffer-id 'mode-line-buffer-id 'l)

                     (when (and (boundp 'which-func-mode) which-func-mode)
                       (powerline-raw which-func-format nil 'l))

                     (powerline-raw " ")
                     (funcall separator-left mode-line face1)
                     (when (boundp 'erc-modified-channels-object)
                       (powerline-raw erc-modified-channels-object face1 'l))
                     (powerline-major-mode face1 'l)
                     (powerline-process face1)
                     (powerline-raw " " face1)
                     (funcall separator-left face1 face2)
                     (powerline-minor-modes face2 'l)
                     (powerline-narrow face2 'l)
                     (powerline-raw " " face2)
                     (funcall separator-left face2 mode-line)))
               (rhs (list (powerline-raw global-mode-string mode-line 'r)
                          (funcall separator-right mode-line face1)
#+end_src

*************** TODO Show column in red when we go over the 80th character
See http://www.elliotglaysher.org/emacs/
*************** END

#+begin_src emacs-lisp
                          (powerline-raw "%l," face1 'l)
                          (powerline-raw "%c" face1 'r)
                          (funcall separator-right face1 'powerline-buffer-position-face)
                          (powerline-raw " %3p" 'powerline-buffer-position-face 'r)
                          (funcall separator-right 'powerline-buffer-position-face face2)
                          (powerline-buffer-size face2 'l)
                          (powerline-raw " " face2)

                          (let ((dict (and (featurep 'ispell)
                                           (or
                                            ispell-local-dictionary
                                            ispell-dictionary))))
                            ;; Add 2 spaces after the language indicator
                            ;; (for GNU/Linux).
                            (cond (buffer-read-only
                                   (powerline-raw "%%%%  " default-dictionary-face 'l))
                                  ((null dict)
                                   (powerline-raw "--  " default-dictionary-face 'l))
                                  (t
                                   (powerline-raw (concat (substring dict 0 2) "  ") other-dictionary-face 'l))))

                          ;; (powerline-hud face2 face1)
                          )))
          (concat (powerline-render lhs)
                  (powerline-fill mode-line (powerline-width rhs))
                  (powerline-render rhs)))))))

  (with-eval-after-load "powerline-autoloads"
    (add-hook 'after-init-hook #'powerline-leuven-theme))
#+end_src

** How Text Is Displayed

#+begin_src emacs-lisp
;;** 14.19 The (info "(emacs)")

  (leuven--section "14.19 (emacs)")

  ;; Display width of a TAB character.
  (setq-default tab-width 4)
#+end_src

** Displaying the Cursor

#+begin_src emacs-lisp
;;** 14.20 The (info "(emacs)Cursor Display")

  (leuven--section "14.20 (emacs)The Cursor Display")
#+end_src

Colorize cursor according to state.

#+begin_src emacs-lisp
  ;; Use cursor color and type to indicate some modes (read-only, overwrite
  ;; and normal insert modes).
  (defun leuven--set-cursor-according-to-mode ()
    "Change cursor color according to some minor modes."
    (let ((color (cond (buffer-read-only "purple1")
                       (overwrite-mode   "#7F7F7F")
                       (t                "black"))) ; #21BDFF is less visible.
          (type (if (null overwrite-mode)
                    'bar
                  'box)))
      (set-cursor-color color)
      (setq cursor-type type)))

  (add-hook 'post-command-hook #'leuven--set-cursor-according-to-mode)

  ;; Cursor to use.
  (setq-default cursor-type 'bar)

  ;; Cursor blinks forever.
  (setq blink-cursor-blinks 0)
#+end_src

Highlight the current line:

#+begin_src emacs-lisp
  ;; Toggle line highlighting in all buffers (Global Hl-Line mode).
  (global-hl-line-mode 1)               ; XXX Perhaps only in prog-modes?

  ;; ;; Extensions to hl-line.el.
  ;; (with-eval-after-load "hl-line+-autoloads"
  ;;
  ;;   ;; Disable Global Hl-Line mode.
  ;;   (global-hl-line-mode -1)
  ;;
  ;;   ;; Turn on `global-hl-line-mode' only when Emacs is idle.
  ;;   (toggle-hl-line-when-idle))

;; hl-line-overlay-priority
  ;; (require 'hl-line+) ; Load this file (it will load `hl-line.el')
#+end_src

** Truncation of Lines

#+begin_src emacs-lisp
;;** 14.21 (info "(emacs)Line Truncation")

  (leuven--section "14.21 (emacs)Line Truncation")

  ;; Respect the value of `truncate-lines' in all windows less than the full
  ;; width of the frame.
  (setq truncate-partial-width-windows nil)
#+end_src

** Customization of Display

#+begin_src emacs-lisp
;;** 14.23 (info "(emacs)Display Custom")ization

  (leuven--section "14.23 (emacs)Display Customization")

  ;; Echo what I'm typing *immediately*.
  (setq echo-keystrokes 0.01)

  ;; Let emacs react faster to keystrokes.
  (setq idle-update-delay 0.35)
#+end_src

Display pressed keyboard shortcuts on screen during presentations or
screencasts.

XXX command-log-mode
XXX view-lossage

#+begin_src emacs-lisp
  ;; Exhaustive log of interactions with Emacs (display keystrokes, etc.).
  (with-eval-after-load "interaction-log-autoloads"

    (autoload 'interaction-log-mode "interaction-log"
      "Global minor mode logging keys, commands, file loads and messages." t)
                                        ; This autoload isn't defined in
                                        ; `interaction-log-autoloads'!

    ;; ;; Maximum number of lines to keep in the *Emacs Log* buffer.
    ;; (setq ilog-log-max 10)

    (defun leuven-display-interaction-log ()
      "Display the Interaction-Log buffer."
      (interactive)
      (interaction-log-mode 1)
      (display-buffer ilog-buffer-name))

    ;; Hotkey for showing the log buffer.
    (global-set-key (kbd "C-h C-l") #'leuven-display-interaction-log))
#+end_src

#+begin_note
View-lossage is much improved in Emacs 25, showing directly which commands were
run by each keypress.
#+end_note

#+begin_src emacs-lisp
)                                       ; Chapter 14 ends here.
#+end_src

* Searching and Replacement

#+begin_src emacs-lisp
;;* 15 (info "(emacs)Search")ing and Replacement

(leuven--chapter leuven-load-chapter-15-search "15 Searching and Replacement"
#+end_src

** Incremental Search (aka "Live Search")

Have a look at the "Standard Isearch Keys" on
http://www.emacswiki.org/emacs/IncrementalSearch

Isearch has a binding which deletes all the non-matching characters from the
search string: ~C-g~ (not a very intuitive binding, because it's usually
associated with aborting operations, not with correcting things).

If you hit ~M-e~ (to edit the search string), the cursor is moved to the mismatch
position.

Since Emacs 24.3:
- ~M-s _~ starts a symbol (identifier) incremental search.
- ~M-s _~ in Isearch toggles symbol search mode.
- ~M-s c~ in Isearch toggles search case-sensitivity.

Since Emacs 27.1, to *go to the first/last occurrence of the current search
string* is possible with new commands ~isearch-beginning-of-buffer~ and
~isearch-end-of-buffer~ bound to ~M-s M-<~ and ~M-s M->~ in Isearch.

#+begin_src emacs-lisp
;;** 15.1 (info "(emacs)Incremental Search")

  (leuven--section "15.1 (emacs)Incremental Search")

  ;; FIXME Error when selecting search string from kill ring (`M-p')
  ;; ;; Always exit searches at the beginning of the expression found.
  ;; (add-hook 'isearch-mode-end-hook #'isearch-goto-match-beginning)
  ;;
  ;; (defun isearch-goto-match-beginning ()
  ;;   "Use with isearch hook to end search at first char of match."
  ;;   (when isearch-forward (goto-char isearch-other-end)))

  ;; ;; Incremental search/query-replace will open the contents.
  ;; (setq search-invisible 'open)         ; XXX

  ;; Don't re-hide an invisible match right away.
  (setq isearch-hide-immediately nil)   ; XXX

  ;; Scrolling commands are allowed during incremental search (without canceling
  ;; Isearch mode).
  (setq isearch-allow-scroll t)
#+end_src

Search for string ignoring new lines: incremental search will see any number of
white spaces, tab spaces, and line breaks as a simple white space.

#+begin_src emacs-lisp
(setq isearch-regexp-lax-whitespace t)
(setq search-whitespace-regexp "[ \t\r\n]+")
#+end_src

#+begin_note
When ~search-invisible~ is ~t~, ~perform-replace~ can replace matches in any invisible
text, but does not display it when prompting the user for confirmation.

When ~search-invisible~ is ~'open~, ~perform-replace~ can replace matches only in
hidden text (invisible through an overlay), and displays it when prompting the
user.

We lack a way to reveal truly invisible text when performing a search and
replace.  The URL of a bracket link in Org is an example of such truly invisible
text.

Juri's solution to add ~'open-all~ could also be used in ~perform-replace~ to let
the user see truly invisible matches before replacing them.
#+end_note

#+begin_src emacs-lisp
  ;; Fuzzy matching utilities (a must-have).
  (with-eval-after-load "fuzzy-autoloads"

    (autoload 'turn-on-fuzzy-isearch "fuzzy" nil t)
                                        ; This autoload isn't defined in
                                        ; `fuzzy-autoloads'!

    (add-hook 'isearch-mode-hook #'turn-on-fuzzy-isearch))
#+end_src

#+begin_src emacs-lisp
  ;; Show number of matches in mode-line while searching.
  (with-eval-after-load "anzu-autoloads"

    ;; Lighter of anzu-mode.
    (setq anzu-mode-lighter "")

    ;; Deactive region if you use anzu a replace command with region.
    (setq anzu-deactivate-region t)

    ;; Separator of `to' string.
    (setq anzu-replace-to-string-separator " => ")

    ;; Function which returns mode-line string.
    (defun leuven--anzu-update-mode-line (here total)
      (when anzu--state
        (let ((status (cl-case anzu--state
                        (search (format (if (> total 1)
                                            " %s of %d%s matches "
                                          " %s of %d%s match ")
                                        (anzu--format-here-position here total)
                                        total (if anzu--overflow-p "+" "")))
                        (replace-query (format " %d replace " total))
                        (replace (format (if (> total 1)
                                             " %d of %d matches "
                                           " %d of %d match ")
                                         here total))))
              (face (if (and (zerop total) (not (string= isearch-string "")))
                        'anzu-mode-line-no-match
                      'anzu-mode-line)))
          (propertize status 'face face))))
    (setq anzu-mode-line-update-function #'leuven--anzu-update-mode-line)

    ;; Enable Global-Anzu mode.
    (global-anzu-mode 1)

    ;; Override binding for `query-replace'.
    (global-set-key (kbd "M-%")   #'anzu-query-replace)
    (global-set-key (kbd "C-M-%") #'anzu-query-replace-regexp)

    ;; (define-key isearch-mode-map (kbd "M-%") #'anzu-query-replace)
    )
#+end_src

** Symbol Search

- ~M-s .~ (~isearch-forward-symbol-at-point~) ::
     Start a symbol (identifier) incremental search forward with the symbol
     found near point added to the search string initially.

** Regexp Search

Emacs uses basic regular expressions, which means that the extended regexp
operators have to be escaped.  This means you have to use ~\(~, ~\|~, and ~\)~
instead of ~(~, ~|~, and ~)~.

You can build regexps with visual feedback by using:
- ~M-x re-builder~ or
- ~M-x regex-tool~ (by John Wiegley)

Optimize regexps with =regexp-opt.el=.

#+begin_src emacs-lisp
;;** 15.5 (info "(emacs)Regexp Search")

  (leuven--section "15.5 (emacs)Regexp Search")
#+end_src

#+begin_src emacs-lisp :tangle no
  ;; Use regexps by default (allows searching across line breaks).
  (global-set-key (kbd "C-s") #'isearch-forward-regexp)
  (global-set-key (kbd "C-r") #'isearch-backward-regexp)

  ;; Shift the meaning of `C-M-s/r' with `C-s/r'.
  (global-set-key (kbd "C-M-s") #'isearch-forward)
  (global-set-key (kbd "C-M-r") #'isearch-backward)
#+end_src

*** IELM                                                              :noexport:

In IELM, list the input line, followed by the first nine substrings matches, to
debug regexp searches (in IELM)

Example:

#+begin_example
ELISP> (save-excursion (set-buffer "BUFFER")
                       (re-search-forward "REGEXP" nil t)
                       (leuven-buffer-matched-strings))
#+end_example

#+begin_src emacs-lisp
  (defun leuven-buffer-matched-strings ()
    (interactive)
    (mapcar 'leuven--buffer-matched-string-nth '(0 1 2 3 4 5 6 7 8 9)))

  (defun leuven--buffer-matched-string-nth (n)
    "Return the Nth pattern-matched string from the current buffer."
    (if (and (match-beginning n) (match-end n))
        (if (> (match-end n) (match-beginning n))
            (buffer-substring (match-beginning n) (match-end n))
          "")
      nil))
#+end_src

** Search Case

#+begin_src emacs-lisp
;;** 15.9 (info "(emacs)Search Case")

  (leuven--section "15.9 (emacs)Search Case")
#+end_src

*Case folding* folds together "a" and "A".

#+begin_src emacs-lisp
  ;; Searches should ignore case by default (in all buffers that do not
  ;; override this).
  (setq-default case-fold-search t)
#+end_src

*Char folding* allows simple ASCII characters to match their complex Unicode
counterparts.  For instance, if you search for "a", you will also match "" and
""; that is, char folding folds together "a", "" and "".

#+begin_src emacs-lisp :tangle no
  (setq search-default-mode 'char-fold-to-regexp)
#+end_src

You can also *toggle character folding* in the middle of a search by typing ~M-s '~.

** Replacement Commands

Pass the string or the regexp directly to ~query-replace~, so you can't mangle it
on the way, by pressing ~M-%~ while at the ~I-search:~ prompt.

~query-replace~ honors *character folding* if the new variable ~replace-char-fold~ is
customized to a non-nil value.

** Other Search-and-Loop Commands

~M-x flush-lines~ (or ~delete-matching-lines~) deletes each line that contains
a match for REGEXP.

There is also the opposite command, ~M-x keep-lines~, which deletes all lines
except those containing matches for REGEXP.

#+begin_src emacs-lisp
;;** 15.11 (info "(emacs)Other Repeating Search") Commands

  (leuven--section "15.11 (emacs)Other Repeating Search Commands")

  (global-unset-key (kbd "M-o")) ; XXX???

  ;; "Multi-occur" easily inside Isearch.
  (define-key isearch-mode-map (kbd "M-o") #'helm-multi-swoop-all)

  ;; Grep all same extension files from inside Isearch.
  (define-key isearch-mode-map (kbd "C-M-o")
    #'(lambda ()
        (interactive)
        (grep-compute-defaults)
        (lgrep (if isearch-regexp isearch-string (regexp-quote isearch-string))
               (if (file-name-extension (buffer-file-name))
                   (format "*.%s" (file-name-extension (buffer-file-name)))
                 "*")
               default-directory)
        (isearch-abort)))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 15 ends here.
#+end_src

* Commands for Fixing Typos

#+begin_src emacs-lisp
;;* 16 Commands for (info "(emacs)Fixit") Typos

(leuven--chapter leuven-load-chapter-16-fixit "16 Commands for Fixing Typos"
#+end_src

** Checking and Correcting Spelling

#+begin_note
On Windows:
- Install [[http://ftp.gnu.org/gnu/aspell/w32/Aspell-0-50-3-3-Setup.exe][GNU Aspell 0.50.3]] (more dictionaries than Cygwin Aspell)
- Install [[http://ftp.gnu.org/gnu/aspell/w32/Aspell-en-0.50-2-3.exe][Aspell English dictionary-0.50-2]]
- Add ~C:\Program Files (x86)\Aspell\bin~ to the System ~PATH~
#+end_note

GNU *Aspell* is better than *Ispell*:

- It does recognize words with apostrophes (l'avion)... but it is slower.

- It can handle UTF-8 documents far better than Ispell can.

When spellchecking a buffer, the ~A~ command accepts an incorrect word, and adds
it to the *file word list* (~ispell-add-per-file-word-list~).

#+begin_src emacs-lisp
;;** 16.4 Checking and Correcting (info "(emacs)Spelling")

  (leuven--section "16.4 (emacs)Checking and Correcting Spelling")

  ;; Spelling checker program.
  (setq ispell-program-name             ; Defined in ispell.el.
        (or (executable-find "aspell")
            (executable-find "hunspell")
            (executable-find "ispell")
            ;; nil                      ; [Default: "ispell"]
            ))

  (defun leuven--executable-ispell-program-name-p ()
    "Ensure that `ispell-program-name' is an executable program name."
    (and (boundp 'ispell-program-name)
         ispell-program-name            ; It can be nil!
         (file-executable-p ispell-program-name)
         ispell-program-name))

  (when (leuven--executable-ispell-program-name-p)

    (defun leuven-ispell-region-or-buffer ()
      "Interactively check the current region or buffer for spelling errors."
      (interactive)
      (if mark-active
          (if (< (mark) (point))
              (ispell-region (mark) (point))
              (ispell-region (point) (mark)))
          (ispell-buffer)))

    ;; Key bindings (or `C-c i' prefix key binding?).
    (global-set-key (kbd "C-$") #'leuven-ispell-region-or-buffer)
    (global-set-key (kbd "C-M-$") #'ispell-change-dictionary)

    ;; ;; Default dictionary to use (if `ispell-local-dictionary' is nil, that
    ;; ;; is if there is no local dictionary to use in the buffer).
    ;; (setq ispell-dictionary "american") ; see `sentence-end-double-space'
#+end_src

#+begin_src emacs-lisp
    ;; Comments in programs should always be in English.
    (add-hook 'prog-mode-hook
              #'(lambda ()
                  (setq ispell-dictionary "american")))
#+end_src

*************** TODO Enable Flyspell in other modes deriving from Text (HTML, etc.)

#+begin_src emacs-lisp :tangle no
    ;; Enable on-the-fly spell checking.
    (add-hook 'text-mode-hook
              #'(lambda ()
                  (message "[Turning on Flyspell mode in `%s']" (buffer-name))
                  (flyspell-mode)))
#+end_src

#+begin_src emacs-lisp
    ;; Prevent Flyspell from finding mistakes in the code, well in comments and
    ;; strings.
    (add-hook 'prog-mode-hook #'flyspell-prog-mode)
#+end_src

#+begin_src emacs-lisp
    (with-eval-after-load "ispell"

      ;; Save the personal dictionary without confirmation.
      (setq ispell-silently-savep t)

      ;; Extensions and extra switches to pass to the `ispell' program.
      (cond
#+end_src

Tell ~aspell~ to speed up, though this reduces somewhat the quality of its
suggestions.  According to the ~aspell~ documentation:

- ~ultra~ is the fastest suggestion mode, which is still twice as slow as ~ispell~.

- If your machine is fast enough, a better option might be to try ~fast~ mode,
  which is twice as slow as ~ultra~, but more accurate.

- The ~normal~ mode, which is the ~aspell~ default, is even more accurate, but is
  reportedly 10 times slower than ~fast~ mode.

Use the ~-C~ option which will ConsiderCamelCaseToBeCorrect.

#+begin_src emacs-lisp
       ((string-match "aspell" ispell-program-name)
        (setq ispell-extra-args '("--sug-mode=ultra" "-C"))
        (setq ispell-really-aspell t)
        (setq ispell-really-hunspell nil))
#+end_src

#+begin_src emacs-lisp
       ((string-match "ispell" ispell-program-name)
        (setq ispell-extra-args '())
        (setq ispell-really-aspell nil)
        (setq ispell-really-hunspell nil)))
#+end_src

#+begin_src emacs-lisp :tangle no
      ;; ;; Solve the problem of words separated by `-' flagged as
      ;; ;; erroneous by removing the `-' from the value of otherchars.
      ;; (if (fboundp 'ispell-get-decoded-string)
      ;;     (defun ispell-get-otherchars ()
      ;;       (replace-regexp-in-string "-" "" (ispell-get-decoded-string 3))))
#+end_src

Add language indicator.

#+begin_src emacs-lisp
      ;; (setq-default mode-line-format
      ;;               (cons
      ;;                '(:eval
      ;;                  (let ((dict (and (featurep 'ispell)
      ;;                                   (not buffer-read-only)
      ;;                                   (or ispell-local-dictionary
      ;;                                       ispell-dictionary
      ;;                                       "--" ; default dictionary
      ;;                                       ))))
      ;;                    (and dict
      ;;                         (propertize (concat " " (substring dict 0 2))
      ;;                                     'face 'mode-line-highlight))))
      ;;                (default-value 'mode-line-format)))
#+end_src

#+begin_src emacs-lisp
      )
#+end_src

#+begin_note
Each time you cycle to another window (~C-x o~), the *Ispell process* gets *killed*
and a *new Ispell process* is *started*, if the language in the next window is
different from the language in the current window...
#+end_note

~flyspell-auto-correct-word~ is bound to ~C-.~.  Press it one time to correct the
word under the cursor.  If several spellings are possible, they appear in the
minibuffer.  Just keep hitting ~C-.~ to replace the word with the successive
suggestions.

#+begin_src emacs-lisp
    (with-eval-after-load "flyspell"

      ;; Remove the binding of `flyspell-auto-correct-previous-word', to be used
      ;; by Multiple Cursors.
      (define-key flyspell-mode-map (kbd "C-;") nil))
#+end_src

~flyspell-goto-next-error~ is bound to "C-,".  Press it to go to the next
previously detected error.

~flyspell-correct-word-before-point~ is bound to ~C-c $~.  Press it to *pop up a menu*
of possible corrections for misspelled word before point.

#+begin_src emacs-lisp
    ;; Don't use `M-TAB' to auto-correct the current word (only use `C-.').
    (setq flyspell-use-meta-tab nil)
    ;; FIXME M-TAB is still bound to `flyspell-auto-correct-word' when this
    ;; chunk of code is placed within (with-eval-after-load "flyspell"...)

    (with-eval-after-load "flyspell"

     ;; Don't consider that a word repeated twice is an error.
     (setq flyspell-mark-duplications-flag nil)

     ;; Lower (for performance reasons) the maximum distance for finding
     ;; duplicates of unrecognized words.
     (setq flyspell-duplicate-distance 12000) ; [default: 400000]

     ;; Fix the "enabling flyspell mode gave an error" bug.
     (setq flyspell-issue-welcome-flag nil)

     ;; ;; Don't print messages for every word (when checking the entire buffer)
     ;; ;; as it causes a (small) slowdown.
     ;; (setq flyspell-issue-message-flag nil)

     ;; Dash character (`-') is considered as a word delimiter.
     (setq-default flyspell-consider-dash-as-word-delimiter-flag t)
     ;; '("francais" "deutsch8" "norsk")

     (defun leuven-flyspell-toggle-dictionary ()
       "Toggle the local dictionary between French and US English."
       (interactive)
       (let ((dict (or ispell-local-dictionary
                       ispell-dictionary)))
         (setq dict (if (string= dict "francais") "american" "francais"))
         (message "[Switched to %S]" dict)
         (sit-for 0.5)
         (ispell-change-dictionary dict)
         (force-mode-line-update)
         (when flyspell-mode
           ;; (flyspell-delete-all-overlays)
           ;; If above is executed, the advised `org-mode-flyspell-verify'
           ;; won't work anymore.
           (flyspell-buffer))))

     ;; Key bindings.
     (global-set-key (kbd "C-$") #'flyspell-buffer)
     (global-set-key (kbd "C-M-$") #'leuven-flyspell-toggle-dictionary)

     ;; Spell-check your XHTML (by adding `nxml-text-face' to the list of
     ;; faces corresponding to text in programming-mode buffers).
     (add-to-list 'flyspell-prog-text-faces 'nxml-text-face)))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 16 ends here.
#+end_src

* Keyboard Macros

#+begin_src emacs-lisp
;;* 17 (info "(emacs)Keyboard Macros")

(leuven--chapter leuven-load-chapter-17-keyboard-macros "17 Keyboard Macros"
#+end_src

Shows keyboard macros or latest interactive commands as Emacs Lisp:
https://github.com/Silex/elmacro.

** Basic Use

- ~S-<F8>~ ::
     Start recording your keyboard macro.

- ~S-<F8>~ again ::
     Stop recording it.

- ~<F8>~ ::
     Call the keyboard macro.

If you want to check the result each time before repeating, type ~<F8> e e...~.

If you want to repeat only N times, type ~C-u N <F8>~.

If you want to repeat forever or until error, type ~C-u 0 <F8>~.

#+begin_src emacs-lisp
;;** 17.1 (info "(emacs)Basic Keyboard Macro") Use

  (leuven--section "17.1 (emacs)Basic Keyboard Macro Use")

  (defun leuven-kmacro-turn-on-recording ()
    "Start recording a keyboard macro and toggle functionality of key binding."
    (interactive)
    (global-set-key (kbd "<S-f8>") #'leuven-kmacro-turn-off-recording)
    (kmacro-start-macro nil))

  (defun leuven-kmacro-turn-off-recording ()
    "Stop recording a keyboard macro and toggle functionality of key binding."
    (interactive)
    (global-set-key (kbd "<S-f8>") #'leuven-kmacro-turn-on-recording)
    (kmacro-end-macro nil))

  ;; Start/stop recording a keyboard macro.
  (global-set-key (kbd "<S-f8>") #'leuven-kmacro-turn-on-recording)

  ;; Execute the most recent keyboard macro.
  (global-set-key (kbd "<f8>") #'kmacro-call-macro)
#+end_src

** Naming and Saving Keyboard Macros

- ~C-<F8>~ ::
     Give the keyboard macro a name (to invoke it under that name).

Assign the last macro to a free key binding of your choice with
~kmacro-bind-to-key~ (bound to ~C-x C-k b~).

To *save a named keyboard macro* (with its key binding) for future use, switch to
your =.emacs= file, and run ~C-u M-x insert-kbd-macro~ (if you leave out the ~C-u~,
then it will just insert the macro definition without the ~global-set-key~
sequence).

You can add ~(interactive)~ to make it a command, so that you can use it with
~M-x~.

#+begin_src emacs-lisp
;;** 17.5 Name and (info "(emacs)Save Keyboard Macro")s

  (leuven--section "17.5 (emacs)Name and Save Keyboard Macros")

  ;; Assign a name to the last keyboard macro defined.
  (global-set-key (kbd "<C-f8>") #'kmacro-name-last-macro)
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 17 ends here.
#+end_src

* Files Handling

#+begin_src emacs-lisp
;;* 18 (info "(emacs)Files") Handling

(leuven--chapter leuven-load-chapter-18-files "18 Files Handling"
#+end_src

** Visiting Files

#+begin_src emacs-lisp
;;** 18.2 (info "(emacs)Visiting") Files

  (leuven--section "18.2 (emacs)Visiting Files")

  (defadvice find-file (around leuven-find-file activate)
    "Open the file named FILENAME and report time spent."
    (let ((filename (ad-get-arg 0))
          (find-file-time-start (float-time)))
      (message "[Finding file %s...]" filename)
      ad-do-it
      (message "[Found file %s in %.2f s]" filename
               (- (float-time) find-file-time-start))))

  ;; Visit a file.
  (global-set-key (kbd "<f3>") #'find-file)
#+end_src

#+begin_src emacs-lisp
  ;; Get rid of the "File xxx is large, really open? (y or n)" annoying message.
  (setq large-file-warning-threshold (* 512 1024 1024)) ; 512 MB.

  ;; Maximum buffer size for which line number should be displayed.
  (setq line-number-display-limit large-file-warning-threshold)
                                        ; 14.18 Optional Mode Line Features.
#+end_src

Knowing this kind of behaviour, and especially when trying to guard myself
against reading a log which spits out a long line, I often do something like
~tail -f /some/file | fold -s~ in a shell buffer. This isn't good for editing,
obviously, but helps a lot with reading.

#+begin_src emacs-lisp
  (defun leuven--is-file-large-p ()
    "File is too big and might cause performance issue."
    (> (buffer-size) large-file-warning-threshold))

  ;; View large files.
  (defun leuven--view-large-file ()
    "Fix performance issues in Emacs when viewing large files."
    (setq buffer-read-only t)
    (setq-local bidi-display-reordering nil) ; Default local setting.
    (jit-lock-mode nil)
    (buffer-disable-undo)
    (set (make-variable-buffer-local 'global-hl-line-mode) nil)
    (set (make-variable-buffer-local 'line-number-mode) nil)
    (set (make-variable-buffer-local 'column-number-mode) nil)

    ;; Disable costly modes.
    (when (boundp 'smartparens-mode)
      (smartparens-mode -1))              ; XXX: DOES NOT WORK.
    (when (boundp 'anzu-mode)
      (anzu-mode -1)))

  (define-derived-mode leuven-large-file-mode fundamental-mode "LvnLargeFile"
    "Fix performance issues in Emacs for large files."
    (leuven--view-large-file))

  (add-to-list 'magic-mode-alist (cons #'leuven--is-file-large-p #'leuven-large-file-mode))
#+end_src

#+begin_src emacs-lisp
  (defun leuven-find-large-file-conservatively (filename)
    (interactive
     (list (read-file-name
            "Find file conservatively: " nil default-directory
            (confirm-nonexistent-file-or-buffer))))
    (let ((auto-mode-alist nil))
      (find-file filename)
      (fundamental-mode)
      (leuven--view-large-file)))
#+end_src

The *SoLong* package is a workaround for the issue of large "minified" files of
programming code bringing Emacs to its knees on account of the relevant modes
not being optimised for that use-case.

** Saving Files

You can define a *shadow file* group to automatically upload local files to
a remote location.

#+begin_src emacs-lisp
;;** 18.3 (info "(emacs)Saving") Files

  (leuven--section "18.3 (emacs)Saving Files")

  (defadvice save-buffer (around leuven-save-buffer activate)
    "Save the file named FILENAME and report time spent."
    (let ((filename (buffer-file-name))
          (save-buffer-time-start (float-time)))
      (message "[Saving file %s...]" filename)
      ad-do-it
      (message "[Saved file %s in %.2f s]" filename
               (- (float-time) save-buffer-time-start))))

  ;; Make your changes permanent.
  (global-set-key (kbd "<f2>") #'save-buffer)
#+end_src

Builtin file version control of Emacs.

#+begin_src emacs-lisp
  ;; Make numbered backups.
  (setq version-control t)

  ;; Save backup files (i.e., `foo~' or `foo.~i~') in one central location
  ;; (instead of in the local directory).
  (setq backup-directory-alist
        '((".*" . "~/.emacs.d/backups/")))
                                        ; Filenames matching a regexp are backed
                                        ; up in the corresponding directory.
                                        ; Emacs will `make-directory' it, if
                                        ; necessary.

  ;; ;; Number of oldest versions to keep when a new numbeRed backup is made.
  ;; (setq kept-old-versions 0)            ; [Default: 2]

  ;; Number of newest versions to keep when a new numbered backup is made.
  (setq kept-new-versions 5)            ; [Default: 2]

  ;; Don't ask me about deleting excess backup versions.
  (setq delete-old-versions t)

  ;; Always use copying to create backup files (don't clobber symlinks).
  (setq backup-by-copying t)
#+end_src

Customize saving actions.

Automatically add a newline at the end of the file:

#+begin_src emacs-lisp
  ;; Ensure newline at the end of file when it is saved.
  (setq require-final-newline t)
  ;; TODO Do this only for text and Fundamental modes, because I could
  ;; edit binary files (see `mode-require-final-newline')
#+end_src

Update time stamps (and copyright notice) automatically.

#+begin_src emacs-lisp
  ;; Update time stamps every time you save a buffer.
  (add-hook 'before-save-hook #'time-stamp)

  ;; Maintain last change time stamps (`Time-stamp: <>' occurring within
  ;; the first 8 lines) in files edited by Emacs.
  (with-eval-after-load "time-stamp"

    ;; Format of the string inserted by `M-x time-stamp':
    ;; `YYYY-MM-DD Day HH:MM' (see `system-time-locale' for non-numeric
    ;; formatted items of time).
    (setq-default time-stamp-format "%:y-%02m-%02d %3a %02H:%02M"))

  ;; Update the copyright notice to indicate the current year.
  (add-hook 'before-save-hook
            #'(lambda ()                  ; Except for ...
                (unless (derived-mode-p 'diff-mode)
                                        ; ... where the patch file can't be
                                        ; changed!
                  (copyright-update))))
#+end_src

** Reverting a Buffer

#+begin_src emacs-lisp
;;** 18.4 (info "(emacs)Reverting") a Buffer

  (leuven--section "18.4 (emacs)Reverting a Buffer")

  ;; Time between Auto-Revert Mode file checks.
  (setq auto-revert-interval 1)         ; [Default: 5]

  ;; ;; But if, for instance, a new version is checked in from outside the current
  ;; ;; Emacs session, the version control number in the mode line, as well as
  ;; ;; other version control related information, may not be properly updated
  ;; (setq auto-revert-check-vc-info t)

  ;; Synchronize.  Reload the file from disk (replacing current buffer text with
  ;; the text of the visited file on disk).
  (defun leuven-revert-buffer-without-query ()
    "Unconditionally revert current buffer."
    (interactive)
    (revert-buffer t t)                 ; ignore-auto(-save), noconfirm
    ;; Remove highlights.
    (dolist (o (overlays-in (window-start) (window-end)))
      (when (or (equal (overlay-get o 'face) 'recover-this-file)
                (equal (overlay-get o 'face) 'highlight-changes)
                (equal (overlay-get o 'face) 'highlight-changes-delete)
                (equal (overlay-get o 'face) 'org-block-executing))
        (delete-overlay o)))            ; Useful when our advice of function
                                        ; `org-babel-execute-src-block' fails to
                                        ; remove the background color.
    (message "[Buffer is up to date with file on disk]"))

  (global-set-key (kbd "C-S-y") #'leuven-revert-buffer-without-query)
#+end_src

Turn on auto-revert mode globally.

#+begin_src emacs-lisp
  (when leuven--cygwin-p                ; Cygwin Emacs uses gfilenotify (based
                                        ; on GLib) and there are performance
                                        ; problems... Emacs bug 20927

    ;; Don't use file notification functions.
    (setq auto-revert-use-notify nil))  ; XXX Apply this in EmacsW32 if it doesn't revert!

  ;; Enable Global Auto-Revert mode (auto refresh buffers).
  (global-auto-revert-mode 1)           ; Can generate a lot of network traffic
                                        ; if `auto-revert-remote-files' is set
                                        ; to non-nil.
#+end_src

Auto-revert will automatically *reload files* that have been *modified outside of
Emacs* (externally modified files).  It won't revert a buffer that you've edited
inside Emacs, even if the file also changes outside.

#+begin_warning
~global-auto-revert-mode~ blocks Cygwin Emacs for more than 5 seconds at many
points in time. Disabled for now, under Cygwin.
#+end_warning

** Auto Reverting Non-File Buffers

Auto-refresh Dired.

#+begin_src emacs-lisp
  ;; Global Auto-Revert mode operates on all buffers (Dired, etc.)
  (setq global-auto-revert-non-file-buffers t)

  ;; Do not generate any messages (be quiet about refreshing Dired).
  (setq auto-revert-verbose nil)        ; Avoid "Reverting buffer `some-dir/'.".
#+end_src

** Auto-Saving: Protection Against Disasters

How to get Emacs to auto-save to your local disk (=#file#=).

#+begin_src emacs-lisp
;;** 18.6 (info "(emacs)Auto Save"): Protection Against Disasters

  (leuven--section "18.6 (emacs)Auto Save: Protection Against Disasters")

  ;; Auto-save every 100 input events.
  (setq auto-save-interval 100)         ; [Default: 300].

  ;; Save files automatically if application is idle for 15 sec.
  (setq auto-save-timeout 15)           ; [Default: 30].
#+end_src

Disable backups and auto-save only in the current buffer with
~M-x sensitive-mode~:

#+begin_src emacs-lisp
  (define-minor-mode sensitive-mode
    "For sensitive files like password lists.
  It disables backup creation and auto saving in the current buffer.

  With no argument, this command toggles the mode.  Non-null prefix argument
  turns on the mode.  Null prefix argument turns off the mode."
    nil                                 ; Initial value.
    " Sensitive"                        ; Indicator for the mode line.
    nil                                 ; Minor mode bindings.
    (if (symbol-value sensitive-mode)
        (progn
          ;; Disable backups.
          (set (make-local-variable 'backup-inhibited) t)
          ;; Disable auto-save.
          (if auto-save-default
              (auto-save-mode -1)))
      ;; Resort to default value of backup-inhibited.
      (kill-local-variable 'backup-inhibited)
      ;; Resort to default auto save setting.
      (if auto-save-default
          (auto-save-mode 1))))
#+end_src

You should enable it for all =.vcf= and =.gpg= files.

Make the message "/FILENAME has auto save data/" unmissable:

#+begin_src emacs-lisp
  (defface recover-this-file
    '((t :weight bold :background "#FF3F3F"))
    "Face for buffers visiting files with auto save data."
    :group 'files)

  (defvar leuven--recover-this-file nil
    "If non-nil, an overlay indicating that the visited file has auto save data.")

  (defun leuven--recover-this-file ()
    (let ((warn (not buffer-read-only)))
      (when (and warn
                 ;; No need to warn if buffer is auto-saved under the name of
                 ;; the visited file.
                 (not (and buffer-file-name
                           auto-save-visited-mode)) ; Emacs 26.1
                 (file-newer-than-file-p (or buffer-auto-save-file-name
                                             (make-auto-save-file-name))
                                         buffer-file-name))
        (set (make-local-variable 'leuven--recover-this-file)
             (make-overlay (point-min) (point-max)))
        (overlay-put leuven--recover-this-file
                     'face 'recover-this-file))))

  (add-hook 'find-file-hook #'leuven--recover-this-file)
#+end_src

XXX Add explanation about what to do when a file is opened in red background!

** Comparing Files

See https://www.diffchecker.com/diff for an online solution.

*** Diff

If you want a Magit diff buffer for the current file, you can call
magit-diff-buffer-file directly, or use the "diff" option (d) in
magit-file-popup. e.g.:

(global-set-key (kbd "C-c m d") #'magit-diff-buffer-file)
(global-set-key (kbd "C-c m f") #'magit-file-popup)

#+begin_tip
To compare Excel files, go to =File= / =Options= / =Advanced= / =Display options for
this worksheet= / =Show formulas in cells instead of their calculated
results=.  Then, =File= / =Save As= / =CSV=.

Or, even easier, use *Spreadsheet Compare 2016*!
#+end_tip

#+begin_src emacs-lisp
;;** 18.9 (info "(emacs)Comparing Files")

  (leuven--section "18.9 (emacs)Comparing Files")

  ;; ;; Default to unified diffs.
  ;; (setq diff-switches "-u")             ; Default in Emacs 25.
#+end_src

Press ~e~ in Dired mode to immediately Ediff two marked files, no questions asked:

#+begin_src emacs-lisp
  (defun leuven-ediff-files-from-dired ()
"Quickly Ediff files from Dired"
    (interactive)
    (let ((files (dired-get-marked-files))
          (wnd (current-window-configuration)))
      (if (<= (length files) 2)
          (let ((file1 (car files))
                (file2 (if (cdr files)
                           (cadr files)
                         (read-file-name
                          "File B to compare: "
                          (dired-dwim-target-directory)))))
            (if (file-newer-than-file-p file1 file2)
                (ediff-files file2 file1)
              (ediff-files file1 file2))
            (add-hook 'ediff-after-quit-hook-internal
                      #'(lambda ()
                          (setq ediff-after-quit-hook-internal nil)
                          (set-window-configuration wnd))))
        (error "no more than 2 files should be marked"))))

  (with-eval-after-load "dired"
    (define-key dired-mode-map (kbd "E") #'leuven-ediff-files-from-dired))
#+end_src

- In case no files are marked, the file at point is used as the first file, and
  ~read-file-name~ is used for the second file. Since I have the magic
  (setq dired-dwim-target t)
  in my config, in case a second dired buffer is open,
  ~dired-dwim-target-directory~ will offer it as the starting directory during
  completion. Very useful to compare two files in two different directories.

- Depending on the order of the arguments to ~ediff-files~, the changes will
  appear either as added or removed; ~file-newer-than-file-p~ tries to put the
  arguments in a logical order by looking at the files' last change times.

- ~ediff-after-quit-hook-internal~ is used to restore the previous window
  configuration after I quit Ediff with ~q~.

*** Compare windows

#+begin_src emacs-lisp
  ;; Compare text in current window with text in next window.
  (global-set-key (kbd "C-=") #'compare-windows)
#+end_src

*** SMerge mode

You can use ~M-x smerge-mode~ to *edit a file with conflict markers* (output from
the ~diff3~ program).

SMerge does not automatically select regions but provides convenient key
bindings to navigate between conflicts and to choose the A or B variant.

#+begin_src emacs-lisp
  ;; Change the cumbersome default prefix (C-c ^).
  (setq smerge-command-prefix (kbd "C-c v"))
#+end_src

Important keybindings:

- ~C-c v n~ (~smerge-next~) ::
     Move to next conflict.

- ~C-c v p~ (~smerge-previous~) ::
     Move to previous conflict.

- ~C-c v RET~ (~smerge-keep-current~) ::
     Keep the version the cursor is on.

- ~C-c v m~ (~smerge-keep-mine~) ::
     Keep your changes.

- ~C-c v o~ (~smerge-keep-other~) ::
     Keep other changes.

#+begin_src emacs-lisp :tangle no
  ;; Enable SMerge automatically.
  (defun leuven--enable-smerge-maybe ()
    (when (and buffer-file-name (vc-backend buffer-file-name))
      (save-excursion
        (goto-char (point-min))
        (when (re-search-forward "^<<<<<<< " nil t)
          (smerge-mode 1)))))

  (add-hook 'buffer-list-update-hook #'leuven--enable-smerge-maybe)
#+end_src

#+begin_note
In recent Emacs versions, SMerge is turned on automatically??? XXX
#+end_note

*** Interface for merging files

- ~C-c v E~ (~smerge-ediff~) ::
     Start an Ediff session to merge the conflicts.

Keybindings:

- ~n~ and ~p~ ::
     Navigate through the conflicts.

- ~a~ or ~b~ ::
     Accept versions.

- ~/~ ::
     Look at the ancestor!

- ~q~ ::
     Quit the ediff session.

The top-left pane contains the =file= in my working directory as it was before the
merge, the top-right pane contains the final revision of =file= at the source URL
and the bottom pane contains the merged version.

The really nice thing is that as soon as I end the Ediff session, Emacs goes
back to the conflicted file /with all the changes done in the Ediff session
applied/. So if you have resolved all conflicts, the file is not in Smerge mode
anymore. The only thing left to do is to save the file. After that, the state of
the file as displayed in the vc-dir buffer changes from /conflicted/ to /edited/.

#+begin_note
Since the year 2000, ~vc-resolve-conflict~ is an alias for ~smerge-ediff~, which as
the name suggests starts an Ediff session, not an Emerge session.

By the way, the library header of =ediff.el= acknowledges =emerge.el='s influence
and then goes on saying "The present version of *Ediff supersedes Emerge*.  It
provides a superior user interface and has numerous major features not found in
Emerge.  In particular, it can do patching, and 2-way and 3-way file comparison,
merging, and directory operations."

Also note that ~magit-ediff-resolve~ (~E m~ or ~e~ on a file with conflicts) uses
~smerge-ediff~ internally.  It does however override the ~ediff-quit-hook~ to
provide a slightly better session finishing experience.  Instead of telling you
that you could save "the buffer" (there are several buffers), it asks you
whether you want to save the buffer (while showing you its name).
#+end_note

** Diff mode

You can review the diff of all file changes, either:

- *unified* (Diff mode) or
- *split* (Ediff mode).

In Diff mode, the changes specified in a patch are grouped into "hunks", which
are contiguous chunks of text that contain one or more changed lines.

Use ~C-x v =~ to show what's changed.

You can also decide to revert a change: *select a hunk and apply it (in reverse)*.

#+begin_src emacs-lisp
;;** 18.10 (info "(emacs)Diff Mode")

  (leuven--section "18.10 (emacs)Diff Mode")

  ;; Mode for viewing/editing context diffs.
  (with-eval-after-load "diff-mode"

    ;; Highlight the changes with better granularity.
    (defun leuven-diff-make-fine-diffs ()
      "Enable Diff Auto-Refine mode."
      (interactive)
      (let (diff-refine)                ; Avoid refining the hunks redundantly ...
        (condition-case nil
            (save-excursion
              (goto-char (point-min))
              (while (not (eobp))
                (diff-hunk-next)
                (diff-refine-hunk)))    ; ... when this does it.
          (error nil))
        (run-at-time 0.0 nil
                     #'(lambda ()
                         (if (derived-mode-p 'diff-mode)
                             ;; Put back the cursor only if still in a Diff buffer
                             ;; after the delay.
                             (goto-char (point-min)))))))

    (defun vc-diff--diff-make-fine-diffs-if-necessary (buffer messages)
      "Auto-refine only the regions of 14,000 bytes or less."
      ;; Check for auto-refine limit.
      (unless (> (buffer-size) 14000)
        (leuven-diff-make-fine-diffs)))
    ;; Push the auto-refine function after `vc-diff'.
    (advice-add 'vc-diff :after #'vc-diff--diff-make-fine-diffs-if-necessary)
#+end_src

If you use ~colordiff~ in SVN, you need this:

#+begin_src emacs-lisp
    (defun vc-diff-finish--handle-color-in-diff-output (buffer messages)
      "Run `ansi-color-apply-on-region'."
      (interactive)
      (progn
        (require 'ansi-color)
        (let ((inhibit-read-only t))
          (ansi-color-apply-on-region (point-min) (point-max)))))
    (advice-add 'vc-diff-finish :after #'vc-diff-finish--handle-color-in-diff-output)
#+end_src

#+begin_src emacs-lisp
    )
#+end_src

To compare 2 text files, you can also use Ediff if the following command
works.

: M-: (executable-find "diff") RET

In Ediff, press:

- ~?~ to get help

- ~|~ to change from vertical window layout to horizontal window layout, and
  vice versa

- ~a~ or ~b~ key to merge the code from A to B or from B to A

- ~ra~ or ~rb~ to revert your change

#+begin_src emacs-lisp
  ;; ;; Ediff, a comprehensive visual interface to diff & patch
  ;; ;; setup for Ediff's menus and autoloads
  ;; (try-require 'ediff-hook)
  ;; already loaded (by Emacs?)

  (with-eval-after-load "ediff"

    ;; Ignore space.
    (setq ediff-diff-options (concat ediff-diff-options " -w"))
                                        ; Add new options after the default ones.

    ;; Skip over difference regions that differ only in white space and line
    ;; breaks.
    ;; (setq-default ediff-ignore-similar-regions  t)
    ;; XXX Make another key binding (than `E') with that value in a let-bind

    ;; Sometimes grab the mouse and put it in the control frame.
    (setq ediff-grab-mouse 'maybe)

    ;; Do everything in one frame.
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)

    ;; Split the window (horizontally or vertically) depending on the frame
    ;; width.
    (setq ediff-split-window-function
          #'(lambda (&optional arg)
              (if (> (frame-width) split-width-threshold)
                  (split-window-horizontally arg)
                (split-window-vertically arg))))

    ;; (setq ediff-merge-split-window-function 'split-window-vertically)
#+end_src

When using Ediff, everything must be visible; otherwise, it's fairly hard to
resolve conflicts.

#+begin_src emacs-lisp
    (defun turn-on-visible-mode ()
      "Make all invisible text visible."
      (visible-mode 1)
      (setq truncate-lines nil)
      (when (and (boundp 'hs-minor-mode)
                 hs-minor-mode)
        (hs-show-all))
      (when (derived-mode-p 'org-mode)
        (org-remove-inline-images)))

    ;; Force the buffers to unhide (folded) text (in Org files).
    (add-hook 'ediff-prepare-buffer-hook #'turn-on-visible-mode)

    (defun turn-off-visible-mode ()
      "Disable Visible mode."
      (visible-mode 0)
      (setq truncate-lines t)
      (when (derived-mode-p 'org-mode)
        (org-display-inline-images)))

    (add-hook 'ediff-quit-hook #'turn-off-visible-mode)

    )
#+end_src

*** Ediff-directories

For *comparing two directories*, you can use ~ediff-directories~, ~ztree-diff~, [[http://meldmerge.org/][Meld]]
(free) or [[https://www.deltawalker.com/][DeltaWalker]] (39.95 USD).

~ediff-directories~ combined with the key sequence == h x= ~= h x~ shows you only the
files which differ.

It is not recursive, but it gives you also subdirectory pairs to compare.  Just
hit ~RET~ on such a pair.

As bonus, it even works for remote directories.

#+begin_warning
~ediff-directories~ does not list files in one directory with no corresponding
files in the other directory.
#+end_warning

*** Ztree

#+begin_src emacs-lisp
  ;; ("M-m g v" . ztree-dir)
  ;; ("M-m g V" . ztree-diff)
#+end_src

Hotkeys supported:

- Open/close directories with double-click, ~RET~ or ~SPC~ keys.
- To jump to the parent directory, hit the ~Backspace~ key.
- To toggle open/closed state of the subtree of the current directory, hit the
  ~x~ key.
- ~RET~ on different files starts the *Ediff* (or open file if one absent or the same)
- ~SPC~ show the simple diff window for the current file instead of *Ediff* (or view
  file if one absent or the same)
- ~TAB~ to fast switch between panels
- ~h~ key to toggle show/hide identical files/directories
- ~H~ key to toggle show/hide hidden/ignored files/directories
- ~C~ key to copy current file or directory to the left or right panel
- ~D~ key to delete current file or directory
- ~v~ key to quick view the current file
- ~r~ initiates the rescan/refresh of current file or subdirectory
- ~<F5>~ forces the full rescan.

** Miscellaneous File Operations

#+begin_src emacs-lisp
;;** 18.11 (info "(emacs)Misc File Ops")

  (leuven--section "18.11 (emacs)Misc File Ops")

  ;; Use the system's Trash (when it is available).
  (setq delete-by-moving-to-trash t)
#+end_src

** Accessing Compressed Files

- Display the *contents* of the archive
- *View or edit* the actual files contained withing the archive

Using the Emacs Dired utility, you can compress (individually) or uncompress
marked files (using ~gzip~) by pressing ~Z~.

If you want to create *a single archive* file from many marked files, you can use
~dired-do-compress-to~, bound to ~c~.

*** On Windows                                                        :noexport:

On Windows, if you are trying to use ~gunzip~ to uncompress a file under Dired,
you will probably encounter errors.

The problem is due to that ~gunzip~ provided by Cygwin is not an executable
file.  It is a *symbolic link to ~gzip~*; you can verify this by
~ls -l /usr/bin/gunzip~.

Since *GNU Emacs does not understand Cygwin's symbolic links*, it cannot execute
~gunzip~.  The solution is to replace ~gunzip~ with ~gzip -d~.

#+begin_src shell :tangle ~/winbin/gunzip :padline no
#!/bin/sh
# gunzip -- gunzip solution on Windows

PATH=${GZIP_BINDIR-'/usr/bin'}:$PATH
exec gzip -d "$@"

# gunzip ends here
#+end_src

** Auto Encryption

History:

1. mailcrypt

2. PGG

3. EasyPG (= epg) is a GnuPG interface for Emacs.

   It allows you to encrypt/decrypt files within Emacs.  When you use ~C-x C-f~ to
   access an encrypted file, Emacs prompts you for the passphrase and then
   decrypts the file before displaying it.  When you save the file, Emacs
   automatically encrypts it again with that same key.

   It has two aspects:

   - convenient tools which allow to use GnuPG from Emacs (EasyPG Assistant),
     and

   - a fully functional interface library to GnuPG (EasyPG Library).

*************** TODO Fetch the key automatically
Set the ~keyserver~ entry in the =~/.gnupg/gpg.conf= file properly.
*************** END

What is PGP/MIME, what is OpenPGP, and how Gnus handles them?
- PGP/MIME is a standard, which mml2015* implements using ep[ag]-*.
- OpenPGP is a standard, which ep[ag]-* implements.

#+begin_src emacs-lisp
  ;; The EasyPG Assistant, transparent file encryption.
  (with-eval-after-load "epa-file"
    (custom-set-variables '(epg-gpg-program "gpg2"))
                                        ; If you have issues, try uninstalling
                                        ; gnupg, keeping only gnupg2!

    ;; Stop EasyPG from asking for the recipient used for encrypting files.
    (setq epa-file-encrypt-to (if (boundp 'user-mail-address)
                                  user-mail-address
                                '("john.doe@example.com")))
                                        ; If no one is selected (""), symmetric
                                        ; encryption will always be performed.

    ;; Cache passphrase for symmetric encryption (VERY important).
    (setq epa-file-cache-passphrase-for-symmetric-encryption t)
                                        ; Not to sound paranoid.  But if you
                                        ; want caching, it's recommended to use
                                        ; *public-key encryption* instead of
                                        ; symmetric encryption.  `gpg-agent' is
                                        ; the preferred way to do this.

    ;; Query passphrase through the minibuffer, instead of using an external
    ;; Pinentry program.
    (setenv "GPG_AGENT_INFO" nil)
    (setq epa-pinentry-mode 'loopback)

    ;; Enable `epa-file'.
    (epa-file-enable))
#+end_src

Password free

Otherwise:

#+begin_src shell :tangle no
gpgconf kill gpg-agent
#+end_src

** Remote Files

#+begin_src emacs-lisp
;;** 18.14 (info "(emacs)Remote Files")

  (leuven--section "18.14 (emacs)Remote Files")
#+end_src

*** Ange-FTP

*************** TODO Check out why network share aren't accessible
I should be able to open //SERVER/d/ via SMB!?
*************** END

#+begin_src emacs-lisp
;;*** Ange-FTP

  (leuven--section "Ange-FTP")

  ;; Transparent FTP support.
  (with-eval-after-load "ange-ftp"

    ;; Try to use passive mode in ftp, if the client program supports it.
    (setq ange-ftp-try-passive-mode t)) ; Needed for Ubuntu.
#+end_src

*** TRAMP

Open files on a remote machine using [[http://www.gnu.org/software/tramp/][TRAMP]] (other protocols than just FTP) from
your machine, edit and save them!

~/method:user@host:/path/to/some/file~

Examples:
- ~C-x C-f /ssh:user@host:/etc/motd RET~ (~root~ to modify it!)
- ~C-x C-f /plink:user@host:/etc/motd RET~ (from Windows Emacs)
- ~C-x C-f /sudo:root@localhost:/etc/motd RET~
- ~C-x C-f /su::/etc/motd RET~ (shortened syntax for the ~root~ account on the
  local host)

Also ~M-x find-dired~, ~rgrep~, ~lgrep~, ~compile -~ properly work with TRAMP (run on
remote server and show result in your Emacs).

#+begin_note
~sshfs~ can give you the same functionality as TRAMP: it is like a personal NFS
(another mounted file system) over SSH.  If you can SSH to a server, you can
probably do ~sshfs~.
#+end_note

#+begin_src emacs-lisp
;;*** TRAMP - Transparent Remote Access, Multiple Protocols

  (leuven--section "TRAMP")

  (with-eval-after-load "tramp"         ; The autoloads are predefined.
#+end_src

**** TODO Configuring TRAMP for use

***** Selecting a default method

#+begin_note
As there are *issues with Cygwin ~ssh~* (which only works with Cygwinized Emacs),
*Windows users* should use the PuTTY implementation of SSH (~plink~ method).
#+end_note

#+begin_src emacs-lisp
    ;; Default transfer method.
    (setq tramp-default-method          ; [Default: "scp"]
          (cond (leuven--win32-p "plink")
                (t "ssh")))
#+end_src

#+begin_tip
You might try out the ~rsync~ /external/ method, which saves the remote files quite
a bit faster than SSH.  It's based on SSH, so it works the same, just saves
faster.
#+end_tip

***** TODO Find file as root

You can just do ~C-x C-f /sudo:user@localhost:/etc/motd RET~.

Because I'm lazy, I have a hack (from Tassilo Horn): if I try to open a file
for which I don't have permissions for, I'm queried if I want to open it as
root using the ~sudo~ tramp method.

#+begin_src emacs-lisp
    (defun leuven--find-file-sudo-header-warning ()
      "*Display a warning in header line of the current buffer."
      (let* ((warning "WARNING: EDITING FILE WITH ROOT PRIVILEGES!")
             (space (+ 6 (- (frame-width) (length warning))))
             (bracket (make-string (/ space 2) ?-))
             (warning (concat bracket warning bracket)))
        (setq header-line-format
              (propertize warning 'face 'header-line))))

    (defun leuven-find-file-sudo (filename)
      "Open FILENAME with root privileges."
      (interactive "F")
      (set-buffer (find-file (concat "/sudo::" filename)))
      (leuven--find-file-sudo-header-warning))

    ;; ;; XXX already an existing defadvice around find-file!!
    ;; (defadvice find-file (around leuven-find-file activate)
    ;;   "Open FILENAME using tramp's sudo method if it's read-only."
    ;;   (if (and (file-exists-p (ad-get-arg 0))
    ;;            (not (file-writable-p (ad-get-arg 0)))
    ;;            (not (file-remote-p (ad-get-arg 0)))
    ;;            (y-or-n-p (concat "File "
    ;;                              (ad-get-arg 0)
    ;;                              " is read-only.  Open it as root? ")))
    ;;       (leuven-find-file-sudo (ad-get-arg 0))
    ;;     ad-do-it))
#+end_src

***** Connecting to a remote host using multiple hops

New proxy system (introduced in 2004, instead of the old "multi-hop" methods) to
edit files on a remote server by going via another server.

#+begin_example
    ;; Route to be followed for specific host/user pairs.
    (add-to-list 'tramp-default-proxies-alist
                 ;;  "final host"    "user"    "proxy in the middle"
                 '("10.10.13.123" "\\`root\\'" "/ssh:%h:"))
#+end_example

Opening ~/sudo:10.10.13.123:~ would connect first ~10.10.13.123~ via ~ssh~ under your
account name, and perform ~sudo -u root~ on that host afterwards.  It is important
to know that the given method is applied on the host which has been reached so
far.  The trick is to think from the end.

***** Reusing passwords for several connections

#+begin_src emacs-lisp
    ;; How many seconds passwords are cached.
    (setq password-cache-expiry 60)     ; [Default: 16]
#+end_src

***** Remote shell setup hints

It is worth noting that you can customize the prompt that tramp expects
(~tramp-login-prompt-regexp~) but my advice would rather be to make your prompt
TRAMP-compatible and not the other way around.

*The author of TRAMP doesn't think this ever needs to be changed, so please tell
him about it if you need to change this.*

#+begin_src emacs-lisp :tangle no
    ;; String used for end of line in rsh connections.
    (setq tramp-rsh-end-of-line         ; [Default: "\n"]
          (cond (leuven--win32-p "\n")
                (t "\r")))
#+end_src

***** Auto-save and Backup configuration

#+begin_src emacs-lisp
    ;; "Turn off" the effect of `backup-directory-alist' for TRAMP files.
    (add-to-list 'backup-directory-alist
                 (cons tramp-file-name-regexp nil))

    ;; Faster auto saves.
    (setq tramp-auto-save-directory temporary-file-directory)
#+end_src

**** Frequently Asked Questions

Be notified when TRAMP file transfers are complete by making Emacs beep after
reading from or writing to the remote host.

#+begin_src emacs-lisp
    (defadvice tramp-handle-write-region
      (after leuven-tramp-write-beep-advice activate)
      "Make TRAMP beep after writing a file."
      (interactive)
      (beep))

    (defadvice tramp-handle-do-copy-or-rename-file
      (after leuven-tramp-copy-beep-advice activate)
      "Make TRAMP beep after copying a file."
      (interactive)
      (beep))

    (defadvice tramp-handle-insert-file-contents
      (after leuven-tramp-insert-beep-advice activate)
      "Make TRAMP beep after inserting contents of a file."
      (interactive)
      (beep))
#+end_src

**** How to Customize Traces

The usual way to debug TRAMP is to set ~tramp-verbose~ to 6.  This will produce a
debug buffer, which you can show at ~tramp-devel@gnu.org~.

#+begin_src emacs-lisp
    ;; Debugging TRAMP.
    (setq tramp-verbose 6))             ; [Maximum: 10]
#+end_src

The best way to report a TRAMP bug is to call ~M-x tramp-bug~; this prepares an
email, including several trace information for analysis.

** Convenience Features for Finding Files

#+begin_src emacs-lisp
;;** 18.17 (info "(emacs)File Conveniences")

  (leuven--section "18.17 (emacs)File Conveniences")

  ;; Filenames excluded from the recent list.
  (setq recentf-exclude                 ; Has to be set before you require
                                        ; `recentf'!
        '(
          ".recentf"
          "~$"                          ; Emacs (and others) backup.
          "\\.aux$" "\\.log$" "\\.toc$" ; LaTeX.
          "/tmp/"
          ))

  ;; Setup a menu of recently opened files.
  (idle-require 'recentf)

  (with-eval-after-load "recentf"

    ;; Maximum number of items that will be saved.
    (setq recentf-max-saved-items 300)  ; Just 20 is too recent.

    ;; File to save the recent list into.
    (setq recentf-save-file (concat user-emacs-directory ".recentf"))

    ;; (When using TRAMP) turn off the cleanup feature of `recentf'.
    (setq recentf-auto-cleanup 'never)  ; Disable before we start recentf!

    ;; Save file names relative to my current home directory.
    (setq recentf-filename-handlers '(abbreviate-file-name))

    ;; Enable `recentf' mode.
    (recentf-mode 1))
#+end_src

*** Helm
:PROPERTIES:
:ID:       59418189-b87e-45a2-b128-5cbdc8a16430
:END:

**** What is Helm?

Helm (successor of Anything) is an incremental completion and selection
narrowing framework for Emacs.

It will help *steer* you in the right direction when you're looking for stuff in
Emacs (like buffers, files, etc).  You don't have anymore to remember the
structure of your working directory; you can focus on more important things.

**** How does it work?

The /default/ prefix for the preconfigured Helm commands is ~C-x c~.  In
Emacs-Leuven, we changed it to ~C-c h~.

#+begin_note
We cannot change ~helm-command-prefix-key~ once ~helm-config~ is loaded.
#+end_note

#+begin_src emacs-lisp
  (leuven--section "Helm")

  ;; Change `helm-command-prefix-key'.
  (global-set-key (kbd "C-c h") #'helm-command-prefix)

  ;; Open Helm (QuickSilver-like candidate-selection framework).
  (when (try-require 'helm-config)      ; XXX
                                        ; [default `helm-command-prefix-key']
                                        ; Explicitly loads `helm-autoloads'!
                                        ; CAUTION for recursive loads...

    (global-unset-key (kbd "C-x c"))
#+end_src

#+begin_src emacs-lisp
    ;; Resume a previous `helm' session.
    (global-set-key (kbd "C-M-z") #'helm-resume)
#+end_src

In Helm, generally, look at the *mode line*: you will see ~C-h m:Help~, it is your
friend; hit it for more info.

In default Helm:

- Narrow the list by typing some patterns (use the *space as separator* for
  multiple patterns),

- Select an element with ~<Up>~ / ~<Down>~ / ~<PageUp>~ / ~<PageDown>~ / ~C-p~ / ~C-n~ /
  ~C-v~ / ~M-v~,

- Choose with ~RET~.

- ~C-z~ executes an action without quitting the Helm session (persistent action).

  #+begin_note
  For ~helm-find-files~:

  + On a regular file,
    1. First hit on ~C-z~ expands the file name
    2. Second hit opens the file and displays its contents in the other window
    3. Third hit kills the buffer (unless it was already open before starting
       helm session).

  + On image files (~.jpg~, etc..)
    1. Second hit (or ~C-u C-z~) displays the image in the other window
    2. If you then turn on ~helm-follow-mode~ (~C-c C-f~), you turn on Helm in
       *image browser* (i.e., use ~C-n/p~ or arrows ~down/up~).
    3. You can rotate image with ~M-l/r~ (these are persistent actions too).
  #+end_note

Kill your buffers with ~C-u C-z~ one by one.

To go back to the *previous element* of the minibuffer history, use ~M-p~.

To mark all candidates in a Helm buffer, use ~M-a~ (~helm-mark-all~) or ~M-m~
(~helm-toggle-all-marks~).

Switch to ~*Helm Log*~ buffer with ~M-x helm-open-last-log~.

**** Changes in key bindings

In ~helm-find-file~, you may want to try using the left arrow to go to the parent
directory!

You can reassign ~TAB~ only during ~helm-find-file~.  The ~helm-find-file~ almost
looks like Dired and I assign ~^~ for going up.  Minor side effect is you cannot
type in ~^~ without using ~C-q~.

Sometimes you want to hit ~TAB~ for ~helm-selection-action~; however, you chose not
to happen.  Now look for substitute for ~TAB~.  Something not ~TAB~ can be ~C-z~,
~C-TAB~, and ~SPC~.

#+begin_src emacs-lisp :tangle no
(define-key helm-find-files-map (kbd "<C-tab>") #'helm-select-action)
(define-key helm-find-files-map (kbd "<SPC>")   #'helm-select-action)
(define-key helm-find-files-map (kbd "<RET>")   #'helm-confirm-and-exit-minibuffer)
(define-key helm-find-files-map (kbd "^")       #'helm-find-files-up-one-level)
#+end_src

#+begin_src emacs-lisp :tangle no
(define-key helm-grep-mode-map (kbd "<RET>") #'helm-grep-mode-jump-other-window)
(define-key helm-grep-mode-map (kbd "n") #'helm-grep-mode-jump-other-window-forward)
(define-key helm-grep-mode-map (kbd "p") #'helm-grep-mode-jump-other-window-backward)
#+end_src

**** Helm documentation

- *Advanced usage* on [[https://github.com/emacs-helm/helm#advanced-usage][Emacs-helm]] page
- [[https://github.com/emacs-helm/helm/wiki][Emacs-helm wiki]]
- [[https://github.com/thierryvolpiatto/emacs-tv-config/blob/master/init-helm-thierry.el][Helm configuration file of Thierry Volpiatto]]!
- http://tuhdo.github.io/helm-intro.html

Helm allows you to do interesting things with its interactive interface. For
example:

- interactive grep: http://tuhdo.github.io/static/live_grep.gif
- interactive occur: http://tuhdo.github.io/static/part3/helm-occur.gif

**** Vocabulary

- ~volatile~ means your candidates are recomputed each time you enter a character
  in pattern (cached candidates are not reused).  Async sources are by essence
  volatile.

- ~delayed~ means your candidates are computed after ~helm-input-idle-delay~
  seconds.

- ~no-matchplugin~ means to not use the multi regexp matching provided by
  ~helm-match-plugin.el~.

**** Features

Finally, the strings in Helm are not just strings; they are *regexps* and I think
they are more powerful than normal fuzzy matcher.

Grep in Helm is interactive, unlike the stock grep/rgrep.
Demo: http://tuhdo.github.io/static/live_grep.gif

No package does any of this:

- Live grep: http://tuhdo.github.io/static/live_grep.gif
- A live outline tree for jumping to function/variable in current file:
  + Demo 1: http://tuhdo.github.io/static/part3/helm-semantic-or-imenu.gif
  + Demo 2: https://cloud.githubusercontent.com/assets/4818719/4102208/cda8f392-311e-11e4-9c83-e68df38ef68e.gif

- Interactively select color and faces: http://tuhdo.github.io/static/part3/helm-color.gif

- Interactive Eshell history, certainly superior to the stock ~C-c C-l~:
  http://tuhdo.github.io/static/part3/helm-eshell-history.gif. I store a large
  amount of shell history, so I want a quick way to narrow down.



XXX Helm is also very useful to look up Elisp variable/function documentation
and for finding stuff in the Info Manuals (e.g. ~helm-info-elisp~ or
~helm-info-emacs~).

XXX Look at helm-dictionary.


#+begin_src emacs-lisp
    ;; Via: http://www.reddit.com/r/emacs/comments/3asbyn/new_and_very_useful_helm_feature_enter_search/
    (setq helm-echo-input-in-header-line t)
    ;; (defun helm-hide-minibuffer-maybe ()
    ;;   (when (with-helm-buffer helm-echo-input-in-header-line)
    ;;     (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
    ;;       (overlay-put ov 'window (selected-window))
    ;;       (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
    ;;                               `(:background ,bg-color :foreground ,bg-color)))
    ;;       (setq-local cursor-type nil))))
    ;;
    ;; (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)
#+end_src

#+begin_src emacs-lisp
    ;; Better version of `occur'.
;;    (global-set-key [remap occur] #'helm-occur) ; helm-regexp.el
    (global-set-key (kbd "C-o")   #'helm-occur) ; helm-regexp.el
    (global-set-key (kbd "C-c o") #'helm-occur) ; helm-regexp.el
#+end_src

#+begin_src emacs-lisp
    (global-set-key (kbd "M-x") #'helm-M-x)
#+end_src

#+begin_src emacs-lisp
    ;; Speedy file opening.
    (global-set-key (kbd "<f3>")
                    #'(lambda ()
                        (interactive)
                        (let ((split-width-threshold (* 2 132)))
                          (helm-for-files))))

    ;; (global-set-key [remap find-file] #'helm-find-files) ; OK. C-x C-f
#+end_src

#+begin_src emacs-lisp
    ;; Buffer list.
    (global-set-key (kbd "C-x b") #'helm-mini) ; OK.
                                        ; = `helm-buffers-list' + recents.

    (global-set-key [remap list-buffers] #'helm-buffers-list) ; OK. C-x C-b
#+end_src

#+begin_src emacs-lisp
    ;; `dabbrev-expand' (M-/) =>`helm-dabbrev'
    ;; (define-key global-map [remap dabbrev-expand] 'helm-dabbrev)
#+end_src

**** Navigating with Structure Views

Popup structure of the current file for quick navigation:

#+begin_src emacs-lisp
    (defun leuven-helm-file-structure (arg)
      "Jump to a place in the buffer using an Index menu.
    For Org mode buffers, show Org headlines.
    For programming mode buffers, show functions, variables, etc."
      (interactive "P")
      (cond ((derived-mode-p 'org-mode) (helm-org-in-buffer-headings))
            ((derived-mode-p 'tex-mode) (helm-imenu))
            (t (helm-semantic-or-imenu arg)))) ; More generic than `helm-imenu'.

    (global-set-key (kbd "<C-f12>") #'leuven-helm-file-structure) ; Awesome.
    ;; (global-set-key (kbd "<f4>") #'leuven-helm-file-structure)
                                        ; And `C-c =' (like in RefTeX)?

    (global-set-key (kbd "C-c o") #'helm-org-agenda-files-headings)
#+end_src

#+begin_src emacs-lisp
    ;; (global-set-key (kbd "M-5") #'helm-etags-select)
#+end_src

#+begin_src emacs-lisp
    (global-set-key (kbd "C-h a") #'helm-apropos) ; OK!
#+end_src

#+begin_src emacs-lisp
    (global-set-key (kbd "C-h i") #'helm-info-emacs) ; OK.
    ;; (global-set-key (kbd "C-h d") #'helm-info-at-point)
    ;; (global-set-key (kbd "C-h 4") #'helm-info-elisp)
#+end_src

#+begin_src emacs-lisp
    ;; (global-set-key (kbd "C-S-h C-c") #'helm-wikipedia-suggest)
#+end_src

#+begin_src emacs-lisp
    (global-set-key (kbd "C-h b") #'helm-descbinds) ; OK.
#+end_src

See helm-flycheck!

#+begin_src emacs-lisp :tangle no
(use-package helm-flycheck
  :ensure t
  :bind (("M-g f"   . my-helm-flycheck)
         ("C-c ! l" . my-helm-flycheck))
  :config
  (defun my-helm-flycheck ()
    "This function makes sure that flycheck has been finished
before running helm-flycheck"
    (interactive)
    (require 'flycheck)
    (if flycheck-mode
        (call-interactively 'helm-flycheck)
      (flycheck-mode)
      (message "[Just turned FlyCheck on, wait a bit for errors to appear...]")
      (run-with-idle-timer 1 nil #'helm-flycheck))))
#+end_src

#+begin_src emacs-lisp
  )                                     ; require 'helm-config ends here.
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load "helm"
#+end_src

#+begin_src emacs-lisp
    ;;! Rebind TAB to do persistent action
    (define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i")   #'helm-execute-persistent-action)
                                        ; Make TAB works in terminal.

    ;; List available actions using C-z.
    ;; (define-key helm-map (kbd "C-z")       #'helm-select-action)
    (define-key helm-map (kbd "<backtab>") #'helm-select-action)
#+end_src

#+begin_src emacs-lisp
    (define-key helm-map (kbd "C-M-n") #'helm-next-source)

    (define-key helm-map (kbd "C-M-p") #'helm-previous-source)

    ;; @ reserved for searching inside buffers! (See C-h m)

    ;; Various functions for Helm (Shell history, etc.).
    (require 'helm-misc)
    ;; For multi-line items in e.g. minibuffer history, match entire items,
    ;; not individual lines within items.

    ;; (try-require 'helm-dictionary)

    ;; Use the *current window* (no popup) to show the candidates.
    (setq helm-full-frame nil)

    ;; Open `helm-buffer' in another window.
    (setq helm-split-window-default-side 'other)

    ;; Default function used for splitting window.
    (setq helm-split-window-preferred-function
          #'(lambda (window)
              (split-window-sensibly)))

    ;; ;; Move to end or beginning of source when reaching top or bottom of
    ;; ;; source.
    ;; (setq helm-move-to-line-cycle-in-source t)

    ;; Candidates separator of `multiline' source (such as
    ;; `helm-show-kill-ring').
    (setq helm-candidate-separator
          "--8<-----------------------separator------------------------>8---")

    ;; Suppress displaying sources which are out of screen at first.
    (setq helm-quick-update t)

    ;; Time that the user has to be idle for, before ALL candidates are
    ;; collected.
    (setq helm-input-idle-delay 0.75)    ; 0.06 OK // 0.70 NOK

    ;; ;; Enable adaptive sorting in all sources.
    ;; (helm-adaptive-mode 1)

    ;; ;; Enable generic Helm completion (for all functions in Emacs that use
    ;; ;; `completing-read' or `read-file-name' and friends).
    ;; (helm-mode 1)
    )
#+end_src

**** Helm find files

~helm-find-files~ is powerful because:

- It has *fuzzy matching* by default (enabled by default, but *disabled* as soon as
  you *add a space* in the pattern).

- It has highlighting on candidates depend on types: directory has a color,
  plain file has a color, executable has a color, shell script has a color.

- Depends on what file type your highlighting candidate is, Helm opens it
  appropriately. For example, if you RET on a directory, Helm opens dired; if
  you RET on a file, Helm opens that file. You can also customize the
  application to open the files. Stock find-file at least can open directory;
  Ido simply can't.

- You can open multiple files with helm-find-files by marking with C-SPC and
  press RET. If you want to everything at current directory, you can use M-a to
  mark all then RET. You can even use wildcard expression like stock find-file

- Helm has a list of actions to apply on your files: checksum file, open file
  externally, switch to eshell, grep, diff...


In helm-find-files, you can alway invoke helm-ff-do-grep with C-s or C-u C-s for
recursive searching. Probably helm-projectile can replace helm-find-files more
if it has this feature? I think you can do this by reusing projectile-grep.

helm-find-files can even find file at point. That is, you don't need to remember
ffap as well. If you write Emacs lisp, move point over the required file and
execute helm-find-files, it will prompt the file location and you simply RET to
enter. All in once nice package.


- ~C-l~ ::
     Delete the last segment of a file name (in the minibuffer).

#+begin_src emacs-lisp
  ;; Disable fuzzy matching.
  (setq helm-ff-fuzzy-matching nil)

  (with-eval-after-load "helm-files"


    ;; Don't show only basename of candidates in `helm-find-files'.
    (setq helm-ff-transformer-show-only-basename nil)

    ;; Search for library in `require' and `declare-function' sexp.
    (setq helm-ff-search-library-in-sexp t)

    ;; ;; Use `recentf-list' instead of `file-name-history' in `helm-find-files'.
    ;; (setq helm-ff-file-name-history-use-recentf t)
    )
#+end_src

#+begin_src emacs-lisp
  ;; This set Helm to open files using designated programs.
  (setq helm-external-programs-associations
        '(("rmvb" . "smplayer")
          ("mp4"  . "smplayer")))
#+end_src

See [[http://stackoverflow.com/questions/14726601/sublime-text-2s-goto-anything-or-instant-search-for-emacs][Sublime Text 2's "Goto Anything" (or instant search) for Emacs?]]
+ https://github.com/xiaohanyu/oh-my-emacs/blob/master/core/ome-completion.org

**** Descbinds

Use the separate Helm Descbinds to get a quick *key bindings* overview.  It will
make your life much easier with million Emacs keys.

#+begin_src emacs-lisp
  ;; A convenient `describe-bindings' with `helm'.
  (with-eval-after-load "helm-descbinds"

    ;; Window splitting style.
    (setq helm-descbinds-window-style 'split-window))
#+end_src

**** Grep (Find in Project)

Launchable from ~current-buffer~ or from ~helm-find-files~.

#+begin_src emacs-lisp
  ;;
  (with-eval-after-load "helm-grep-autoloads"

      (global-set-key (kbd "M-g ,") #'helm-do-grep)

      (global-set-key (kbd "M-g a") #'helm-do-grep-ag) ; Thierry Volpiatto
                                        ; Or `C-c p s s' (Helm-projectile ag?)
      (setq helm-grep-ag-command "rg --color=always --colors 'match:fg:black' --colors 'match:bg:yellow' --smart-case --no-heading --line-number %s %s %s")
      (setq helm-grep-ag-pipe-cmd-switches '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'")) ; #CDCD00

      )
#+end_src

~helm-ag-map~ and ~helm-do-ag-map~ are inherited by ~helm-map~.

| Key           | Action                                                                      |
|---------------+-----------------------------------------------------------------------------|
| C-c o         | Open other window                                                           |
| C-l           | Search in parent directory                                                  |
| C-c C-e       | Switch to edit mode                                                         |
| C-x C-s       | Save ag results to buffer (Ask save buffer name if prefix key is specified) |
| C-c C-f       | Enable helm-follow-mode                                                     |
| C-c > , right | Move to next file                                                           |
| C-c < , left  | Move to previous file                                                       |
| C-c ?         | Show help message                                                           |

If you are using ~ag~, you can place an ~.agignore~ file in the project root with
the *files* (or extensions) you would want to *ignore*.

If you use ~helm-ag~ command, you can specify option like ~-G\.js$~ search_pattern,
or if you use ~helm-do-ag~, you can use ~C-u~ prefix for specifying extension.

#+begin_src emacs-lisp
  ;; the_silver_searcher.
  (when (executable-find "ag")

    ;; The silver searcher with Helm interface.
    (with-eval-after-load "helm-ag-autoloads"

      (global-set-key (kbd "C-c s") #'helm-ag)
      (global-set-key (kbd "M-s s") #'helm-ag)

      ;; Find in Project with Ag (from project root).
      (global-set-key (kbd "C-S-f")   #'helm-do-ag-project-root) ;; Find in project. DOES NOT WORK WELL.
      (global-set-key (kbd "C-M-S-f") #'helm-do-ag-project-root) ;; Find in project. DOES NOT WORK WELL.

      ;; ;; Search with Ag.  Ask for directory first.
      ;; (global-set-key (kbd "C-S-d") #'helm-do-ag)

      ;; Search with Ag this file (like Swoop).
      (global-set-key (kbd "M-g >") #'helm-ag-this-file)

      ;; Search with Ag in current projectile project.
      (global-set-key (kbd "C-S-a") #'helm-projectile-ag)

      (global-set-key (kbd "M-g ,") #'helm-ag-pop-stack)
      ))

  (with-eval-after-load "helm-ag"

    ;; Base command of `ag'.
    (setq helm-ag-base-command (concat helm-ag-base-command " --ignore-case"))

    ;; Command line option of `ag'
    (setq helm-ag-command-option "--all-text")

    ;; Insert thing at point as search pattern.
    (setq helm-ag-insert-at-point 'symbol))
#+end_src

See https://github.com/dingmingxin/dotfiles/blob/master/config_emacs/config/custom-init-helm.el

**** Helm M-x (search for a command)

There's no denying it: it's really difficult to remember all of these various
commands.  Rather than falling back to using the mouse and menu selections,
instead type ~M-x~.

This will bring up a Helm menu, where you can then search for your desired
command.

*************** TODO Get gray for common text of candidates
See http://code.tutsplus.com/tutorials/essential-textmate-shortcuts-tips-and-techniques--net-21168
*************** END

#+begin_note
With ~helm-M-x~, to pass prefix arguments to the command you want to run, you have
to type ~C-u~ *after* typing ~M-x~ and selecting the command -- that is, *before*
pressing ~RET~.
#+end_note

#+begin_src emacs-lisp
  (with-eval-after-load "helm-command"

    ;; Save command even when it fails (on errors).
    (setq helm-M-x-always-save-history t))
#+end_src

**** Helm locate

Use Helm to *quickly navigate between files*, even in the largest projects.

#+begin_note
Locate for *Windows* users: you have to install [[http://www.voidtools.com/download.php][Everything]] with its command line
interface ~es.exe~.
#+end_note

#+begin_src emacs-lisp
  ;; (with-eval-after-load "helm-autoloads"
  ;;   (global-set-key [remap locate] #'helm-locate))

  ;; XXX Problems since Cygwin update (beginning of 2020-02).
  ;; (with-eval-after-load "helm-locate"
  ;;
  ;;   (when (and (or leuven--win32-p leuven--cygwin-p)
  ;;              (executable-find "es"))
  ;;
  ;;     ;; Sort locate results by full path.
  ;;     (setq helm-locate-command "es -s %s %s")))
#+end_src

**** Helm for buffers

As a starting point for all *searches in buffers and files*, use ~helm-buffers-list~
and ~helm-find-files~: you can launch ~helm-multi-occur~ and ~helm-do-grep~ from
there.

You can also use the ~@~ prefix to *search buffer contents*.

#+begin_src emacs-lisp
  (with-eval-after-load "helm-buffers"

    ;; Don't truncate buffer names.
    (setq helm-buffer-max-length nil)

    ;; Never show details in buffer list.
    (setq helm-buffer-details-flag nil)

    ;; String to display at end of truncated buffer names.
    (setq helm-buffers-end-truncated-string ""))
#+end_src

#+begin_src emacs-lisp
  ;; (with-eval-after-load "helm-adaptive"
  ;;
  ;;   ;; Don't save history information to file.
  ;;   (remove-hook 'kill-emacs-hook 'helm-adaptive-save-history))
#+end_src

**** Helm ring

By pressing ~M-y~, you will see the *clipboard history* (list of all previous
clipboard contents) and can pick the one you want to paste into the text using
arrow keys.  Use ~RET~ to insert it.

#+begin_src emacs-lisp
  ;; Paste from History.
  (global-set-key (kbd "M-y") #'helm-show-kill-ring) ; OK.
#+end_src

#+begin_src emacs-lisp
  ;; (global-set-key (kbd "C-h SPC") #'helm-all-mark-rings)
  (global-set-key (kbd "C-c m") #'helm-all-mark-rings)
#+end_src

~helm-all-mark-rings~ allows you to view the content of the both the *local and
global mark rings* in a friendly interface, so you can always jump back to where
you were.

#+begin_src emacs-lisp
  ;; kill-ring, mark-ring, and register browsers for Helm.
  (with-eval-after-load "helm-ring"

    ;; Max number of lines displayed per candidate in kill-ring browser.
    (setq helm-kill-ring-max-lines-number 20))
#+end_src

#+begin_src emacs-lisp
  ;; (with-eval-after-load "helm-utils"
  ;;   (setq helm-yank-symbol-first t)
#+end_src

**** Helm-ls-git

#+begin_src emacs-lisp
  ;; List Git files.
  (with-eval-after-load "helm-ls-git-autoloads"

    ;; (global-set-key (kbd "C-c C-f") #'helm-ls-git-ls) ; used by Org!
    (global-set-key (kbd "M-+")    #'helm-ls-git-ls)
    ;; (global-set-key (kbd "<S-f3>") #'helm-ls-git-ls)

    ;; Browse files and see status of project with its VCS.
    (global-set-key (kbd "C-x C-d") #'helm-browse-project))
#+end_src

See http://edvorg.com/edvorg/emacs-configs/blob/master/init.d/init-helm.el for
much more configs with Git...

**** Imenu

Imenu is like an outline tree in regular IDE, but Helm makes it interactive, and
fast.  You can ask questions such as "Is there a ~function~ whose name contains
~memory~?".

**** Google

~helm-google-suggest~ is very efficient when you get completions from Google (so
you can type only a few characters to get relevant completions) and then you can
send this completion to various services (e.g. wiki lookup), so you don't have
to start a separate Wikipedia lookup, Youtube lookup, etc. command, because you
can use the same command for any of them.

#+begin_note
You can easily add actions for other sites you usually search for info on.
#+end_note

#+begin_src emacs-lisp
  ;; Emacs Helm Interface for quick Google searches
  (with-eval-after-load "helm-google-autoloads"
    (global-set-key (kbd "C-c h g") #'helm-google)
    (global-set-key (kbd "C-c h s") #'helm-google-suggest))

  ;; (with-eval-after-load "helm-google"
  ;;
  ;;   ;; (when (executable-find "curl")
  ;;   ;;   (setq helm-google-suggest-use-curl-p t))
  ;;   )
#+end_src

**** Helm Projectile

Exploring large projects with Projectile and Helm Projectile:
http://tuhdo.github.io/helm-projectile.html

Helm Projectile replaces many Projectile "core commands", such as
`projectile-find-file`.

A few demos:

- Select and open multiple files,
  http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-files-1.gif :
  Now we can open multiple files at once with `helm-projectile`. It outweighs Ido
  + flx for finding files, since you can only open one file in Ido. Yes, you can
  open one file faster in Helm, but when you need to open two or more files,
  Helm is more suitable for the large.

- Jump to any file depends on context, even if the file path is in a text file,
  http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-files-dwim-1.gif

- Switch between other files with same names but different extensions,
  http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-other-file.gif. Work
  not only for C/C++ but other languages, and is customizable. You don't have to
  configure anything, like adding include paths for the command to
  search. Everything is automatic. Just use it as it is.

- Ediff two selected files from helm-projectile-find-file,
  http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-file-ediff.gif.

- Invoke Etags while in helm-projectile-find-file session; when in Etags
  session, you can switch back later to helm-projectile-find-file,
  http://tuhdo.github.io/static/helm-projectile/helm-projectile-etags.gif.

- You can invoke `helm-do-grep` on any project directory when using
  a `helm-projectile` command.

Key bindings:

- ~C-c p p~ for ~helm-projectile-switch-project~
- ~C-c p f~ for ~helm-projectile-find-file~
- ~C-c p s g~ for ~helm-projectile-grep~
- ~C-c p s a~ for ~helm-projectile-ag~

#+begin_src emacs-lisp
  ;; Disable fuzzy matching for Helm Projectile commands.
  (setq helm-projectile-fuzzy-match nil)

  ;; (global-set-key (kbd "C-;") #'helm-projectile)
#+end_src

**** Lisp completion

#+begin_warning
This (from Thierry Volpiatto) seems good, except that it changes the behavior of
~TAB~ when done in a word.  Instead of indenting, it completes the word at point,
changing the buffer's contents!
#+end_warning

#+begin_src emacs-lisp :tangle no
  ;; Lisp complete or indent.
  (define-key lisp-interaction-mode-map
    [remap indent-for-tab-command] #'helm-lisp-completion-at-point-or-indent)
  (define-key emacs-lisp-mode-map
    [remap indent-for-tab-command] #'helm-lisp-completion-at-point-or-indent)
#+end_src

~M-TAB~?

#+begin_src emacs-lisp
  ;; Lisp complete.
  (define-key lisp-interaction-mode-map
    [remap completion-at-point] #'helm-lisp-completion-at-point)
  (define-key emacs-lisp-mode-map
    [remap completion-at-point] #'helm-lisp-completion-at-point)
#+end_src

**** Helm swoop

# Occur Edit mode applies edits made in ~*Occur*~ buffers to the original buffers.
# It is bound to ~e~ in Occur mode.

Pressing twice C-o goes from Helm Swoop to Helm Multi Swoop...

#+begin_src emacs-lisp
  ;; Efficiently hopping squeezed lines powered by Helm interface
  ;; (= Helm occur + Follow mode!).
  (with-eval-after-load "helm-swoop-autoloads"

    ;; Better version of `(helm-)occur'.
    (global-set-key (kbd "C-o")   #'helm-swoop)
    (global-set-key (kbd "M-s o") #'helm-swoop)
    ;; (global-set-key (kbd "M-i") #'helm-swoop)
    ;; (global-set-key (kbd "M-I") #'helm-swoop-back-to-last-point)

    (global-set-key (kbd "M-s O") #'helm-multi-swoop)
    (global-set-key (kbd "M-s /") #'helm-multi-swoop)
    ;; (global-set-key (kbd "C-c M-i") #'helm-multi-swoop)

    ;; (global-set-key (kbd "C-x M-i") #'helm-multi-swoop-all)

    ;; When doing Isearch, hand the word over to `helm-swoop'.
    (define-key isearch-mode-map (kbd "C-o") #'helm-swoop-from-isearch)
    ;; (define-key isearch-mode-map (kbd "M-i") #'helm-swoop-from-isearch)

    (with-eval-after-load "dired"
      (define-key dired-mode-map (kbd "C-o") #'helm-swoop)
      ;; (define-key dired-mode-map (kbd "M-i") #'helm-swoop)
      ))

  (with-eval-after-load "helm-swoop"

    ;; Move up and down like Isearch.
    (define-key helm-swoop-map (kbd "C-r") #'helm-previous-line)
    (define-key helm-swoop-map (kbd "C-s") #'helm-next-line)
    (define-key helm-multi-swoop-map (kbd "C-r") #'helm-previous-line)
    (define-key helm-multi-swoop-map (kbd "C-s") #'helm-next-line)

    ;; From `helm-swoop' to `helm-multi-swoop-all'.
    (define-key helm-swoop-map (kbd "C-o") #'helm-multi-swoop-all-from-helm-swoop)
    ;; (define-key helm-swoop-map (kbd "M-i") #'helm-multi-swoop-all-from-helm-swoop)

    ;; Don't slightly boost invoke speed in exchange for text color.
    (setq helm-swoop-speed-or-color t)

    ;; Split direction.
    ;; (setq helm-swoop-split-direction 'split-window-horizontally)
    (setq helm-swoop-split-direction 'split-window-sensibly)

    ;; Don't save each buffer you edit when editing is complete.
    (setq helm-multi-swoop-edit-save nil))
#+end_src

*** Image mode

AFAICT you need to eval something like

    (setq image-type-header-regexps '((".*" . imagemagick)))

to be able to resize images in image-mode with imagemagick (for example, from
the "Image" menu).  If resizing works for you when visiting an image file,
I guess your imagemagick support is ok.

*************** TODO auto-image-file-mode in find-file-hook for performance reasons!?

New commands since Emacs 24.4:

- ~v~ in Dired works just as you request: it shows the image,
- ~n~ shows the next image in the same directory (~image-next-file~),
- ~p~ shows the previous image (~image-previous-file~), and
- ~q~ quits.

Get EXIF data with ~image-dired-get-exif-data~.

#+begin_src emacs-lisp
  (leuven--section "Image mode")

  ;; Show image files as images (not as semi-random bits).
  (add-hook 'find-file-hook #'auto-image-file-mode)
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 18 ends here.
#+end_src

* Using Multiple Buffers

#+begin_src emacs-lisp
;;* 19 Using Multiple (info "(emacs)Buffers")

(leuven--chapter leuven-load-chapter-19-buffers "19 Using Multiple Buffers"
#+end_src

** Listing Existing Buffers

- The ~C~ (current) column has a ~.~ for the buffer from which you came.
- The ~R~ (read-only) column has a ~%~ if the buffer is read-only.
- The ~M~ (modified) column has a ~*~ if it is modified.

#+begin_src emacs-lisp
;;** 19.2 (info "(emacs)List Buffers")

  (leuven--section "19.2 (emacs)List Buffers")

  (unless (locate-library "helm-autoloads")

    ;; Operate on buffers like Dired.
    (global-set-key (kbd "C-x C-b") #'ibuffer))

  (with-eval-after-load "ibuffer"

    ;; Completely replaces `list-buffer'.
    (defalias 'ibuffer-list-buffers 'list-buffer)

    ;; Don't show the names of filter groups which are empty.
    (setq ibuffer-show-empty-filter-groups nil)

    ;; Filtering groups.
    (setq ibuffer-saved-filter-groups
          '(("default"
             ("Chat"
              (mode . circe-mode))
             ("Org"
              (or (mode . diary-mode)
                  (mode . org-mode)
                  (mode . org-agenda-mode)))
             ("LaTeX"
              (or (mode . latex-mode)
                  (mode . LaTeX-mode)
                  (mode . bibtex-mode)
                  (mode . reftex-mode)))
             ("Gnus & News"
              (or (mode . message-mode)
                  (mode . bbdb-mode)
                  (mode . mail-mode)
                  (mode . gnus-group-mode)
                  (mode . gnus-summary-mode)
                  (mode . gnus-article-mode)
                  (name . "^\\(\\.bbdb\\|dot-bbdb\\)$")
                  (name . "^\\.newsrc-dribble$")
                  (mode . newsticker-mode)))
             ("Files"
              (filename . ".*"))
             ("Dired"
              (mode . dired-mode))
             ("Shell"
              (mode . shell-mode))
             ("Version Control"
              (or (mode . svn-status-mode)
                  (mode . svn-log-edit-mode)
                  (name . "^\\*svn-")
                  (name . "^\\*vc\\*$")
                  (name . "^\\*Annotate")
                  (name . "^\\*git-")
                  (name . "^\\*vc-")))
             ("Emacs"
              (or (name . "^\\*scratch\\*$")
                  (name . "^\\*Messages\\*$")
                  (name . "^TAGS\\(<[0-9]+>\\)?$")
                  (name . "^\\*Occur\\*$")
                  (name . "^\\*grep\\*$")
                  (name . "^\\*Compile-Log\\*$")
                  (name . "^\\*Backtrace\\*$")
                  (name . "^\\*Process List\\*$")
                  (name . "^\\*gud\\*$")
                  (name . "^\\*Kill Ring\\*$")
                  (name . "^\\*Completions\\*$")
                  (name . "^\\*tramp")
                  (name . "^\\*compilation\\*$")))
             ("Emacs Source"
              (mode . emacs-lisp-mode))
             ("Documentation"
              (or (mode . Info-mode)
                  (mode . apropos-mode)
                  (mode . woman-mode)
                  (mode . help-mode)
                  (mode . Man-mode))))))

    (add-hook 'ibuffer-mode-hook
              #'(lambda ()
                  (ibuffer-switch-to-saved-filter-groups "default")))

    ;; Order the groups so the order is: [Default], [agenda], [emacs].
    (defadvice ibuffer-generate-filter-groups
      (after leuven-reverse-ibuffer-groups activate)
      (setq ad-return-value (nreverse ad-return-value))))
#+end_src

** Killing Buffers

#+begin_src emacs-lisp
;;** 19.4 (info "(emacs)Kill Buffer")

  (leuven--section "19.4 (emacs)Kill Buffer")

  ;; Kill this buffer without confirmation (if not modified).
  (defun leuven-kill-this-buffer-without-query ()
    "Kill the current buffer without confirmation (if not modified)."
    (interactive)
    (kill-buffer nil))

  ;; Key binding.
  (global-set-key (kbd "<S-f12>") #'leuven-kill-this-buffer-without-query)
#+end_src

** Operating on Several Buffers

#+begin_src emacs-lisp
;;** 19.5 (info "(emacs)Several Buffers")

  (leuven--section "19.5 (emacs)Several Buffers")

  ;; Put the current buffer at the end of the list of all buffers.
  (global-set-key (kbd "<M-f12>") #'bury-buffer)
#+end_src

** Convenience Features and Customization of Buffer Handling

#+begin_src emacs-lisp
;;** 19.7 (info "(emacs)Buffer Convenience") and Customization of Buffer Handling

  (leuven--section "19.7 (emacs)Buffer Convenience and Customization of Buffer Handling")

  ;; Unique buffer names dependent on file name.
  (try-require 'uniquify)

  (with-eval-after-load "uniquify"

    ;; Distinguish directories by adding extra separator.
    (setq uniquify-trailing-separator-p t))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 19 ends here.
#+end_src

* Multiple Windows

#+begin_src emacs-lisp
;;* 20 Multiple (info "(emacs)Windows")

(leuven--chapter leuven-load-chapter-20-windows "20 Multiple Windows"
#+end_src

** Concepts of Emacs Windows

#+begin_src emacs-lisp
;;** 20.1 (info "(emacs)Basic Window")

  (leuven--section "20.1 (emacs)Basic Window")
#+end_src

** Using Other Windows

#+begin_src emacs-lisp
;;** 20.3 (info "(emacs)Other Window")

  (leuven--section "20.3 (emacs)Other Window")

  (global-set-key (kbd "<f6>") #'other-window)
#+end_src

If there are two windows displayed, act like =C-x o=.
If there is only one window displayed, swap it with previous buffer.

#+begin_src emacs-lisp
  (defun leuven-switch-to-other-window-or-buffer ()
    "If there is only one window displayed, swap it with previous buffer.
If there are two or more windows displayed, act like `other-window':
cycle through all windows on current frame."
    (interactive)
    (if (one-window-p t)
        (switch-to-buffer (other-buffer (current-buffer) 1))
      (other-window -1)))

  (global-set-key (kbd "<f6>") #'leuven-switch-to-other-window-or-buffer)
#+end_src

#+begin_src emacs-lisp
  ;; Reverse operation of `other-window' (`C-x o').
  (global-set-key (kbd "<S-f6>") #'previous-multiframe-window)
#+end_src

** Deleting and Rearranging Windows

If there is only one window displayed, act like ~C-x 2~ or ~C-x 3~.  If there are
two (or more) windows displayed, act like ~C-x 1~.

#+begin_src emacs-lisp
;;** 20.5 (info "(emacs)Change Window")

  (leuven--section "20.5 (emacs)Change Window")

  (defun leuven-delete-or-split-window ()
    "Cycle between 1 window and 2 windows.

  When splitting the window, the new window is selected, as it
  makes more sense to do something there first.

  The window's contents is unchanged by default.

  Do you want to see another part of the same file?  You've
  nothing to do.

  Do you want to see the last file you were visiting?  Simply
  bury the current buffer (M-<F12>).

  Do you want to go back to the first window?  Switch to
  it (<F6>)."
    (interactive)
    (cond ((one-window-p t)
           (select-window
            (if (> (frame-width) split-width-threshold)
                (split-window-horizontally)
              (split-window-vertically))))
          (t
           (delete-other-windows))))

  ;; Delete all windows in the selected frame except the selected window.
  (global-set-key (kbd "<f5>") #'leuven-delete-or-split-window)
#+end_src

The following code flips a two-window frame, so that left is right, or up is
down.

#+begin_src emacs-lisp
  ;; Swap 2 windows.
  (defun leuven-swap-windows ()
    "If you have 2 windows, swap them."
    (interactive)
    (cond ((not (= (count-windows) 2))
           (message "[You need exactly 2 windows to swap them.]"))
          (t
           (let* ((wind-1 (first (window-list)))
                  (wind-2 (second (window-list)))
                  (buf-1 (window-buffer wind-1))
                  (buf-2 (window-buffer wind-2))
                  (start-1 (window-start wind-1))
                  (start-2 (window-start wind-2)))
             (set-window-buffer wind-1 buf-2)
             (set-window-buffer wind-2 buf-1)
             (set-window-start wind-1 start-2)
             (set-window-start wind-2 start-1)))))

  (global-set-key (kbd "C-c ~") #'leuven-swap-windows)
#+end_src

The following code toggles between horizontal and vertical layout of two
windows.  Useful when Emacs opens the window below instead at the side.

#+begin_src emacs-lisp
  (defun leuven-toggle-window-split ()
    "Toggle between vertical and horizontal split.
  Vertical split shows more of each line, horizontal split shows more lines.
  This code only works for frames with exactly two windows."
    (interactive)
    (cond ((not (= (count-windows) 2))
           (message "[You need exactly 2 windows to toggle the window split.]"))
          (t
           (let* ((this-win-buffer (window-buffer))
                  (next-win-buffer (window-buffer (next-window)))
                  (this-win-edges (window-edges (selected-window)))
                  (next-win-edges (window-edges (next-window)))
                  (this-win-2nd (not (and (<= (car this-win-edges)
                                              (car next-win-edges))
                                          (<= (cadr this-win-edges)
                                              (cadr next-win-edges)))))
                  (splitter
                   (if (= (car this-win-edges)
                          (car (window-edges (next-window))))
                       'split-window-horizontally
                     'split-window-vertically)))
             (delete-other-windows)
             (let ((first-win (selected-window)))
               (funcall splitter)
               (if this-win-2nd (other-window 1))
               (set-window-buffer (selected-window) this-win-buffer)
               (set-window-buffer (next-window) next-win-buffer)
               (select-window first-win)
               (if this-win-2nd (other-window 1)))))))

  (global-set-key (kbd "C-c |") #'leuven-toggle-window-split)
#+end_src

~delete-window~: if only one window in frame, ~delete-frame~:

#+begin_src emacs-lisp
  (defadvice delete-window (around delete-window (&optional window) activate)
    (interactive)
    (save-current-buffer
      (setq window (or window (selected-window)))
      (select-window window)
      (if (one-window-p t)
      (delete-frame)
        ad-do-it (selected-window))))
#+end_src

** Dedicated windows

How to avoid displaying another buffer in a specific window, making the current
window always display this buffer ("sticky window").

#+begin_src emacs-lisp
  (defun toggle-current-window-dedication ()
    "Toggle whether the current active window is dedicated or not."
    (interactive)
    (let* ((window (selected-window))
           (dedicated (window-dedicated-p window)))
      (set-window-dedicated-p window (not dedicated))
      (message "[Window %sdedicated to %s]"
               (if dedicated "no longer " "")
               (buffer-name))))

  ;; Press [pause] key in each window you want to "freeze".
  (global-set-key (kbd "<pause>") #'toggle-current-window-dedication)
#+end_src

** Displaying a Buffer in a Window

Splits screen vertically if the width of the window is large enough.

See
http://stackoverflow.com/questions/1381794/too-many-split-screens-opening-in-emacs
for alternative code...

See as well ~split-window-preferred-function~.

#+begin_src emacs-lisp
;;** 20.6 (info "(emacs)Displaying Buffers")

  (leuven--section "20.6 (emacs)Pop Up Window")

  ;; Don't allow splitting windows vertically.
  (setq split-height-threshold nil)

  ;; ;; Minimum width for splitting windows horizontally.
  ;; (setq split-width-threshold (* 2 80))      ; See `split-window-sensibly'.
#+end_src

** Window Handling Convenience Features and Customization

Use ~M-x scroll-all-mode~ to scroll all visible windows together in parallel.

#+begin_src emacs-lisp
)                                       ; Chapter 20 ends here.
#+end_src

* Frames and Graphical Displays

#+begin_src emacs-lisp
;;* 21 (info "(emacs)Frames") and Graphical Displays

(leuven--chapter leuven-load-chapter-21-frames "21 Frames and Graphical Displays"
#+end_src

** Mouse Commands for Editing

#+begin_src emacs-lisp
;;** 21.1 (info "(emacs)Mouse Commands")

  (leuven--section "21.1 (emacs)Mouse Commands")

  ;; Scroll one line at a time.
  (setq mouse-wheel-scroll-amount
        '(1
          ((shift) . 1)))

  ;; Paste at text-cursor, not at mouse-cursor.
  (setq mouse-yank-at-point t)
#+end_src

** Creating Frames

#+begin_src emacs-lisp
;;** 21.6 (info "(emacs)Creating Frames")

  (leuven--section "21.6 (emacs)Creating Frames")
#+end_src

1. Resize the frame to the size you want.
2. Enter ~(frame-parameters)~ in the ~*scratch*~ buffer.
3. Evaluate the form: place the cursor after the closing parenthesis, and type
   ~C-j~, so that the output goes right into the ~*scratch*~ buffer.

By putting customizations of ~default-frame-alist~ in your init file, you can
control the appearance of *all the frames* Emacs creates, including the initial
one.

#+begin_note
~initial-frame-alist~ is just for overriding properties for the first frame.
#+end_note

#+begin_src emacs-lisp
  (when (display-graphic-p)

    ;; Put Emacs exactly where you want it, every time it starts up.
    (setq initial-frame-alist
          '((top . 0)
            (left . 0)))

    ;; Auto-detect the screen dimensions and compute the height of Emacs.
    (add-to-list 'default-frame-alist
                 (cons 'height
                       (/ (-
                           ;; Height of Display 1.
                           (nth 4
                                (assq 'geometry
                                      (car (display-monitor-attributes-list)))) ; XXX Emacs 24.4 needed!
                           177)       ; Allow for Emacs' title bar and taskbar
                                      ; (from the OS).
                          (frame-char-height)))))
#+end_src

#+begin_src emacs-lisp
  ;; Title bar display of visible frames.
  (setq frame-title-format
        (format "%s Emacs%s %s%s of %s - PID: %d"
                (replace-regexp-in-string "-.*$" ""
                                          (capitalize (symbol-name system-type)))
                (if (string-match "^x86_64-.*" system-configuration)
                    "-w64"
                  "-w32")
                emacs-version
                (if (and (boundp 'emacs-repository-version)
                         emacs-repository-version)
                    (concat " (" (substring
                                  (replace-regexp-in-string
                                   " .*" "" emacs-repository-version) 0 7) ")")
                  "")
                (format-time-string "%Y-%m-%d" emacs-build-time)
                (emacs-pid)))
#+end_src

#+begin_src emacs-lisp
  (defun leuven-detach-window ()
    "Close current window and re-open it in new frame."
    (interactive)
    (let ((current-buffer (window-buffer)))
      (delete-window)
      (select-frame (make-frame))
      (set-window-buffer (selected-window) current-buffer)))
#+end_src

** Frame Commands

- ~toggle-frame-maximized~ (M-<F10> by default) ::
     Toggle maximization state of the selected frame.  Respect window manager
     screen decorations.

- ~toggle-frame-fullscreen~ (<F11> by default) ::
     Toggle fullscreen mode of the selected frame.  *Hide window manager screen
     decorations*, giving slightly more screen space to Emacs itself.

#+begin_src emacs-lisp
;;** 21.7 (info "(emacs)Frame Commands")

  (leuven--section "21.7 (emacs)Frame Commands")

  ;; Maximize Emacs frame by default.
  (modify-all-frames-parameters '((fullscreen . maximized)))

  ;; Full screen.
  (global-set-key (kbd "<C-S-f12>") #'toggle-frame-fullscreen)
#+end_src

** Speedbar Frames

#+begin_src emacs-lisp
;;** 21.9 (info "(emacs)Speedbar")

  (leuven--section "21.9 (emacs)Speedbar Frames")

  (unless (featurep 'helm-config)       ; Helm is better than speedbar!

    ;; Jump to speedbar frame.
    (global-set-key (kbd "<f4>") #'speedbar-get-focus))

  ;; Everything browser (into individual source files), or Dired on steroids.
  (with-eval-after-load "speedbar"

    ;; Number of spaces used for indentation.
    (setq speedbar-indentation-width 2)

    ;; Add new extensions for speedbar tagging (allow to expand/collapse
    ;; sections, etc.) -- do this BEFORE firing up speedbar?
    (speedbar-add-supported-extension
     '(".bib" ".css" ".jpg" ".js" ".nw" ".org" ".php" ".png" ".R" ".tex" ".txt"
       ".w" "README"))

    ;; Bind the arrow keys in the speedbar tree.
    (define-key speedbar-mode-map (kbd "<right>") #'speedbar-expand-line)
    (define-key speedbar-mode-map (kbd "<left>")  #'speedbar-contract-line)

    ;; Parameters to use when creating the speedbar frame in Emacs.
    (setq speedbar-frame-parameters '((width . 30)
                                      (height . 45)
                                      (foreground-color . "blue")
                                      (background-color . "white")))

    ;; Speedbar in the current frame (vs in a new frame).
    (when (and (not (locate-library "helm-config"))
                                        ; Helm is better than speedbar!
               (locate-library "sr-speedbar"))

      (autoload 'sr-speedbar-toggle "sr-speedbar" nil t)
      (global-set-key (kbd "<f4>") #'sr-speedbar-toggle)))
#+end_src

See NeoTree as well.

** Scroll Bars

#+begin_src emacs-lisp
;;** 21.12 (info "(emacs)Scroll Bars")

  (leuven--section "21.12 (emacs)Scroll Bars")

  (if (and (display-graphic-p)
           ;; (featurep 'powerline)
           )

      ;; Turn scroll bar off.
      (scroll-bar-mode -1)

    ;; Position of the vertical scroll bar.
    (setq-default vertical-scroll-bar 'right))
#+end_src

** Tool Bars

#+begin_src emacs-lisp
;;** 21.15 (info "(emacs)Tool Bars")

  (leuven--section "21.15 (emacs)Tool Bars")

  ;; Turn tool bar off.
  (when (display-graphic-p)
    (tool-bar-mode -1))
#+end_src

** Using Dialog Boxes

#+begin_src emacs-lisp
;;** 21.16 Using (info "(emacs)Dialog Boxes")

  (leuven--section "21.16 (emacs)Using Dialog Boxes")

  ;; Don't use dialog boxes to ask questions.
  (setq use-dialog-box nil)

  ;; Don't use a file dialog to ask for files.
  (setq use-file-dialog nil)
#+end_src

** Tooltips

#+begin_src emacs-lisp
;;** 21.17 (info "(emacs)Tooltips")

  (leuven--section "21.17 (emacs)Tooltips")

  ;; Disable Tooltip mode (use the echo area for help and GUD tooltips).
  (unless leuven--console-p (tooltip-mode -1))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 21 ends here.
#+end_src

* International Character Set Support

#+begin_src emacs-lisp
;;* 22 (info "(emacs)International") Character Set Support

(leuven--chapter leuven-load-chapter-22-international "22 International Character Set Support"
#+end_src

For any user who needs symbols that are not in the 7-bit ASCII set, our
recommendation is to move to Unicode UTF-8.  That is the only encoding that is
the same across all platforms and operating systems that support it.

To check your locale settings, you can have a look to what Emacs produce (in a
mail buffer) under "Important settings" when you type
~M-x report-emacs-bug RET foo RET~:

*Important settings*:
- value of ~$LC_ALL~: ~nil~
- value of ~$LC_COLLATE~: ~nil~
- value of ~$LC_CTYPE~: ~nil~
- value of ~$LC_MESSAGES~: ~nil~
- value of ~$LC_MONETARY~: ~nil~
- value of ~$LC_NUMERIC~: ~nil~
- value of ~$LC_TIME~: ~nil~
- value of ~$LANG~: ~en_US.UTF-8~
- value of ~$XMODIFIERS~: ~nil~
- ~locale-coding-system~: ~utf-8-unix~
- ~default-enable-multibyte-characters~: ~t~

#+begin_note
If ~LANG~ is set, that's enough: all the ~LC_*~ default to whatever ~LANG~ says, but
you can override them if you set them explicitly.
#+end_note

** Introduction to International Character Sets

#+begin_tip
To open (or save) a file in UTF-8, you can press ~C-x RET c utf-8 RET~
(~universal-coding-system-argument~) before the ~C-x C-f~ (or ~C-x C-s~).
#+end_tip

To help you find all the chars you need to replace by escape sequences, you can
use ~C-u C-s [^[:ascii:]]~.

~M-x describe-coding-system RET RET~

To see all the non-ASCII characters you can type with the ~C-x 8~ prefix, type
~C-x 8 C-h~.

#+begin_src emacs-lisp
;;** 22.1 (info "(emacs)International Chars")

  (leuven--section "22.1 (emacs)International Chars")

  ;; Keyboard input definitions for ISO 8859-1.
  (with-eval-after-load "iso-transl"

    ;; Add binding for "zero width space".
    (define-key iso-transl-ctl-x-8-map (kbd "0") [?]))
#+end_src

** Language Environments

#+begin_src emacs-lisp
;;** 22.2 (info "(emacs)Language Environments")

  (leuven--section "22.2 (emacs)Language Environments")

  ;; Specify your character-set locale.
  (setenv "LANG" "en_US.utf8")          ; For `svn' not to report warnings.

  ;; System locale to use for formatting time values.
  (setq system-time-locale "C")         ; Make sure that the weekdays in the
                                        ; time stamps of your Org mode files and
                                        ; in the agenda appear in English.

  ;; (setq system-time-locale (getenv "LANG"))
                                        ; For weekdays in your locale settings.
#+end_src

One could use:
- ~LC_ALL~,
- ~LC_COLLATE=C~ (or ~LC_COLLATE=POSIX~),
- ~LC_CTYPE~,
- ~LC_ALL~ or
- ~LANG~

but this won't work for a Windows binary (well for the Cygwin version) of Emacs.

** Input Methods

#+begin_src emacs-lisp
;;** 22.3 (info "(emacs)Input Methods")

  (leuven--section "22.3 (emacs)Input Methods")

  ;; Get 8-bit characters in terminal mode (Cygwin Emacs).
  (set-input-mode (car (current-input-mode))
                  (nth 1 (current-input-mode))
                  0)
#+end_src

#+begin_src emacs-lisp
  (defun leuven-list-unicode-display (&optional regexp)
    "Display a list of unicode characters and their names in a buffer."
    (interactive "sRegexp (default \".*\"): ")
    (let* ((regexp (or regexp ".*"))
           (case-fold-search t)
           (cmp #'(lambda (x y) (< (cdr x) (cdr y))))
           ;; alist like ("name" . code-point).
           (char-alist (sort (cl-remove-if-not #'(lambda (x) (string-match regexp (car x)))
                                               (ucs-names))
                             cmp)))
      (with-help-window "*Unicode characters*"
        (with-current-buffer standard-output
          (dolist (c char-alist)
            (insert (format "0x%06X\t" (cdr c)))
            (insert (cdr c))
            (insert (format "\t%s\n" (car c))))))))
#+end_src

** Recognizing Coding Systems

In GNU Emacs, when you specify the coding explicitly in the file via an explicit
~coding:~ cookie, that overrides ~file-coding-system-alist~.

XXX Declare PDF files as binary

#+begin_note
*ISO-8859-1* (also called Latin-1) is *identical to Windows-1252* (also called
CP1252) *except for the code points 128-159* (0x80-0x9F). ISO-8859-1 assigns
several control codes in this range. Windows-1252 has several characters,
punctuation, arithmetic and business symbols assigned to these code points.
https://www.i18nqa.com/debug/table-iso8859-1-vs-windows-1252.html#compare
#+end_note

#+begin_src emacs-lisp
;;** 22.6 (info "(emacs)Recognize Coding") Systems

  (leuven--section "22.6 (emacs)Recognize Coding Systems")

  ;; Default coding system (for new files), also moved to the front of the
  ;; priority list for automatic detection.
  (prefer-coding-system 'utf-8-unix)    ; Unix flavor for code blocks executed
                                        ; via Org-Babel.
#+end_src

#+begin_src emacs-lisp
;; https://lists.gnu.org/archive/html/gnu-emacs-sources/2005-12/msg00005.html
(defun leuven--do-accent (subst-list)
  "Utility cleanup function."
  (dolist (pair subst-list)
    (save-excursion
      (while (re-search-forward (car pair) nil t)
        (replace-match (cdr pair) t)))))

(defun leuven-cleanup-accent-iso-latin-1-to-utf-8 ()
  "Replace non-UTF-8 characters."
  (interactive)
  ;; See https://www.fileformat.info/info/charset/UTF-8/list.htm, then type
  ;; C-x 8 RET and then the number, followed by RET.
  (leuven--do-accent '(("\200" . "EUR")  ;; \342\202\254
                       ("\205" . "...")
                       ("\221" . "`")
                       ("\222" . "'")    ;; \342\200\231
                       ("\223" . "\"")
                       ("\224" . "\"")
                       ("\226" . "-")
                       ("\227" . "--")
                       ("\234" . "oe")
                       ("\240" . "")    ;; \302\240
                       ("\246" . "|")
                       ("\251" . "")
                       ("\253" . "")
                       ("\256" . "")
                       ("\260" . "")
                       ("\265" . "u")
                       ("\272" . "")
                       ("\273" . "")
                       ("\274" . "1/4")
                       ("\275" . "1/2")
                       ("\276" . "3/4")
                       ("\277" . "")
                       ("\300" . "")
                       ;; ("\301" . "") ;; caps spanish a ("facil")
                       ("\302" . "")
                       ("\304" . "")
                       ("\307" . "")
                       ("\310" . "")
                       ("\311" . "")
                       ("\312" . "")
                       ("\316" . "")
                       ("\317" . "")
                       ("\324" . "")
                       ("\326" . "")
                       ("\331" . "")
                       ("\337" . "ss")
                       ("\333" . "")
                       ("\340" . "")    ;; \303\240
                       ("\341" . "")    ;; \303\241
                       ("\342" . "")    ;; \303\242
                       ("\344" . "")
                       ("\347" . "")
                       ("\350" . "")    ;; \303\250
                       ("\351" . "")    ;; \303\251
                       ("\352" . "")
                       ("\353" . "")
                       ("\355" . "")
                       ("\356" . "")
                       ("\357" . "")
                       ("\361" . "")
                       ("\363" . "")    ;; \303\263
                       ("\364" . "")    ;; \303\264
                       ("\365" . "")
                       ("\366" . "")
                       ("\371" . "")
                       ("\372" . "")
                       ("\373" . "")    ;; \303\273
                       ("\374" . "")    ;; \303\274
                       )))
#+end_src

** Specifying a File's Coding System

#+begin_src emacs-lisp
;;** 22.7 (info "(emacs)Specify Coding") System of a File

  (leuven--section "22.7 (emacs)Specify Coding System of a File")

  ;; To copy and paste to and from Emacs through the clipboard (with coding
  ;; system conversion).
  (cond (leuven--win32-p
         (set-selection-coding-system 'compound-text-with-extensions))
        (t
         (set-selection-coding-system 'utf-8)))
#+end_src

** Bidirectional Editing

#+begin_src emacs-lisp :tangle no
;;** 22.19 (info "(emacs)Bidirectional Editing")

  (leuven--section "22.19 (emacs)Bidirectional Editing")

  ;; Faster scrolling (if you never expect to have to display bidirectional
  ;; scripts, such as Arabic and Hebrew).
  (setq-default bidi-paragraph-direction 'left-to-right)
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 22 ends here.
#+end_src

* Major and Minor Modes

#+begin_src emacs-lisp
;;* 23 (info "(emacs)Modes")

(leuven--chapter leuven-load-chapter-23-major-and-minor-modes "23 Major and Minor Modes"
#+end_src

** How Major Modes are Chosen

See "Syntax of Regexps":
- ~\'~ matches end of string
- ~$~ matches end of line

#+begin_src emacs-lisp
;;** 23.3 (info "(emacs)Choosing Modes")

  (leuven--section "23.3 (emacs)Choosing File Modes")
#+end_src

*** Choice based on the file name

Instead of superseding the binding in ~auto-mode-alist~, you can replace it
(brute force) with ~(setcdr (rassq 'old-mode auto-mode-alist) 'new-mode)~.

#+begin_src emacs-lisp
  ;; List of filename patterns.
  (setq auto-mode-alist
        (append '(("\\.log\\'"       . text-mode)
                  ;; ("\\.[tT]e[xX]\\'" . latex-mode)
                  ;; ("\\.cls\\'"       . LaTeX-mode)
                  ("\\.cgi\\'"       . perl-mode)
                  ;; ("[mM]akefile"     . makefile-mode)
                  (".ssh/config\\'"  . ssh-config-mode)
                  ("sshd?_config\\'" . ssh-config-mode)
                  ) auto-mode-alist))

  ;; Major mode for fontifiying ssh config files.
  (autoload 'ssh-config-mode "ssh-config-mode"
    "Major mode for fontifiying ssh config files." t)
#+end_src

#+begin_src emacs-lisp
  ;; Major mode for editing comma-separated value files.
  (with-eval-after-load "csv-mode-autoloads"

    (add-to-list 'auto-mode-alist '("\\.csv\\'" . csv-mode)))

  (with-eval-after-load "csv-mode"

    ;; Field separators: a list of *single-character* strings.
    (setq csv-separators '("," ";")))
#+end_src

*** Choice based on the interpreter name

#+begin_src emacs-lisp
  ;; List of interpreters specified in the first line (starts with `#!').
  (push '("expect" . tcl-mode) interpreter-mode-alist)
#+end_src

*** Choice based on the text at the start of the buffer

For a list of buffer beginnings, see ~magic-mode-alist~.

#+begin_src emacs-lisp
  ;; ;; Load generic modes which support e.g. batch files.
  ;; (try-require 'generic-x)
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 23 ends here.
#+end_src

* Indentation

#+begin_src emacs-lisp
;;* 24 (info "(emacs)Indentation")

(leuven--chapter leuven-load-chapter-24-indentation "24 Indentation"
#+end_src

** Indentation Commands

- ~M-m~ ::
     ~back-to-indentation~.

- ~C-M-\~ ::
     Run the command ~indent-region~ (which does the job of the imaginary command
     ~unsuck-html-layout~ in ~html-mode~).

#+begin_src emacs-lisp
;;** 24.1 (info "(emacs)Indentation Commands") and Techniques

  (leuven--section "24.1 (emacs)Indentation Commands and Techniques")

  (defun leuven-indent-buffer ()
    "Indent each non-blank line in the buffer."
    (interactive)
    (save-excursion
      (indent-region (point-min) (point-max) nil)))
#+end_src

*Code alignment* (align declarations).

#+begin_src emacs-lisp
  (defun leuven-align-code (begin end)
    "Align region to equal signs and colons."
    (interactive "r")
    ;; Keep them separate align calls, otherwise colons align with spaces if
    ;; they're in the same region.
    (align-regexp begin end "\\(\\s-*\\)=" 1 1)
    (align-regexp begin end "\\(\\s-*\\):" 1 1))

  ;; Align your code in a pretty way.
  (global-set-key (kbd "C-x \\") #'leuven-align-code)
  (global-set-key (kbd "C-c =")  #'leuven-align-code)
#+end_src

For example,

#+begin_example
var first = 3,
    second = "oh my god!",
    last = "but not least";
#+end_example

gets reindented like this:

#+begin_example
var first  = 3,
    second = "oh my god!",
    last   = "but not least";
#+end_example

#+begin_tip
For *filling code* (*pretty-format*'ting it, auto-inserting newlines, indents,
etc.), see ~uncrustify~.
#+end_tip

#+begin_src emacs-lisp
  ;; Show vertical lines to guide indentation.
  (with-eval-after-load "indent-guide-autoloads-XXX" ; Display problems with CrossMapIntegration.java

    ;; Enable indent-guide-mode automatically.
    (add-hook 'prog-mode-hook #'indent-guide-mode))

  (with-eval-after-load "indent-guide"

    ;; Character used as vertical line.
    (setq indent-guide-char
          (cond ((char-displayable-p ?\u254E) "")
                ((char-displayable-p ?\u2502) "")
                (t ":")))

    (diminish 'indent-guide-mode))
#+end_src

*************** TODO Look at the `dtrt-indent' package
*************** END

** Tabs vs. Spaces

Don't tabify.  Instead, _reindent_ everything, e.g. with ~C-M-\~.

#+begin_src emacs-lisp
;;** 24.3 TABs vs. (info "(emacs)Just Spaces")

  (leuven--section "24.3 TABs vs. (emacs)Just Spaces")

  ;; Indentation can't insert TABs.
  (setq-default indent-tabs-mode nil)
#+end_src

** Convenience Features for Indentation

#+begin_src emacs-lisp
  ;; (setq tab-always-indent 'complete)
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 24 ends here.
#+end_src

* Commands for Human Languages

#+begin_src emacs-lisp
;;* 25 Commands for (info "(emacs)Text") Human Languages

(leuven--chapter leuven-load-chapter-25-text "25 Commands for Human Languages"
#+end_src

** Words

#+begin_src emacs-lisp
;;** 25.1 (info "(emacs)Words")

  (leuven--section "25.1 (emacs)Words")
#+end_src

** Sentences

#+begin_src emacs-lisp
;;** 25.2 (info "(emacs)Sentences")

  (leuven--section "25.2 (emacs)Sentences")

  ;; ;; A single space does end a sentence.
  ;; (setq-default sentence-end-double-space nil) ; see `ispell-dictionary'
#+end_src

The default value of ~sentence-end-double-space~ is good for French as well, as
we put two spaces after a interrogation/question mark. That way, those two
spaces won't be transformed into one...

** Filling Text

There are several *no-break space* characters required for French punctuation:

- *No-break thin space* (~202F~), known in Unicode as "narrow no-break space",
  required before ~?~, ~!~ and ~;~.

- *No-break space* (~00A0~), required before ~:~ and ~~, and required after ~~.

  It can be inserted with ~S-SPC~:

  #+begin_src emacs-lisp
  (defun leuven-nbsp-command ()
    "Insert the no-break space character 00A0."
    (interactive)
    (insert-char ?\u00A0))

  (global-set-key (kbd "S-SPC") #'leuven-nbsp-command)
  #+end_src

They could be used to avoid breaking at certain bad places.

Another solution to avoid that is to add ~fill-french-nobreak-p~ to
~fill-nobreak-predicate~.

#+begin_src emacs-lisp
;;** 25.5 (info "(emacs)Filling") Text

  (leuven--section "25.5 (emacs)Filling Text")

  ;; Line-wrapping beyond that column (when pressing `M-q').
  (setq-default fill-column 80)

  ;; (Un-)fill paragraph.
  (defun leuven-fill-or-unfill-paragraph (count)
    "Like `fill-paragraph', but unfill if used twice."
    (interactive "P")
    (let ((fill-column
           (if count
               (prefix-numeric-value count)
             (if (eq last-command 'leuven-fill-or-unfill-paragraph)
                 (progn (setq this-command nil)
                        (point-max))
               fill-column))))
      (if (derived-mode-p 'org-mode)
          (org-fill-paragraph)
        (fill-paragraph))))

  ;; M-q.
  (global-set-key [remap fill-paragraph] #'leuven-fill-or-unfill-paragraph)
  (with-eval-after-load "org"
    (define-key org-mode-map (kbd "M-q") #'leuven-fill-or-unfill-paragraph))

  ;; Prevent breaking lines just before a punctuation mark such as `?' or `:'.
  (add-hook 'fill-nobreak-predicate #'fill-french-nobreak-p)

  ;; Activate Auto Fill for all text mode buffers.
  (add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

#+begin_src emacs-lisp
  (defun leuven-replace-nbsp-by-spc ()
    "Replace all nbsp by normal spaces."
    (interactive "*")
    (save-excursion
      (save-restriction
        (save-match-data
          (progn
            (goto-char (point-min))
            (while (re-search-forward "[]" nil t)
              (replace-match " " nil nil)))))))
#+end_src

#+begin_src emacs-lisp
  (defun leuven-good-old-fill-paragraph ()
    (interactive)
    (let ((fill-paragraph-function nil)
          (adaptive-fill-function nil))
      (fill-paragraph)))
#+end_src

*************** TODO Replace ' by `' in Emacs Lisp and by `` in other modes
*************** END

#+begin_src emacs-lisp
  ;; (defun leuven-smart-punctuation-apostrophe ()
  ;;   "Replace second apostrophe by backquote in front of symbol."
  ;;   (interactive)
  ;;   (cond
  ;;    ((or (bolp) (not (looking-back "'")))
  ;;     ;; Insert just one '.
  ;;     (self-insert-command 1))
  ;;    ((save-excursion
  ;;       (backward-char)
  ;;       ;; Skip symbol backwards.
  ;;       (and (not (zerop (skip-syntax-backward "w_.")))
  ;;            (not (looking-back "`"))
  ;;            (or (insert-and-inherit "`") t))))
  ;;    (t
  ;;     ;; Insert `' around following symbol.
  ;;     (delete-char -1)
  ;;     (unless (looking-back "`") (insert-and-inherit "`"))
  ;;     (save-excursion
  ;;       (skip-syntax-forward "w_.")
  ;;       (unless (looking-at "'") (insert-and-inherit "'"))))))

  (defun leuven-smart-punctuation-quotation-mark ()
    "Replace two following double quotes by French quotes."
    (interactive)
    (let ((dict (or (when (boundp 'ispell-local-dictionary)
                      ispell-local-dictionary)
                    (when (boundp 'ispell-dictionary)
                      ispell-dictionary))))
      (message "[>>> %s]" major-mode)
      (cond
       ((and (string= dict "francais")
             (eq (char-before) ?\")
             (or (not (equal mode-name "Org"))
                 (not (member (org-element-type (org-element-at-point))
                              '(src-block keyword table dynamic-block)))))
        (backward-delete-char 1)
        (insert "  ")
        (backward-char 2))
       ((and (eq (char-before) ?\")
             (derived-mode-p 'latex-mode))
        (backward-delete-char 1)
        (insert "\\enquote{}")
        (backward-char 1))
       (t
        (insert "\"")))))

  (defun leuven--smart-punctuation ()
    "Replace second apostrophe or quotation mark."
    ;; (local-set-key [39] #'leuven-smart-punctuation-apostrophe)
    (local-set-key "\"" #'leuven-smart-punctuation-quotation-mark))

  (add-hook 'text-mode-hook #'leuven--smart-punctuation)
  (add-hook 'message-mode-hook #'leuven--smart-punctuation)
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load "key-chord-autoloads"
    (key-chord-mode 1))

  ;; Map pairs of simultaneously pressed keys to commands.
  (with-eval-after-load "key-chord"

    (key-chord-define-global "<<" #'(lambda () (interactive) (insert "")))
    (key-chord-define-global ">>" #'(lambda () (interactive) (insert "")))

    ;; (key-chord-define-global "hb" #'describe-bindings) ; dashboard.
    (key-chord-define-global "hf" #'describe-function)
    (key-chord-define-global "hv" #'describe-variable)

    (with-eval-after-load "expand-region-autoloads" ; Autoloads file.
      (key-chord-define-global "hh" #'er/expand-region) ; Autoloaded.
      (key-chord-define-global "HH" #'er/contract-region)) ; Autoloaded.

    (with-eval-after-load "avy-autoloads"
      (key-chord-define-global "jj" #'avy-goto-word-or-subword-1))

    (with-eval-after-load "dired-x"
      (key-chord-define-global "xj" #'dired-jump)) ; Autoloaded?

    (key-chord-define-global "vb" #'eval-buffer)
    ;; (key-chord-define-global "vg" #'eval-region) ; 2015-02-17 Crash Gnus `C-u g'

    ;; (key-chord-define-global "x0" #'delete-window) ; 2015-02-09 Crash Gnus `C-u 3'
    ;; (key-chord-define-global "x1" #'delete-other-windows) ; 2015-02-05 Crash Gnus `C-u 1'
    (key-chord-define-global "xh" #'mark-whole-buffer)
    (key-chord-define-global "xk" #'kill-buffer)
    (key-chord-define-global "xo" #'other-window) ; box...
    (key-chord-define-global "xs" #'save-buffer)

    (key-chord-define-global "yy" #'browse-kill-ring)
    (key-chord-define-global "zk" #'zap-to-char)

    (with-eval-after-load "hl-anything-autoloads"    ; Package.
      (key-chord-define-global "*o" #'hl-global-highlight-on/off)
      (key-chord-define-global "*h" #'hl-highlight-thingatpt-global)
      (key-chord-define-global "*u" #'hl-unhighlight-all-global)
      (key-chord-define-global "*n" #'hl-find-next-thing)
      (key-chord-define-global "*p" #'hl-find-prev-thing)
      (key-chord-define-global "*r" #'hl-restore-highlights)
      (key-chord-define-global "*s" #'hl-save-highlights))

    (key-chord-define-global ";s" #'set-mark-command)

    ;; (key-chord-define-global "ac" #'align-current)
    ;; (key-chord-define-global "fc" #'flycheck-mode)
    ;; (global-set-key (kbd "M-2") #'highlight-symbol-occur)
    ;; (global-set-key (kbd "M-3") #'(lambda () (interactive) (highlight-symbol-jump -1)))
    ;; (global-set-key (kbd "M-4") #'(lambda () (interactive) (highlight-symbol-jump 1)))
    ;; (key-chord-define-global "vg" #'vc-git-grep)

    ;; (key-chord-define-global "''" "`'\C-b")
    ;; (key-chord-define-global "dq" "\"\"\C-b")
    ;; (key-chord-define-global ";d" #'dired-jump-other-window)
    ;; (key-chord-define-global "jk" #'dabbrev-expand)
    ;; (key-chord-define-global "JJ" #'xref-find-definitions)
    ;; (key-chord-define-global ",." "<>\C-b")
    ;; (key-chord-define-global "''" "`'\C-b")
    ;; (key-chord-define-global ",," #'indent-for-comment)
    )
#+end_src

** Case Conversion Commands

#+begin_src emacs-lisp
;;** 25.6 (info "(emacs)Case") Conversion Commands

  (leuven--section "25.6 (emacs)Case Conversion Commands")

  ;; Enable the use of some commands without confirmation.
  (mapc #'(lambda (command)
          (put command 'disabled nil))
        ;; Disabled commands.
        '(downcase-region
          upcase-region))
#+end_src

** Outline Mode
:PROPERTIES:
:ID:       42ad895e-c049-4710-a877-5014a7f6acfc
:END:

Outline is line-oriented and does not distinguish end-of-block.

#+begin_src emacs-lisp
;;** 25.8 (info "(emacs)Outline Mode")

  (leuven--section "25.8 (emacs)Outline Mode")
#+end_src

*** TODO outline-minor-mode (inside plain latex-mode as well)

Though Outline minor mode has NOTHING to do with folding of code as such, some
people have the following code in their ~ruby-mode-hook~ to enable code folding
using ~outline-minor-mode~ + ~outline-magic~.

#+begin_example
(outline-minor-mode 1)
(set (make-local-variable 'outline-regexp) "^[ \t]*\\(?:def\\|class\\|module\\)\\|^[ \t]*###==")
#+end_example

Outline minor mode is also used to collapse Lisp code (i.e., to see in the
buffer just the definition of a function instead of the whole body).

See also the library [[id:a36b1dbd-1d05-4ff2-b19a-167e50c4f1f7][hs-minor-mode]].

You can use ~org-cycle~ in other modes, with ~outline-minor-mode~.

See https://github.com/zk-phi/dotfiles/blob/master/emacs/init.el.

#+begin_src emacs-lisp
  ;; Outline mode commands for Emacs.
  (with-eval-after-load "outline"

    ;; Bind the outline minor mode functions to an easy to remember prefix
    ;; key (more accessible than the horrible prefix `C-c @').
    (setq outline-minor-mode-prefix (kbd "C-c C-o")) ; like in nXML mode

    ;; ;; Make other `outline-minor-mode' files (LaTeX, etc.) feel the Org
    ;; ;; mode outline navigation (written by Carsten Dominik).
    ;; (try-require 'outline-magic)
    ;; (with-eval-after-load "outline-magic"
    ;;   (add-hook 'outline-minor-mode-hook
    ;;             #'(lambda ()
    ;;               (define-key outline-minor-mode-map
    ;;                 (kbd "<S-tab>") #'outline-cycle)
    ;;               (define-key outline-minor-mode-map
    ;;                 (kbd "<M-left>") #'outline-promote)
    ;;               (define-key outline-minor-mode-map
    ;;                 (kbd "<M-right>") #'outline-demote)
    ;;               (define-key outline-minor-mode-map
    ;;                 (kbd "<M-up>") #'outline-move-subtree-up)
    ;;               (define-key outline-minor-mode-map
    ;;                 (kbd "<M-down>") #'outline-move-subtree-down))))

    ;; ;; Extra support for outline minor mode.
    ;; (try-require 'out-xtra)


    ;; Org-style folding for a `.emacs' (and much more).

    ;; FIXME This should be in an `eval-after-load' of Org, so that
    ;; `org-level-N' are defined when used

    (defun leuven--outline-regexp ()
      "Calculate the outline regexp for the current mode."
      (let ((comment-starter (replace-regexp-in-string
                              "[[:space:]]+" "" comment-start)))
        (when (string= comment-start ";")
          (setq comment-starter ";;"))
        ;; (concat "^" comment-starter "\\*+")))
        (concat "^" comment-starter "[*]+ ")))

    ;; Fontify the whole line for headings (with a background color).
    (setq org-fontify-whole-heading-line t)

    (defun leuven--outline-minor-mode-hook ()
      (setq outline-regexp (leuven--outline-regexp))
      (let* ((org-fontify-whole-headline-regexp "") ; "\n?")
             (heading-1-regexp
              (concat (substring outline-regexp 0 -1)
                      "\\{1\\} \\(.*" org-fontify-whole-headline-regexp "\\)"))
             (heading-2-regexp
              (concat (substring outline-regexp 0 -1)
                      "\\{2\\} \\(.*" org-fontify-whole-headline-regexp "\\)"))
             (heading-3-regexp
              (concat (substring outline-regexp 0 -1)
                      "\\{3\\} \\(.*" org-fontify-whole-headline-regexp "\\)"))
             (heading-4-regexp
              (concat (substring outline-regexp 0 -1)
                      "\\{4,\\} \\(.*" org-fontify-whole-headline-regexp "\\)")))
        (font-lock-add-keywords nil
         `((,heading-1-regexp 1 'org-level-1 t)
           (,heading-2-regexp 1 'org-level-2 t)
           (,heading-3-regexp 1 'org-level-3 t)
           (,heading-4-regexp 1 'org-level-4 t)))))

    (add-hook 'outline-minor-mode-hook #'leuven--outline-minor-mode-hook)

    ;; Add the following as the top line of your `.emacs':
    ;;
    ;; ; -*- mode: emacs-lisp; eval: (outline-minor-mode 1); -*-
    ;;
    ;; Now you can add `;;' and `;;*', etc. as headings in your `.emacs'
    ;; and cycle using `<S-tab>', `<M-left>' and `<M-right>' will collapse
    ;; or expand all headings respectively.  I am guessing you mean to make
    ;; segments such as `;; SHORTCUTS' and `;; VARIABLES', this will do
    ;; that, but not too much more.
    )
#+end_src

For Emacs Lisp, Stefan Monnier additionally uses:

#+begin_src emacs-lisp
    (add-hook 'outline-minor-mode-hook
              #'(lambda ()
                  (when (and outline-minor-mode (derived-mode-p 'emacs-lisp-mode))
                    (hide-sublevels 1000))))
#+end_src

which starts outline-minor-mode by hiding all the bodies of functions.

He also uses ~reveal-mode~ which automatically unhides the bodies when you try to
move the cursor into them (so you don't need to remember the key sequences to
use for opening/closing elements).

*** org-global-cycle + outline-magic

The visibility-cycling features are written in a way that they are independent
of the outline setup.  The following setup provides standard Org mode
functionality (headline folding and unfolding) in ~outline-minor-mode~ on
~C-TAB~ and ~S-TAB~.  We use ~C-TAB~ instead of ~TAB~, because ~TAB~ usually
has mode-specific tasks.

Note that for ~C-TAB~ to work, the cursor needs to be on a headline (the line
where the ellipsis shows).

#+begin_src emacs-lisp
  ;; (add-hook 'outline-minor-mode-hook
  ;;   #'(lambda ()
  ;;     (define-key outline-minor-mode-map (kbd "<C-tab>") #'org-cycle)
  ;;     (define-key outline-minor-mode-map (kbd "<S-tab>") #'org-global-cycle))) ; backtab?
#+end_src

Now doing

    M-x find-library RET ox.el RET

    S-TAB (one or more times)

will give you a give quick overview of all the function names.

Or check out ~outline-magic.el~, which does this and also provides *promotion and
demotion* functionality.

*** org

#+begin_src emacs-lisp
  (global-set-key (kbd "<S-tab>") #'org-cycle) ; that works (but on level 1+)
  ;; TODO Look at org-cycle-global and local below, they work better, but
  ;; still on level 1+
  ;; TODO Replace it by a function which alternatively does `hide-body' and
  ;; `show-all'
#+end_src

*** org-struct-mode

> Experienced users use outline-minor-mode - It takes time to getting used to
> it.

You can also use ~orgalist~, a package that provides Org mode's plain lists in
non-Org buffers?

~org-global-cycle~ (!= ~org-cycle-global~) now works fine in buffers using
~orgstruct-mode~.

As for handling "large" files, I use this:

#+begin_src emacs-lisp
  ;; from Bastien

  ;; ;; XXX 2010-06-21 Conflicts with outline-minor-mode bindings
  ;; ;; add a hook to use `orgstruct-mode' in Emacs Lisp buffers
  ;; (add-hook 'emacs-lisp-mode-hook #'orgstruct-mode)

  (defun org-cycle-global ()
    (interactive)
    (org-cycle t))

  (global-set-key (kbd "C-M-]") #'org-cycle-global)
                                        ; XXX ok on Emacs Lisp, not on LaTeX
                                        ; S-TAB?

  ;; (defun org-cycle-local ()
  ;;   (interactive)
  ;;   (save-excursion
  ;;     (move-beginning-of-line nil)
  ;;     (org-cycle)))

  (defun org-cycle-local ()
    (interactive)
    (ignore-errors
      (end-of-defun)
      (beginning-of-defun))
    (org-cycle))

  (global-set-key (kbd "M-]") #'org-cycle-local)
                                        ; XXX ok on Emacs Lisp, not on LaTeX

;; C-M-] and M-] fold the whole buffer or the current defun.
#+end_src

I made a video to demonstrate it quickly: [[https://vimeo.com/55570133][navigating-emacs]].

This helps me survive in files like ~org.el~ and ~org-agenda.el~.

*** fold-dwim

#+begin_src emacs-lisp :tangle no
  ;; (global-set-key (kbd "C-c +") #'fold-dwim-toggle)
  ;; (global-set-key (kbd "C-c C-+") #'fold-dwim-show-all)
  ;; (global-set-key (kbd "C-c C--") #'fold-dwim-hide-all)
#+end_src

*** fold-dwim-org

#+begin_src emacs-lisp
  ;; ;; Unified user interface for Emacs folding modes, bound to Org key-strokes.
  ;; (try-require 'fold-dwim-org)
#+end_src

#+begin_src emacs-lisp
  ;; 25.8.2
  ;; Toggle display of invisible text.
  (defun leuven-toggle-show-everything (&optional arg)
    "Show all invisible text."
    (interactive (list (or current-prefix-arg 'toggle)))
    (if (derived-mode-p 'prog-mode)
        (hs-show-all)
      (visible-mode arg)))

  (global-set-key (kbd "M-A") #'leuven-toggle-show-everything) ; `M-S-a'.
#+end_src

#+begin_src emacs-lisp :tangle no
(defvar hs-hide-all nil "Current state of hideshow for toggling all.")
(make-local-variable 'hs-hide-all)

(defun hs-toggle-hiding-all ()
  "Toggle hideshow all."
  (interactive)
  (setq hs-hide-all (not hs-hide-all))
  (if hs-hide-all
      (hs-hide-all)
    (hs-show-all)))
#+end_src

** Boxquote

Use Unicode characters.

#+begin_src emacs-lisp
;;** (info "(emacs-goodies-el)boxquote")

  (leuven--section "(emacs-goodies-el)boxquote")

  (with-eval-after-load "boxquote-autoloads"
    (global-set-key (kbd "C-c q") #'boxquote-region))

  (with-eval-after-load "boxquote"
    (setq boxquote-top-and-tail  "")
    (setq boxquote-title-format  " %s")
    (setq boxquote-top-corner    "  ")
    (setq boxquote-side          "   ")
    (setq boxquote-bottom-corner "  "))
#+end_src

In Gnus, you can mark some region with enclosing tags by pressing ~C-c M-m~
(~message-mark-inserted-region~) or by clicking on ~<menu-bar> <Message> <Insert
Region Marked>~.

#+begin_example
--8<---------------cut here---------------start------------->8---
...
...
...
--8<---------------cut here---------------end--------------->8---
#+end_example

** Phonetic

#+begin_src emacs-lisp
;;** (info "phonetic")

  (leuven--section "phonetic")

  ;; Phonetic spelling.
  (when (locate-library "phonetic")
    (autoload 'phonetize-region "phonetic"
      "Translate the region according to the phonetic alphabet." t))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 25 ends here.
#+end_src

* TeX

#+begin_src emacs-lisp
;;** 25.11 (info "(emacs)TeX Mode")

(leuven--chapter leuven-load-chapter-25.11-tex-mode "25.11 TeX Mode"
#+end_src

#+begin_warning
Emacs ships with =tex-mode.el= but that's a separate thing from AUCTeX.  All
AUCTeX functions start with ~TeX-*~ or ~LaTeX-*~ (case matters) or ~font-latex-*~.
#+end_warning

** Native TeX Mode

- ~tex-mode~ or ~latex-mode~ ::
     Default Emacs built-in (La)TeX mode (menu ~TeX~; text ~LaTeX~ displayed in the
     mode line).

#+begin_src emacs-lisp
  (leuven--section "25.11 (emacs)TeX Mode")
#+end_src

Under Windows, in the *native* TeX mode, ~shell-file-name~ must be =cmdproxy.exe= to:

- avoid the error "comint-send-string: writing to process: invalid argument,
  tex-shell", and

- properly quote ~tex-start-commands~.

#+begin_src emacs-lisp
  ;; Get colored PDFLaTeX output.
  (define-derived-mode latex-output-mode fundamental-mode "LaTeX-Output"
    "Simple mode for colorizing LaTeX output."
    (set (make-local-variable 'font-lock-defaults)
         '((("^!.*" .
             compilation-error-face)    ; LaTeX error
            ("^-+$" .
             compilation-info-face)     ; Latexmk separator
            ("^Package .* Warning: .*" .
             compilation-warning-face)
            ("Reference .* undefined" .
             compilation-warning-face)
            ("^\\(?:Overfull\\|Underfull\\|Tight\\|Loose\\).*" .
             font-lock-string-face)
            ("^LaTeX Font Warning:" .
             font-lock-string-face)
            ;; ...
            ))))

  (defadvice TeX-recenter-output-buffer
    (after leuven-colorize-latex-output activate)
    (with-selected-window (get-buffer-window (TeX-active-buffer))
      (latex-output-mode)))
#+end_src

** AUCTeX

- ~TeX-mode~ or ~LaTeX-mode~ ::
     AUCTeX (menus ~Preview~, ~LaTeX~, ~Command~ and ~Ref~; text ~LaTeX/P~ displayed in
     the mode line).

AUCTeX supports TeX and extensions such as LaTeX.  For LaTeX, there is a
(major) ~LaTeX-mode~ in AUCTeX which runs (in this order):

1. ~text-mode-hook~, then
2. ~TeX-mode-hook~, and then
3. a hook ~LaTeX-mode-hook~ special to the LaTeX mode.

If you need to make a customization via a hook which is only relevant for the
LaTeX mode, put it into the ~LaTeX-mode-hook~; if it is relevant for any AUCTeX
mode, add it to ~TeX-mode-hook~ and if it is relevant for all text modes, append
it to ~text-mode-hook~.

AUCTeX defines the ~tex-mode.el~ mode names as alias of its own modes: it
aliases ~(la)tex-mode~ to ~(La)TeX-mode~.

#+begin_src emacs-lisp
  (leuven--section "25.11 (emacs)AUCTeX Mode")

;;** 1.2 (info "(auctex)Installation") of AUCTeX

  (try-require 'tex-site) ; XXX

  ;; Support for LaTeX documents.
  (with-eval-after-load "latex"
#+end_src

You can detect the *successful activation of AUCTeX*: after loading a LaTeX
file, AUCTeX gives you a ~Command~ menu.

- Press ~C-c C-c File RET RET~ to run ~dvips~ (note that the command is ~File~ and
  not ~Dvips~ as one might expect)

- Press ~C-c C-c Print RET RET~ to run ~GSview~ (also somewhat misleading name)

- If you want to print the document, do it from ~GSview~.

#+begin_src emacs-lisp
    ;; ;; LaTeX-sensitive spell checking
    ;; (add-hook 'tex-mode-hook
    ;;           #'(lambda ()
    ;;             (make-local-variable 'ispell-parser)
    ;;             (setq ispell-parser 'tex)))
#+end_src

#+begin_src emacs-lisp
;;** 2.1 (info "(auctex)Quotes")

    (leuven--section "2.1 (auctex)Quotes")

    ;; Insert right brace with suitable macro after typing left brace.
    (setq LaTeX-electric-left-right-brace t)

;;** 2.6 (info "(auctex)Completion")

    (leuven--section "2.6 (auctex)Completion")

    ;; If this is non-nil when AUCTeX is loaded, the TeX escape character `\'
    ;; will be bound to `TeX-electric-macro'.
    (setq TeX-electric-escape t)

;;** 2.8 (info "(auctex)Indenting")

    (leuven--section "2.8 (auctex)Indenting")

    ;; Leave some environments un-indented when doing `M-q'.
    (add-to-list 'LaTeX-indent-environment-list '("tikzpicture" current-indentation))
    (add-to-list 'LaTeX-indent-environment-list '("comment"     current-indentation))
    (add-to-list 'LaTeX-indent-environment-list '("sverbatim"   current-indentation))

    ;; Auto-indentation (suggested by the AUCTeX manual -- instead of adding
    ;; a local key binding to `RET' in the `LaTeX-mode-hook').
    (setq TeX-newline-function 'newline-and-indent)
#+end_src

#+begin_src emacs-lisp
;;** 4.1 Executing (info "(auctex)Commands")

    (leuven--section "4.1 Executing (auctex)Commands")

    ;; Add a command to execute on the LaTeX document.
    (add-to-list 'TeX-command-list
                 '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t))

    ;; (add-to-list 'TeX-command-list
    ;;              '("latexmk" "(run-latexmk)"
    ;;                TeX-run-function nil t :help "Run latexmk") t)
    ;; (setq TeX-command-default "latexmk")

    (defun leuven--LaTeX-mode-hook ()

      ;; Default command to run in the LaTeX buffer.
      (setq TeX-command-default         ; TeX-engine?
            (save-excursion
              (save-restriction
                (widen)
                (goto-char (point-min))
                (let ((re (concat
                           "^\\s-*\\\\usepackage\\(?:\\[.*\\]\\)?"
                           "{.*\\<\\(?:font\\|math\\)spec\\>.*}")))
                  (save-match-data
                    (if (re-search-forward re 3000 t)
                        "XeLaTeX"
                      "LaTeX"))))))

      ;; Minor mode for hiding and revealing macros and environments.
      (TeX-fold-mode t))

    (add-hook 'LaTeX-mode-hook #'leuven--LaTeX-mode-hook)

    ;; Don't ask user for permission to save files before starting TeX.
    (setq TeX-save-query nil)

    (defun TeX-default ()
      "Choose the default command from `C-c C-c'."
      (interactive)
      (TeX-save-document "")          ; or just use `TeX-save-query'
      (execute-kbd-macro (kbd "C-c C-c RET")))

    ;; Rebind the "compile command" to default command from `C-c C-c' (in LaTeX
    ;; mode only).
    (define-key LaTeX-mode-map (kbd "<f9>") #'TeX-default)

    ;; Use PDF mode by default (instead of DVI).
    (setq-default TeX-PDF-mode t)
#+end_src

A decent viewer reloads the PDF automatically when the file has changed while
staying on the same page (no need to close & reopen).

Support for forward search with PDF files means that the viewer jumps to the
page in the output file corresponding to the position in the source file.
Currently, this only works if you use the pdfsync LaTeX package and xpdf or
SumatraPDF as your PDF viewer.

#+begin_src emacs-lisp
;;** 4.2 (info "(auctex)Viewing") the formatted output

    (leuven--section "4.2 (auctex)Viewing the formatted output")

    (defvar leuven--sumatrapdf-command
      (concat leuven--windows-program-files-dir "SumatraPDF/SumatraPDF.exe")
      "Path to the SumatraPDF executable.")

    ;; Incompatible with TeX 13. Viewer configuration is now only supported via
    ;; TeX-view-program-selection.
    ;; ;; Use a saner PDF viewer (evince, SumatraPDF).
    ;; (setcdr (assoc "^pdf$" TeX-output-view-style)
    ;;         (cond ((or leuven--win32-p leuven--cygwin-p)
    ;;                `("." (concat "\"" ,leuven--sumatrapdf-command "\" %o")))
    ;;               (t
    ;;                '("." "evince %o"))))

    ;; For AUCTeX 11.86+.
    (when (or leuven--win32-p leuven--cygwin-p)
      (when (boundp 'TeX-view-program-list)
        (add-to-list 'TeX-view-program-list
                     `("SumatraPDF"
                       ,(list (concat "\"" leuven--sumatrapdf-command "\" %o"))))))

    (when (or leuven--win32-p leuven--cygwin-p)
      (setcdr (assoc 'output-pdf TeX-view-program-selection)
              '("SumatraPDF")))
#+end_src

#+begin_tip
Under Windows, we could open the PDF file with ~start "" xxx.pdf~ (in a command
prompt).
#+end_tip

#+begin_src emacs-lisp
;;** 4.7 (info "(auctex)Documentation")
#+end_src

~C-c ?~ (or ~M-x TeX-doc~) displays documentation for a package.

*************** TODO TeX-doc does not provide a list of available keywords for completion
Nor a default when point is on a command name...
*************** END

#+begin_src emacs-lisp
;;** 5.2 (info "(auctex)Multifile") Documents

    ;; ;; Assume that the file is a master file itself.
    ;; (setq-default TeX-master t)

;;** 5.3 Automatic (info "(auctex)Parsing Files")

    ;; Enable parse on load (if no style hook is found for the file).
    (setq TeX-parse-self t)

    ;; Enable automatic save of parsed style information when saving the buffer.
    (setq TeX-auto-save t)

;;** 5.4 (info "(auctex)Internationalization")

    ;; ;; XXX Insert a literal hyphen.
    ;; (setq LaTeX-babel-insert-hyphen nil)

;;** 5.5 (info "(auctex)Automatic") Customization

    ;; TODO Add beamer.el to TeX-style-path

;;*** 5.5.1 (info "(auctex)Automatic Global") Customization for the Site

    (leuven--section "5.5.1 (auctex)Automatic Global Customization for the Site")

    ;; Directory containing automatically generated TeX information.
    (setq TeX-auto-global
          (concat user-emacs-directory "auctex-auto-generated-info/"))
                                        ; Must end with a slash.

;;*** 5.5.3 (info "(auctex)Automatic Local") Customization for a Directory

    (leuven--section "5.5.3 (auctex)Automatic Local Customization for a Directory")

    ;; Directory containing automatically generated TeX information.
    (setq TeX-auto-local (concat user-emacs-directory "auctex-auto-generated-info/"))
                                        ; Must end with a slash.
#+end_src

** Preview-LaTeX

You can detect the successful activation of ~preview-latex~: after loading a
LaTeX file, ~preview-latex~ gives you a ~Preview~ menu.

#+begin_src emacs-lisp
;;** (info "(preview-latex)Top")

    (leuven--section "(preview-latex)Top")

    (with-eval-after-load "preview"

      ;; Path to `gs' command (for format conversions).
      (setq preview-gs-command
        (cond (leuven--win32-p
               (or (executable-find "gswin32c.exe")
                   "C:/texlive/2015/tlpkg/tlgs/bin/gswin32c.exe"))
                                        ; Default value.
              (t
               (or (executable-find "rungs") ; For Cygwin Emacs.
                   "/usr/bin/gs"))))
      (leuven--file-exists-and-executable-p preview-gs-command)

      ;; Scale factor for included previews.
      (setq preview-scale-function 1.2))
#+end_src

#+begin_note
This is also called when exporting from Org to PDF.  Why?

To show it, just edit the path to ~gswin32c~ and you'll see a message "Can't find
executable" in the echo area.
#+end_note

** RefTeX

AUCTeX is fantastic, and RefTeX just makes things better.

To fill in ~\ref{}~ and ~\cite{}~ commands, you can use ~C-c &~
(~reftex-view-crossref~).

*************** TODO Conflict with YASnippet prefix key and ~org-mark-ring~-push
*************** END

A Table of Contents of the entire (multifile) document with browsing
capabilities is available with ~C-c =~.  Hitting ~l~ there will show all the labels
and cites.

Labels can be created with ~C-c (~ and referenced with ~C-c )~.  When referencing,
you get a menu with all labels of a given type and context of the label
definition.  The selected label is inserted as a ~\ref~ macro.

Citations can be made with ~C-c [~ which will use a regular expression to pull out
a *formatted* list of articles from your BibTeX database.  The selected citation
is inserted as a ~\cite~ macro.

Index entries can be made with ~C-c /~ which indexes the word at point or the
current selection.  More general index entries are created with ~C-c <~.
~C-c >~ displays the compiled index.

#+begin_src emacs-lisp
    (add-hook 'LaTeX-mode-hook #'reftex-mode) ; with AUCTeX LaTeX mode

    ;; Minor mode with distinct support for `\label', `\ref', `\cite' and
    ;; `\index' in LaTeX.
    (with-eval-after-load "reftex"

      ;; Turn all plug-ins on.
      (setq reftex-plug-into-AUCTeX t)

      ;; Use a separate selection buffer for each label type -- so the menu
      ;; generally comes up faster.
      (setq reftex-use-multiple-selection-buffers t))
#+end_src

** BibTeX

#+begin_src emacs-lisp
    ;; BibTeX mode.
    (with-eval-after-load "bibtex"

      ;; Current BibTeX dialect.
      (setq bibtex-dialect 'biblatex))

    )                                   ; with-eval-after-load "latex" ends here.
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 25.11-tex-mode ends here.
#+end_src

* SGML and HTML Modes

#+begin_src emacs-lisp
(leuven--chapter leuven-load-chapter-25-text "25 Commands for Human Languages"

;;** 25.12 (info "(emacs)HTML Mode")

  (leuven--section "25.12 (emacs)HTML Mode")
#+end_src

** HTML

*** html-mode

The default HTML mode, derived from SGML mode (see the HTML and SGML menus),
works quite well for editing HTML4 documents (whose tags don't have to close).

- ~C-c C-v~ ::
     *View* your file *in your browser* (~browse-url-of-buffer~).

- ~C-c C-b~ (or ~C-c <left>~) ::
     Jump to the opening HTML tag (~sgml-skip-tag-backward~).

- ~C-c C-f~ (or ~C-c <right>~) ::
     Jump to the closing HTML tag (~sgml-skip-tag-forward~).

- ~C-c TAB~ ::
     Hide all of the angle-bracketed tags in the buffer (~sgml-tags-invisible~).
     This can be used as a cheap *preview* of *just the bare text*.

- ~C-c /~ ::
     ~sgml-close-tag~.

- ~C-M-i~ ::
     ~ispell-complete-word~.

*** html-helper-mode

You might also want to consider ~html-helper-mode~, which has a lot more
features than plain ~html-mode~:

- autocompletion,
- auto-insertion of closing tags... and
- a lot more.

When you open a buffer for HTML editing, a didactic HTML menu appears, so you
can use your mouse to invoke commands.

Using the prefix-arg (~C-u~) to relevant HTML tags, ~html-helper-mode~ will put
tags around a region you've specified.

#+begin_src emacs-lisp
  (when (locate-library "html-helper-mode")

    (autoload 'html-helper-mode "html-helper-mode"
      "Mode for editing HTML documents." t)

    ;; Invoke html-helper-mode automatically on .html files.
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . html-helper-mode))

    ;; Invoke html-helper-mode automatically on .asp files.
    (add-to-list 'auto-mode-alist '("\\.asp\\'" . html-helper-mode))

    ;; Invoke html-helper-mode automatically on .jsp files.
    (add-to-list 'auto-mode-alist '("\\.jsp\\'" . html-helper-mode)))
#+end_src

** XHTML

[[id:786a2051-476a-4277-82df-d8ebf8ba0e99][nXML]] seems to be the most recommended mode to view and edit well-formed *XHTML*
(reformulation of HTML as an XML application).

#+begin_src emacs-lisp :tangle no
  (add-to-list 'auto-mode-alist '("\\.xhtml?\\'" . xml-mode))
                                        ; Alias for `nxml-mode'.
#+end_src

Alternatively, you can use [[http://ourcomments.org/Emacs/nXhtml/doc/nxhtml.html][nXhtml]] mode, derived from nXML mode.  It adds a lot
of things useful for *XHTML* files with mixed content:

- handling *multiple major modes* (Mumamo) in one buffer (for CSS, JS, PHP and
  similar things): get the correct syntax highlighting and indentation for
  each of them,
- folding,
- improved interface to Tidy (?),
- etc.

Though, it takes a while to load.

** web-mode

[[http://web-mode.org/][web-mode]] is another alternative for editing HTML documents embedding CSS/JS and
blocks (client/server side).

#+begin_src emacs-lisp
  (with-eval-after-load "web-mode-autoloads"
    (add-to-list 'auto-mode-alist '("\\.aspx\\'"   . web-mode))
    (add-to-list 'auto-mode-alist '("\\.axvw\\'"   . web-mode)) ; ARCHIBUS view.
    (add-to-list 'auto-mode-alist '("\\.html?\\'"  . web-mode))
    (add-to-list 'auto-mode-alist '("\\.jsp\\'"    . web-mode))
    (add-to-list 'auto-mode-alist '("\\.x[ms]l\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.xhtml?\\'" . web-mode)))

  ;; Major mode for editing web templates.
  (with-eval-after-load "web-mode"

    (define-key web-mode-map (kbd "C--")      #'web-mode-fold-or-unfold)
    (define-key web-mode-map (kbd "C-+")      #'web-mode-fold-or-unfold)
    (define-key web-mode-map (kbd "M-(")      #'web-mode-element-wrap)

    (define-key web-mode-map (kbd "M-h")      #'web-mode-mark-and-expand)

    ;; Moving.
    (define-key web-mode-map (kbd "M-n")      #'web-mode-tag-next)
    (define-key web-mode-map (kbd "C-M-e")    #'web-mode-element-end)
    (define-key web-mode-map (kbd "M-<down>") #'web-mode-element-sibling-next) ;; end or next? XXX

    (define-key web-mode-map (kbd "M-p")      #'web-mode-tag-previous)
    (define-key web-mode-map (kbd "C-M-p")    #'web-mode-tag-previous)
    (define-key web-mode-map (kbd "C-M-a")    #'web-mode-element-previous)
    (define-key web-mode-map (kbd "M-<up>")   #'web-mode-element-sibling-previous)

    (define-key web-mode-map (kbd "C-M-u")    #'web-mode-element-parent)

    (define-key web-mode-map (kbd "C-M-d")    #'web-mode-element-child)


(defun web-mode-edit-element-elements-end-inside ()
  (interactive)
  (web-mode-element-end)
  (backward-char))

(defun web-mode-edit-element-utils-x-position (fx)
  (save-excursion
    (funcall fx)
    (point)))

(defun web-mode-edit-element-utils-fnil (val f)
  (if val val
    (funcall f)))

(defun web-mode-edit-element-elements-sibling-next-p ()
  (let ((parent-position
         (web-mode-edit-element-utils-fnil
          (save-excursion
            (web-mode-element-beginning)
            (web-mode-element-parent-position))
          'point))
        (tag-next-position
         (web-mode-edit-element-utils-x-position
          (lambda ()
            (web-mode-edit-element-elements-end-inside)
            (web-mode-tag-next)
            (web-mode-element-beginning)))))
    (not (= parent-position tag-next-position))))




(defun web-mode-edit-element-elements-sibling-next-or-next-parent ()
  (interactive)
  (if (web-mode-edit-element-elements-sibling-next-p)
      (web-mode-element-sibling-next)
    (web-mode-element-parent)
    (web-mode-element-sibling-next)))


    (define-key web-mode-map (kbd "M-<down>") #'web-mode-edit-element-elements-sibling-next-or-next-parent)





;; XXX What about Fold Tag Attributes?

;; C-M-a           c-beginning-of-defun
;; C-M-e           c-end-of-defun
;; C-M-h           c-mark-function
;; C-M-j           c-indent-new-comment-line
;; C-M-q           c-indent-exp
;; M-a             c-beginning-of-statement
;; M-e             c-end-of-statement
;; M-j             c-indent-new-comment-line
;; M-q             c-fill-paragraph

    ;; Script element left padding.
    (setq web-mode-script-padding
          (if (and (boundp 'standard-indent) standard-indent) standard-indent 4))

    ;; Style element left padding.
    (setq web-mode-style-padding
          (if (and (boundp 'standard-indent) standard-indent) standard-indent 4))

    ;; CSS indentation level.
    (setq-default web-mode-css-indent-offset
                  (if (and (boundp 'standard-indent) standard-indent) standard-indent 4))

    (setq-default web-mode-attr-indent-offset
                  (if (and (boundp 'standard-indent) standard-indent) standard-indent 4))

    ;; Code (JavaScript, php, etc.) indentation level.
    (setq-default web-mode-code-indent-offset
                  (if (and (boundp 'standard-indent) standard-indent) standard-indent 4))
                                        ; XXX Check out ab-pm-cf-wr-newother.axvw.

    ;; Auto-pairing.
    (setq web-mode-enable-auto-pairing t)

    ;; Enable element highlight.
    (setq web-mode-enable-current-element-highlight t) ; web-mode-current-element-highlight-face.

    ;; Enable block face (useful for setting background of <style>).
    (setq web-mode-enable-block-face t) ; web-mode-block-face.

    ;; Enable part face (useful for setting background of <script>).
    (setq web-mode-enable-part-face t) ; web-mode-part-face.

    ;; ;; Comment style : 1 = default, 2 = force server comments outside a block.
    ;; (setq web-mode-comment-style 2)
#+end_src

#+begin_src emacs-lisp
    ;; (flycheck-add-mode 'html-tidy 'web-mode)
#+end_src

Show XML path on the modeline or in an header?

#+begin_src emacs-lisp
    ;; ARCHIBUS Imenu.
    (add-to-list 'web-mode-imenu-regexp-list
                 '("\\(dataSource\\) id=\"\\([a-zA-Z0-9_]*\\)" 1 2 " "))
    (add-to-list 'web-mode-imenu-regexp-list
                 '("\\(panel\\) .*id=\"\\([a-zA-Z0-9_]*\\)" 1 2 " "))
    (add-to-list 'web-mode-imenu-regexp-list
                 '("\\(button\\).*id=\"\\([a-zA-Z0-9_]*\\)" 1 2 " "))
    (add-to-list 'web-mode-imenu-regexp-list
                 '("id=\"\\([a-zA-Z0-9_]*\\).*\\(button\\)" 2 1 " "))
#+end_src

#+begin_src emacs-lisp :tangle no
    (setq web-mode-imenu-generic-expression
          '(
            ("DataSource" "<dataSource[ ]*id=\"\\([a-zA-Z0-9-_./#]*\\)\"[ ]*>" 1)
            ;; ("Includes" "<cfinclude[ ]*template=\"\\([a-zA-Z0-9-_./#]*\\)\"[ ]*>" 1)
            ;; ("Cases" "<cfcase[ ]*value=\"\\([a-zA-Z0-9-_,. ]*\\)\".*>" 1)
            ;; ("Forms" "<form.*action[ ]*=[ ]*\"\\([a-zA-Z0-9-_#.\?=]*\\)\".*>" 1)
            ;; ("Queries" "<cfquery.*name[ ]*=[ ]*\"\\([a-zA-Z0-9-_#.]*\\)\".*>" 1)
            ;; ("Loops" "<\\(cfloop\\|cfoutput\\).*\\(list\\|to\\|query\\)[ ]*=[ ]*\"\\([a-zA-Z0-9-_#.=]*\\)\".*>" 3)
            ;; ("JSFunctions" "function[ ]*\\([a-zA-Z0-9-_]*\\)[ ]*(.*)" 1)
            ;; ("Content" "<cfcontent.*type=\"\\([a-zA-Z0-9-_./]*\\)\".*>" 1)
            ;;                             ;cfmodule, cflocation, cftransaction, cfabort, cfif?, add cfform to forms, cflock
            ))

    (add-hook 'web-mode-hook
              #'(lambda ()
                  (setq imenu-generic-expression
                        web-mode-imenu-generic-expression)))
#+end_src

#+begin_src emacs-lisp
    ;; Highlight `saveWorkflowRuleId' in AXVW files.
#+end_src

#+begin_src emacs-lisp
    )
#+end_src

** XML
:PROPERTIES:
:ID:       786a2051-476a-4277-82df-d8ebf8ba0e99
:END:

nXML mode (default for editing XML files, since GNU Emacs 23.2) does:

- real-time *validation against a schema in RELAX NG* (actually RNC, i.e. the
  "Compact" Syntax): ~C-c C-n~ (assuming RNG validation is on),

- *code completion* against the RNG schema.

Some key bindings:

- ~C-M-n~ ::
     Move forward over one element (~nxml-forward-element~).

- ~C-M-p~ ::
     Move backward over one element (~nxml-backward-element~).

- ~C-M-u~ ::
     Move up the element structure (~nxml-backward-up-element~).

- ~C-M-d~ ::
     Move down the element structure (~nxml-down-element~).

#+begin_src emacs-lisp
  (with-eval-after-load "nxml-mode"

    ;; Indent 4 spaces (for the children of an element relative to the start-tag).
    (setq nxml-child-indent 4)

    (setq nxml-slash-auto-complete-flag t)

    ;; Remove the binding of `C-c C-x' (`nxml-insert-xml-declaration'), used by
    ;; Org timeclocking commands.
    (define-key nxml-mode-map (kbd "C-c C-x") nil)

    ;; View the buffer contents in a browser.
    (define-key nxml-mode-map (kbd "C-c C-v") #'browse-url-of-buffer)
                                        ; XXX Normally bound to
                                        ; `rng-validate-mode'.
#+end_src

#+begin_src emacs-lisp
;; causes entire elements (with children) to be treated as sexps.
(setq nxml-sexp-element-flag t)
#+end_src

#+begin_src emacs-lisp
    ;; Fix XML folding.
    (add-to-list 'hs-special-modes-alist
                 '(nxml-mode
                   "<!--\\|<[^/>]*[^/]>"
                   "-->\\|</[^/>]*[^/]>"
                   "<!--"
                   nxml-forward-element
                   nil))

    (add-hook 'nxml-mode-hook 'hs-minor-mode))
#+end_src

** Highlight the closing tag (Pair highlighting)

#+begin_src emacs-lisp
  ;; Highlight the current SGML tag context (`hl-tags-face').
  (try-require 'hl-tags-mode)
  (with-eval-after-load "hl-tags-mode"

    (add-hook 'html-mode-hook
              #'(lambda ()
                  (require 'sgml-mode)
                  ;; When `html-mode-hook' is called from `html-helper-mode'.
                  (hl-tags-mode 1)))      ; XXX Can't we simplify this form?

    (add-hook 'nxml-mode-hook
              #'(lambda ()
                  (when (< (buffer-size) large-file-warning-threshold) ; View large files.
                    (hl-tags-mode 1))))

    ;; (add-hook 'web-mode-hook #'hl-tags-mode)
    )
#+end_src

** CSS

#+begin_src emacs-lisp
  ;; TODO: Handle media queries
  ;; TODO: Handle wrapped lines
  ;; TODO: Ignore vendor prefixes
  (defun leuven-sort-css-properties ()
    "Sort CSS properties alphabetically."
    (interactive)
    (let ((start (search-forward "{"))
          (end (search-forward "}")))
      (when (and start end)
        (sort-lines nil start end)
        (sort-declarations))))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 25 ends here.
#+end_src

* Editing Programs

#+begin_src emacs-lisp
;;* 26 Editing (info "(emacs)Programs")

(leuven--chapter leuven-load-chapter-26-programs "26 Editing Programs"
#+end_src

Keyboard shortcuts:

| Command          | Emacs    | Sublime Text | IntelliJ IDEA | TextMate | Atom   | Webstorm |
|------------------+----------+--------------+---------------+----------+--------+----------|
| Move line up     | C-S-up   | C-S-up       | M-S-up        |          | C-up   | M-S-up   |
| Move line down   | C-S-down | C-S-down     | M-S-down      |          | C-down | M-S-down |
| Scroll line up   | C-up     |              |               |          |        |          |
| Scroll line down | C-down   |              |               |          |        |          |

#+begin_src emacs-lisp
  ;; Swap the current and next line.
  (defun leuven-move-line-down ()
    "Move the current line down one line."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1))

  ;; Swap the current and previous line.
  (defun leuven-move-line-up ()
    "Move the current line up one line."
    (interactive)
    (transpose-lines 1)
    (forward-line -2))

  (add-hook 'prog-mode-hook
            #'(lambda ()
                (local-set-key (kbd "<C-S-down>") #'leuven-move-line-down)
                (local-set-key (kbd "<C-S-up>")   #'leuven-move-line-up)
                                        ; Sublime Text and js2-refactor.
                (local-set-key (kbd "<M-S-down>") #'leuven-move-line-down)
                (local-set-key (kbd "<M-S-up>")   #'leuven-move-line-up)))
                                        ; IntelliJ IDEA.
#+end_src

#+begin_src emacs-lisp
  ;; Move caret down and up in the editor.
  (add-hook 'prog-mode-hook
            #'(lambda ()
                ;; Scroll text of current window upward by one line.
                (local-set-key (kbd "<C-up>")   (kbd "C-u 1 C-v"))

                ;; Scroll text of current window downward by one line.
                (local-set-key (kbd "<C-down>") (kbd "C-u 1 M-v"))))
                                        ; Sublime Text + SQL Management Studio + IntelliJ IDEA.
#+end_src

*************** TODO Add "move view" up/down on C-up/down
See an example in SQL Server Management Studio
*************** END

** Major Modes for Programming Languages

Have a look at:
- [[http://cedet.sourceforge.net][CEDET]] for development in AWK, C/C++, C#, Calc, Erlang, Java, JavaScript, Make,
  PHP, Python, Ruby and Scheme,
- [[http://common-lisp.net/project/slime][SLIME]] for Common Lisp development,
- JDEE for Java programs.

Emacs tool for Emacs Lisp code analysis (to keep overview of the function calls
and dependecies between functions/variables): byte-compile-generate-call-tree

Also =who-calls.el=

#+begin_src emacs-lisp
;;** 26.1 Major Modes for (info "(emacs)Program Modes")

  (leuven--section "26.1 Major Modes for (emacs)Program Modes")
#+end_src

** Top-Level Definitions, or Defuns
:PROPERTIES:
:ID:       ea687cd8-fff0-461f-999e-c9fbc84b5901
:END:

#+begin_src emacs-lisp
;;** 26.2 Top-Level Definitions, or (info "(emacs)Defuns")

  (leuven--section "26.2 Top-Level Definitions, or (emacs)Defuns")
#+end_src

*** Navigating Between Methods

Keyboard shortcuts:

| Command                      | Emacs | Leuven | IntelliJ IDEA |
|------------------------------+-------+--------+---------------|
| Move beginning of defun      | C-M-a | M-up   | M-up          |
| Move end of defun            | C-M-e |        |               |
| Move beginning of next defun |       | M-down | M-down        |

Use ~M-up~ and ~M-down~ keys to quickly jump to the *previous* or *next function*.

#+begin_src emacs-lisp
  (defun leuven-beginning-of-next-defun ()
    "Move forward to the beginning of next defun."
    (interactive)
    (let ((current-prefix-arg -1))
      (call-interactively 'beginning-of-defun)))

  ;; Next Method.
  (global-set-key (kbd "<M-down>") #'leuven-beginning-of-next-defun)

  ;; Previous Method.
  (global-set-key (kbd "<M-up>")   #'beginning-of-defun) ; C-M-a.
#+end_src

Imenu is a great tool allowing you to *go to a function definition* (by name), but
only if the definition is *in the buffer you are currently editing* (it won't jump
and open another file).

~font-lock-mode-hook~ is run after entering a major mode. You can make use of this
to add an Imenu index to the menu bar in any mode that supports Imenu.

#+begin_src emacs-lisp
  ;; Making buffer indexes as menus.
  (try-require 'imenu)                  ; Awesome!
  (with-eval-after-load "imenu"

    ;; Imenu should always rescan the buffers.
    (setq imenu-auto-rescan t)

    ;; Add Imenu to the menu bar in any mode that supports it.
    (defun try-to-add-imenu ()
      (condition-case nil
          (imenu-add-to-menubar "Outline") ; Imenu index.
        (error nil)))
    (add-hook 'font-lock-mode-hook #'try-to-add-imenu)

    ;; Bind Imenu from the mouse.
    (global-set-key [S-mouse-3] #'imenu)
#+end_src

#+begin_src emacs-lisp
    ;; String to display in the mode line when current function is unknown.
    (setq which-func-unknown "(Top Level)")

    ;; Show current function in mode line (based on Imenu).
    (which-function-mode 1)             ; ~ Stickyfunc mode (in header line)
#+end_src

Truncate the current function name (for the mode line):

#+begin_src emacs-lisp
    (defun leuven--which-func-current ()
      (let ((current (gethash (selected-window) which-func-table)))
        (if current
            (truncate-string-to-width current 30 nil nil "...") ; 30 = OK!
          which-func-unknown)))

    (setq which-func-format
          `("[" (:propertize (:eval (leuven--which-func-current))
                             local-map ,which-func-keymap
                             face which-func
                             mouse-face mode-line-highlight
                             help-echo "mouse-1: go to beginning\n\
mouse-2: toggle rest visibility\n\
mouse-3: go to end") "]")))
#+end_src

~helm-imenu-in-all-buffers~ command pops an Helm interface with all the *Imenu tags*
*across all buffers with the same mode as the current one*.

#+begin_note
In a sense, it is similar to ~etag~ selection, but works only for the /open/
buffers -- you don't get thousands of symbols from ~etags~ to deal with.  And this
is often more convenient as you don't have to explicitly build the ~etags~ table.
#+end_note

#+begin_src emacs-lisp
  (with-eval-after-load "helm-autoloads"

    ;; Keybinding to quickly jump to a symbol in buffer.
    (global-set-key [remap imenu] #'helm-imenu)

    ;; ;; Helm Imenu tag selection across all buffers (with the same mode).
    ;; (global-set-key (kbd "C-c i") #'helm-imenu-in-all-buffers)
  )

  ;; Helm interface for Imenu.
  (with-eval-after-load "helm-imenu"

    ;; Delimit types of candidates and his value
    (setq helm-imenu-delimiter ": ")

    ;; Do not directly jump to the definition even if there is just on candidate.
    (setq helm-imenu-execute-action-at-once-if-one nil))
#+end_src

** Indentation for Programs

Changing the "hanginess" of a brace and then reindenting, will not move the
brace to a different line.  For this, you're better off getting an external
program like GNU ~indent~, which will rearrange brace location, among other
things.

#+begin_src emacs-lisp
;;** 26.3 (info "(emacs)Program Indent")ation

    (leuven--section "26.3 (emacs)Program Indentation")

    ;; Turn on auto-fill mode in Lisp modes.
    (add-hook 'lisp-mode-hook #'auto-fill-mode)
    (add-hook 'emacs-lisp-mode-hook #'auto-fill-mode)

    ;; Auto-indentation: automatically jump to the "correct" column when the RET
    ;; key is pressed while editing a program (act as if you pressed `C-j').
    (add-hook 'prog-mode-hook
              #'(lambda ()
                  (local-set-key (kbd "<RET>") #'newline-and-indent)
                  (local-set-key (kbd "C-j") #'newline)))

    ;; (defun back-to-indentation-or-beginning ()
    ;;   (interactive)
    ;;   (if (/= (point) (line-beginning-position))
    ;;       (beginning-of-line)
    ;;     (back-to-indentation)))
    ;;
    ;; (defun align-with-spaces (beg end)
    ;;   "Align selected using only spaces for whitespace."
    ;;   (interactive "r")
    ;;   (let ((indent-tabs-mode nil))
    ;;     (align beg end)))

    (with-eval-after-load "sh-script"

      ;; Use the SMIE code for navigation and indentation.
      (setq sh-use-smie t))
#+end_src

** Commands for Editing with Parentheses

#+begin_src emacs-lisp
;;** 26.4 Commands for Editing with (info "(emacs)Parentheses")

  (leuven--section "26.4 Commands for Editing with (emacs)Parentheses")

  ;; Check for unbalanced parentheses in the current buffer.
  (dolist (mode '(emacs-lisp clojure js2 js))
    (add-hook (intern (format "%s-mode-hook" mode))
              #'(lambda ()
                  (add-hook 'after-save-hook 'check-parens nil t))))

  ;; Move cursor to offscreen open-paren when close-paren is inserted.
  (setq blink-matching-paren 'jump-offscreen) ; XXX Doesn't work when
                                              ; `show-paren-mode' is enabled.

  ;; Highlight matching paren.
  (show-paren-mode 1)
  (setq show-paren-style 'mixed)
  (setq show-paren-ring-bell-on-mismatch t)

(setq show-paren-when-point-inside-paren t)
(setq show-paren-when-point-in-periphery t)
#+end_src

*** Rainbow Parentheses

Automagically highlight matching parentheses in source code.

#+begin_src emacs-lisp :tangle no
  ;; Highlight nested parens, brackets, braces a different color at each depth.
  (with-eval-after-load "rainbow-delimiters-autoloads"

    ;; Enable rainbow-delimiters in programming modes.
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

To customize it, see
http://yoo2080.wordpress.com/2013/12/21/small-rainbow-delimiters-tutorial/.

*** Navigating to Parentheses

#+begin_src emacs-lisp
  ;; XXX Navigate to the code block start.
  (global-set-key (kbd "C-)") #'forward-sexp)
  (global-set-key (kbd "C-(") #'backward-sexp)
#+end_src

#+begin_src emacs-lisp
  ;; Jump to matching parenthesis.
  (defun leuven-goto-matching-paren (arg)
    "Go to the matching parenthesis, if on a parenthesis."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
          ((looking-at "\\s\)") (forward-char 1) (backward-list 1))))

  (global-set-key (kbd "C-S-)") #'leuven-goto-matching-paren)
  (global-set-key (kbd "C-")   #'leuven-goto-matching-paren)
#+end_src

*** Matching Parentheses

Balanced editing: inserting two matching parentheses at once, etc.

- autopair

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "autopair-autoloads-XXX"

    ;; Attempts to wrap the selected region.
    (setq autopair-autowrap t)

    ;; Enable Autopair-Global mode.
    (autopair-global-mode 1))
#+end_src

- ~electric-pair-mode~ (in Emacs, since 24.1)

  Here's a quick summary (~|~ marks point):

  + typing ~((((~ makes            ~((((|))))~
  + typing ~))))~ afterwards makes ~(((())))|~
  + if the buffer has too many closers, an opener before them will *not* autopair
  + if the buffer has too many openers, a closer after them will *not* autoskip
  + in a mixed parenthesis situation with ~[]~'s and ~()~'s, it tries to do
    sensible things

  As of Emacs 24.4, this mode is greatly improved and matches autopair.el in
  functionality (also recommended by the autopair author).

- *paredit* is (was?) the thing to use for Emacs Lisp!

  Paredit-kill kills text until next paren or double quote!  Also exists now in
  smartparens strict mode...

#+begin_src emacs-lisp :tangle no
  ;; Minor mode for editing parentheses.
  (with-eval-after-load "paredit-autoloads-XXX"

    (add-hook 'emacs-lisp-mode-hook #'paredit-mode)

    ;; Common Lisp editing extensions.
    (with-eval-after-load "redshank"    ; Requires `paredit'.

      (add-hook 'emacs-lisp-mode-hook #'redshank-mode)))
#+end_src

  Use it in ELisp; use smartparens in other modes (NOT globally!)

  Keep looking at the [[http://www.emacswiki.org/emacs/PareditCheatsheet][cheatsheet]] until you've got the hang of it.

  [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][The Animated Guide to Paredit]]

- *smartparens*

  Pair can be simple as parentheses or brackets, or can be programming tokens
  such as ~if~ ... ~fi~ or ~if~ ... ~end~ in many languages (see face
  ~sp-show-pair-match-face~).

  If you get into any serious lisp coding, check out ~paredit~ -- it forces you to
  always have balanced brackets in the file, thus avoiding a whole class of
  silly but hard-to-spot mistakes on lines ending with and avalanche of ~)))))~.

  If you are less into bondage & submission, ~smartparens.el~ is another option,
  it *helps* to have balanced brackets without breaking your will ;-)

  It is more about ease-of-coding than B&D.

  #+begin_note
  If we believe Xiao Hanyu, smartparens is the future, it is the ultimate
  solution for paren pairs management in Emacs world.  It is flexible, uniform
  and highly customizable.  It is also bundled with a comprehensive
  documentation, besides a Wiki, you can also ~M-x sp-cheat-sheet~ to get live
  examples, which, I think, is really a innovative feature.
  #+end_note

  *Bug 18785: Emacs hangs with Org mode when point is in LOGBOOK.*

  - ~C-M-e~ (~sp-up-sexp~) ::
       Move forward out of one level of parentheses.

  - ~C-M-u~ (~sp-backward-up-sexp~) ::
       Move backward out of one level of parentheses.

  - ~C-M-<backspace>~ (~sp-splice-sexp-killing-backward~) ::
       Unwrap the current list and kill all the expressions between start of
       this list and the point.

       This one's surpisingly useful for writing prose.

  - ~C-S-<backspace>~ or ~M-R~ ? (~sp-splice-sexp-killing-around~) ::
       Unwrap the current list and kill everything inside except next
       expression.

  - ~C-<right>~ (~sp-forward-slurp-sexp~) ::
       Add sexp following the current list in it by moving the closing
       delimiter.

  - ~C-<left>~ (~sp-forward-barf-sexp~) ::
       Remove the last sexp in the current list by moving the closing delimiter.

#+begin_src emacs-lisp
  ;; Automatic insertion, wrapping and paredit-like navigation with user defined
  ;; pairs.
  (with-eval-after-load "smartparens-autoloads-XXX"

    ;; Default configuration for smartparens package.
    (require 'smartparens-config)       ; Keybinding management, markdown-mode,
                                        ; org-mode, (la)tex-mode, Lisp modes,
                                        ; C++, PHP.
    (global-set-key "\M-R" #'sp-splice-sexp-killing-around) ; `sp-raise-sexp'.

    ;; Toggle Smartparens mode in all buffers.
    (smartparens-global-mode 1)         ; How to disable this in large files?

    ;; Toggle Show-Smartparens mode in all buffers.
    (show-smartparens-global-mode 1)

    ;; Remove local pairs in Text mode.
    (sp-local-pair 'text-mode "'" nil :actions nil)
    (sp-local-pair 'text-mode "\"" nil :actions nil)

    (push 'latex-mode sp-ignore-modes-list)
#+end_src

#+begin_src emacs-lisp :tangle no
    (require 'smartparens-org)
#+end_src

  Combining the regular ~kill-line~ with ~sp-kill-sexp~: ~kill-line~ everywhere, and
  ~sp-kill-sexp~ with a prefix.

#+begin_src emacs-lisp
    (defun leuven-sp-kill-maybe (arg)
      (interactive "P")
      (if (consp arg)
          (sp-kill-sexp)
        (kill-line arg)))

    (global-set-key [remap kill-line] #'leuven-sp-kill-maybe)
#+end_src

  =turn-on-smartparens-strict-mode= adds years to one's life to allow for more
  hacking.  Seriously.  XXX

#+begin_src emacs-lisp :tangle no
    ;; ;; Enable smartparens-strict-mode in all Lisp modes.
    ;; (mapc #'(lambda (mode)
    ;;         (add-hook (intern (format "%s-hook" (symbol-name mode)))
    ;;                   #'smartparens-strict-mode))
    ;;       sp--lisp-modes)
#+end_src

#+begin_src emacs-lisp
    )
#+end_src

** Manipulating Comments

#+begin_src emacs-lisp
;;** 26.5 (info "(emacs)Comments")

  (leuven--section "26.5 (emacs)Comments")

  ;; Always comments out empty lines.
  (setq comment-empty-lines t)

  (unless (locate-library "smart-comment-autoloads-XXX")

    (defadvice comment-dwim (around leuven-comment activate)
      "When called interactively with no active region, comment a single line instead."
      (if (or (use-region-p) (not (called-interactively-p 'any)))
          ad-do-it
        (comment-or-uncomment-region (line-beginning-position)
                                     (line-end-position))
        (message "[Commented line]"))))

  (with-eval-after-load "smart-comment-autoloads-XXX"

    (global-set-key (kbd "M-;") #'smart-comment))
#+end_src

** Documentation Lookup

Function argument hint.  Highlight the arguments in
~eldoc-highlight-function-argument~.

#+begin_src emacs-lisp
;;** 26.6 (info "(emacs)Documentation") Lookup

  (leuven--section "26.6 (emacs)Documentation Lookup")

  ;; Idle time to wait before printing documentation.
  (setq eldoc-idle-delay 0.2)

  ;; Resize echo area to fit documentation.
  (setq eldoc-echo-area-use-multiline-p t)
#+end_src

New minor mode ~global-eldoc-mode~ is enabled by default in Emacs 25.

#+begin_src emacs-lisp
  ;; ;; Show the function arglist or the variable docstring in the echo area.
  ;; (global-eldoc-mode)                 ; In Emacs 25.
#+end_src

** Hideshow minor mode (code folding)
:PROPERTIES:
:ID:       a36b1dbd-1d05-4ff2-b19a-167e50c4f1f7
:END:

XXX See http://stackoverflow.com/questions/2399612/why-is-there-no-code-folding-in-emacs

Hideshow can *fold* and unfold (i.e. hide and un-hide) logical blocks of *code* in
many programming modes.

~hs-minor-mode.el~ collapses code for a lot of languages, not only Lisp.  See
[[id:42ad895e-c049-4710-a877-5014a7f6acfc][outline-minor-mode]] as well.

And the pretty awesome ~hideshow-org~.  Folding made useful.

Keyboard shortcuts:

| Command                         | Emacs | Sublime Text | Visual Studio | Webstorm |
|---------------------------------+-------+--------------+---------------+----------|
| Fold (collapse) region          |       | C-S-[        | C-S-[         | C--      |
| Unfold (uncollapse) region      |       | C-S-]        | C-S-]         | C-+      |
|---------------------------------+-------+--------------+---------------+----------|
| Fold (collpase) All regions     |       |              | C-k C-0       | C-S--    |
| Unfold (uncollapse) All regions |       | C-k C-j      |               | C-S-+    |
|---------------------------------+-------+--------------+---------------+----------|
| Fold (collapse) Tag Attributes  |       | C-k C-t      |               |          |

#+begin_src emacs-lisp
;;** 26.7 (info "(emacs)Hideshow") minor mode

  (leuven--section "26.7 (emacs)Hideshow minor mode")

  ;; Enable Hideshow (code folding) for programming modes.
  (add-hook 'prog-mode-hook #'hs-minor-mode)

  (with-eval-after-load "hideshow"

    ;; Unhide both code and comment hidden blocks when doing incremental search.
    (setq hs-isearch-open t)

    (defadvice goto-line (after expand-after-goto-line activate compile)
      (save-excursion (hs-show-block)))

    (defadvice xref-find-definitions (after expand-after-xref-find-definitions activate compile)
      (save-excursion (hs-show-block)))

    ;; Change those really awkward key bindings with `@' in the middle.

    ;; Folding / Expand block.
    (define-key hs-minor-mode-map (kbd "<C-kp-add>")        #'hs-show-block)
                                        ; `C-c @ C-s' (expand current fold)
    ;; Folding / Collapse block.
    (define-key hs-minor-mode-map (kbd "<C-kp-subtract>")   #'hs-hide-block)
                                        ; `C-c @ C-h' (collapse current fold)
    ;; Folding / Expand All.
    (define-key hs-minor-mode-map (kbd "<C-S-kp-add>")      #'hs-show-all)
                                        ; `C-c @ C-M-s' (expand all folds)
    ;; Folding / Collapse All.
    (define-key hs-minor-mode-map (kbd "<C-S-kp-subtract>") #'hs-hide-all)
                                        ; `C-c @ C-M-h' (collapse all folds)

    (defcustom hs-face 'hs-face
      "*Specify the face to to use for the hidden region indicator"
      :type 'face
      :group 'hideshow)

    (defface hs-face
      '((t :box "#777777" :foreground "#9A9A6A" :background "#F3F349"))
      "Face to hightlight the \"...\" area of hidden regions"
      :group 'hideshow)

    (defun hs-display-code-line-counts (ov)
      (when (eq 'code (overlay-get ov 'hs))
        (overlay-put ov 'display (propertize "..." 'face 'hs-face))))

    (setq hs-set-up-overlay 'hs-display-code-line-counts)

    ;; ;; Hide all top level blocks.
    ;; (add-hook 'find-file-hook #'hs-hide-all)
)
#+end_src

** Completion for Symbol Names
:PROPERTIES:
:ID:       4b262301-5370-40c6-8da6-019215634e20
:END:

#+begin_src emacs-lisp
;;** 26.8 (info "(emacs)Symbol Completion")

  (leuven--section "26.8 (emacs)Symbol Completion")
#+end_src

It's more or less a convention that each language mode binds its symbol
completion command (~completion-at-point~) to ~<M-tab>~.

#+begin_note
If Semantic mode is enabled, it tries to use the *Semantic parser data* for
completion.

If Semantic mode is not enabled or fails at performing completion, it tries to
complete using the *selected tags table*.

If in Emacs Lisp mode, it performs completion using the function, variable, or
property names defined in the current Emacs session.
#+end_note

Note that ~<M-tab>~ is used by many window managers themselves (typically for
switching between windows) and is not passed to applications.

In that case, you should:

- type ~ESC TAB~ or ~C-M-i~ for completion, or

- bind the command normally bound to ~<M-tab>~ to a key that is convenient for
  you to hit, such as ~<C-tab>~.

#+begin_src emacs-lisp :tangle no
  ;; When you hit `<C-tab>', call the command normally bound to `<M-tab>'.
  (global-set-key (kbd "<C-tab>")
    #'(lambda ()
        (interactive)
        (call-interactively (key-binding (kbd "<M-tab>")))))
#+end_src

See also [[id:0fa23e4a-e42c-4317-834c-d2ef7c9d741c][Dabbrev]], Emacs' standard autocompletion (on by default).

** Glasses minor mode

Add overlays to use a different face for the capital letters in symbols like
~CamelCaseUnreadableSymbol~, to make them easier to read.

#+begin_src emacs-lisp
;;** 26.9 (info "(emacs)Glasses") minor mode

  (leuven--section "26.9 (emacs)Glasses minor mode")

  (add-hook 'ess-mode-hook          #'glasses-mode)
  (add-hook 'inferior-ess-mode-hook #'glasses-mode)
  (add-hook 'java-mode-hook         #'glasses-mode)

  (with-eval-after-load "glasses"

    ;; String to be displayed as a visual separator in unreadable identifiers.
    (setq glasses-separator "")

    ;; No display change.
    (setq glasses-original-separator "")

    ;; Face to be put on capitals of an identifier looked through glasses.
    (make-face 'leuven-glasses-face)
    (set-face-attribute 'leuven-glasses-face nil :weight 'bold)
    (setq glasses-face 'leuven-glasses-face)
                                        ; Avoid the black foreground set in
                                        ; `emacs-leuven-theme' to face `bold'.

    ;; Set properties of glasses overlays.
    (glasses-set-overlay-properties)

    ;; No space between an identifier and an opening parenthesis.
    (setq glasses-separate-parentheses-p nil))
#+end_src

subword-mode : M-f/M-b in ~CamelCaseUnreadableSymbol~.

** C and related modes

*** Eclim

[[http://eclim.org/][Eclim]] provides the ability to *bring [[http://www.eclipse.org/][Eclipse]] code editing features* (to Vim, but
also to other editors thanks to third party clients):

- "true" *code completion* (i.e., only context-sensitive completions),
- *code validation* (report any validation errors found),
- searching for declarations or references, and
- [[http://eclim.org/features.html][many more]].

The initial goal was to provide Eclipse *Java* functionality, but support for
various other languages (*C/C++*, HTML/CSS, Groovy, JavaScript, *PHP*, *Python*, *Ruby*,
XML/DTD/XSD, etc.) has been added.

See https://github.com/senny/emacs-eclim/issues/178.

**** Download / install

1. Install [[http://www.eclipse.org/downloads/][Eclipse]].
2. Install [[http://eclim.org/install.html][Eclim]] (see ~vim.skip~ and ~vim.skip.hint~).
3. Install [[https://github.com/senny/emacs-eclim][Emacs-eclim]] from MELPA.

**** Getting started

You should *create an Eclipse project first*, and then you can create a Java file
and open it in Emacs.  Open plain Java file without creating an Eclipse project
will not work.

#+begin_note
"Could not find eclipse project for <file>.java"?  Are you using *Cygwin Emacs*
with a Windows Java installation?  ~/cygdrive~ paths won't be understood...
#+end_note

**** The Eclim daemon

Eclimd (Eclim's daemon) can run without a graphical Eclipse, but you can also
run it from plain Eclipse.  So whenever you need some eclipse's functionalities
that aren't (yet) supported by either ~emacs-eclim~ or ~eclim~, you can switch to it
(e.g. the debugger or the profiler).

**** [[http://eclim.org/faq.html][FAQ / Troubleshooting]]

To tell eclim *which Eclipse workspace to use*, you can start eclimd like so:

#+begin_src shell :tangle no
eclimd -Dosgi.instance.area.default=@user.home/another_workspace
#+end_src

**** Core functionality

- ~M-x eclim-project-build~ ::
     Triggers a *build* of *the current project*.

- M-x eclim-run-class ::
     *Run the current class*.

- ~C-c C-e t~ (or ~M-x eclim-run-junit~) ::
     *Run* the current *JUnit* class or method at point.

Browsing:

- C-c C-e h (M-x eclim-java-hierarchy) ::
     Class hierarchy tree.

- C-c C-e f t (M-x eclim-java-find-type) ::
     Types.

- ~C-c C-e f d~ (~M-x eclim-java-find-declaration~ or ~M-.~ in Emacs-Leuven) ::
     *Find* and display the *declaration* of the *Java identifier at point*.

- ~C-c C-e f r~ (~M-x eclim-java-find-references~) ::
     *Find* and display *references* for the *Java identifier at point*
     = list callers.
     = Find Usages?

Problems and Errors:

- ~C-c C-e b~ (~M-x eclim-problems~) ::
     *Show current compilation problems* in a separate window.

- ~C-c C-e o~ (~M-x eclim-problems-open~) ::
     Opens a new window inside the current frame showing the current project
     *compilation problems*.

Projects:

- ~C-c C-e p c~ (~M-x eclim-project-create~) ::
     Not documented.

- ~M-x eclim-manage-projects~ ::
     *Manage all your eclim projects* in one buffer.

#+begin_src emacs-lisp
  ;; An interface to the Eclipse IDE.
  (with-eval-after-load "emacs-eclim-autoloads-XXX"

    ;; Enable Eclim mode in Java.
    (add-hook 'java-mode-hook #'eclim-mode))

  (with-eval-after-load "eclim"

    ;; Find Eclim installation.
    (setq eclim-executable
          (or (executable-find "eclim")
              (concat leuven--windows-program-files-dir "eclipse/eclim.bat")))
    ;; (setq eclim-executable "C:/PROGRA~2/eclipse/eclim.bat")
    ;; (setq eclim-executable "C:/Users/Fabrice/Downloads/eclipse/eclim.bat")

    ;; (add-to-list 'eclim-eclipse-dirs
    ;;              (concat leuven--windows-program-files-dir "eclipse/eclim"))

    ;; Print debug messages.
    (setq eclim-print-debug-messages t)

    ;; Add key binding.
    (define-key eclim-mode-map (kbd "M-.") #'eclim-java-find-declaration)
#+end_src

#+begin_src emacs-lisp
    ;; Display compilation error messages in the echo area.
    (setq help-at-pt-display-when-idle t)
    (setq help-at-pt-timer-delay 0.1)
    (help-at-pt-set-timer)
#+end_src

#+begin_src emacs-lisp
    ;; Add the emacs-eclim source.
    (require 'ac-emacs-eclim-source)

    ;;! Limit `ac-sources' to Eclim source.
    (defun ac-emacs-eclim-java-setup ()
      (setq ac-sources '(ac-source-emacs-eclim)))
   ;; (setq ac-sources (delete 'ac-source-words-in-same-mode-buffers ac-sources))

    (ac-emacs-eclim-config)
#+end_src

https://github.com/senny/emacs-eclim/wiki/Code-Completion

#+begin_note
There are 2 Eclim Company-mode backends:
- ~company-eclim~, the built-in one.
- ~company-emacs-eclim~, which is a bit more feature-rich (it uses YASnippet, for
  instance), and also a bit buggier.
#+end_note

See http://java-coders.com/p/tsdh/emacs-eclim for Company.

#+begin_src emacs-lisp
    ;; Configure company-mode.
    (require 'company-emacs-eclim)
    (company-emacs-eclim-setup)
#+end_src

#+begin_src emacs-lisp
    ;; Control the Eclim daemon from Emacs.
    (require 'eclimd)

    )
#+end_src

** Java

** JavaScript

*** JS2-mode

The default *indentation* style for ~switch case~ is preferred and quite popular
among JS developers.

- Crockford's style also goes with this.
  http://javascript.crockford.com/code.html

- JavaScript
  https://github.com/bengourley/js-style-guide (so it's not only Crockford)

- Java
  http://www.oracle.com/technetwork/java/javase/documentation/codeconventions-142311.html#468

Config examples:
- https://github.com/cjohansen/.emacs.d/blob/98ddde2a17b1d0c6181891561bc01aaf570376ae/setup-js2-mode.el

Vido:
- [[https://www.youtube.com/watch?v=dbxoo-qEmcg][Some stuff you can do in Emacs in JavaScript]]

Key bindings:

- ~M-.~ (~js2-jump-to-definition~) ::
     Jump to the definition of an object's property, variable or function.

- M-, ::
     Pop back to where ~M-x xref-find-definitions~ was last invoked.

#+begin_src emacs-lisp
  (with-eval-after-load "js2-mode-autoloads"

    (add-to-list 'auto-mode-alist '("\\.js\\'\\|\\.json\\'" . js2-mode)))
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load "js2-mode"

    ;; Add highlighting of many ECMA built-in functions.
    (setq js2-highlight-level 3)

    ;; Delay in secs before re-parsing after user makes changes.
    (setq-default js2-idle-timer-delay 0.1)

    ;; `js2-line-break' in mid-string will make it a string concatenation.
    ;; The '+' will be inserted at the end of the line.
    (setq js2-concat-multiline-strings 'eol)

    ;; (setq js2-mode-show-parse-errors nil)

    ;; Don't emit Ecma strict-mode warnings.
    (setq js2-mode-show-strict-warnings nil)

    ;; Let Flycheck handle parse errors.
    (setq js2-strict-missing-semi-warning nil)

    ;; ;; List of any extern names you'd like to consider always declared.
    ;; (setq js2-global-externs '("View")) ; ARCHIBUS.

    ;; Treat unused function arguments like declared-but-unused variables.
    (setq js2-warn-about-unused-function-arguments t)

    ;; Augment the default indent-line behavior with cycling among several
    ;; computed alternatives.
    (setq js2-bounce-indent-p t)
#+end_src

*** JS2-refactor

The ~js2-refactor~ mode should start with ~C-c C-m~ (that is, ~C-c RET~) and then
a two-letter mnemonic shortcut.

List of available *refactorings*:

- lt (log-this) ::
     *Adds a console.log()* statement for what is at point (or region).

- ~rv~ (~rename-var~) ::
     *Renames* the *variable* on point and all occurrences in its lexical scope.

- ~ev~ (~extract-var~) ::
     Takes a *marked expression* and replaces it with a *var*.

- ~ip~ (~introduce-parameter~) ::
     Changes the *marked expression* to a *parameter* in a local function.

- ~ef~ (~extract-function~) ::
     *Extracts* the marked expressions out into a new named *function*.

- ~em~ (~extract-method~) ::
     *Extracts* the marked expressions out into a new named *method* in an object
     literal.

- ~vt~ (~var-to-this~) ::
     Changes *local ~var* a~ to be ~this.a~ (*instance variable*) instead.

- ~lp~ (~localize-parameter~) ::
     Changes a parameter to a local var in a local function.

- ~eo~ (~expand-object~) ::
     Converts a one line object literal to multiline.

- ~co~ (~contract-object~) ::
     Converts a multiline object literal to one line.

- ~eu~ (~expand-function~) ::
     Converts a one line function to multiline (expecting semicolons as
     statement delimiters).

- ~cu~ (~contract-function~) ::
     Converts a multiline function to one line (expecting semicolons as
     statement delimiters).

- ~ea~ (~expand-array~) ::
     Converts a one line array to multiline.

- ~ca~ (~contract-array~) ::
     Converts a multiline array to one line.

- ~wi~ (~wrap-buffer-in-iife~) ::
     Wraps the entire buffer in an immediately invoked function expression.

- ~ig~ (~inject-global-in-iife~) ::
     Creates a shortcut for a marked global by injecting it in the wrapping
     immediately invoked function expression.

- ~ag~ (~add-to-globals-annotation~) ::
     Creates a ~/*global */~ annotation if it is missing, and adds the var at
     point to it.

- ~iv~ (~inline-var~) ::
     Replaces all instances of a variable with its initial value.

- ~ao~ (~arguments-to-object~) ::
     Replaces arguments to a function call with an object literal of named
     arguments.  Requires YASnippet.

- ~3i~ (~ternary-to-if~) ::
     Converts ternary operator to if-statement.

- ~sv~ (~split-var-declaration~) ::
     Splits a ~var~ with multiple vars declared, into several ~var~ statements.

- ~uw~ (~unwrap~) ::
     Replaces the parent statement with the selected region.

#+begin_src emacs-lisp
  (with-eval-after-load "js2-refactor-autoloads"
    (add-hook 'js2-mode-hook #'js2-refactor-mode)

    (js2r-add-keybindings-with-prefix "C-c C-m") ; eg. extract variable with
                                                 ; `C-c C-m ev`.
    )
)
#+end_src

*** Xref-js2

#+begin_src emacs-lisp
;; Xref-js2
#+end_src

*** Imenu

http://emacs.stackexchange.com/questions/2658/how-to-display-the-list-of-functions-in-imenu-and-collapse-uncollapse-functions
NOTE -- Solution 2 refers to (better) outlining support!!

See ARCHIBUS Controller spec at
http://www.archibus.com/ai/abizfiles/v19.2_help/system-management/Content/wc_views/Adv_Views_Techniques/using_js_to_extend_views/Basic_controller_programming.htm.

#+begin_src emacs-lisp
  ;; Below regex list could be used in both js-mode and js2-mode.
  (setq javascript-common-imenu-regex-list
        ;; Items are in reverse order because they are rendered in reverse.
        `(("Function"                        "^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*:[ \t]*function[ \t]*(" 1)

          ("Auto-Wiring Panel Event _after"  "^[ \t]*.*_after\\([a-zA-Z0-9_$.]+\\)[ \t]*:[ \t]*function[ \t]*(" 1)
          ("Auto-Wiring Panel Event _on"     "^[ \t]*.*_on\\([a-zA-Z0-9_$.]+\\)[ \t]*:[ \t]*function[ \t]*(" 1)
          ("Auto-Wiring Panel Event _before" "^[ \t]*.*_before\\([a-zA-Z0-9_$.]+\\)[ \t]*:[ \t]*function[ \t]*(" 1)

          ("Auto-Wiring View Event 1"        "^[ \t]*\\(afterInitialDataFetch\\)[ \t]*:[ \t]*function[ \t]*(" 1)
          ("Auto-Wiring View Event 0"        "^[ \t]*\\(afterViewLoad\\)[ \t]*:[ \t]*function[ \t]*(" 1)

          ("Variable"                        "^[ \t]*\\([a-zA-Z_.]+\\): [^f]" 1)

          ("Controller Extension"            "var[ \t]*\\([^ \t]+\\)[ \t]*= View.extendController(" 1)
          ("Controller Extension"            "var[ \t]*\\([^ \t]+\\)[ \t]*= .*[cC]ontroller.*extend(" 1)
          ("Controller"                      "var[ \t]*\\([^ \t]+\\)[ \t]*= View.createController(" 1)
          ))
#+end_src

See http://blog.binchen.org/posts/why-emacs-is-better-editor-part-two.html:

#+begin_src emacs-lisp
;; {{ Patching Imenu in js2-mode
(setq js2-imenu-extra-generic-expression javascript-common-imenu-regex-list)

(defvar js2-imenu-original-item-lines nil
  "List of line information of original Imenu items.")

(defun js2-imenu--get-line-start-end (pos)
  (let (b e)
    (save-excursion
      (goto-char pos)
      (setq b (line-beginning-position))
      (setq e (line-end-position)))
    (list b e)))

(defun js2-imenu--get-pos (item)
  (let (val)
    (cond
     ((integerp item)
      (setq val item))

     ((markerp item)
      (setq val (marker-position item))))

    val))

(defun js2-imenu--get-extra-item-pos (item)
  (let (val)
    (cond
     ((integerp item)
      (setq val item))

     ((markerp item)
      (setq val (marker-position item)))

     ;; plist
     ((and (listp item) (listp (cdr item)))
      (setq val (js2-imenu--get-extra-item-pos (cadr item))))

     ;; alist
     ((and (listp item) (not (listp (cdr item))))
      (setq val (js2-imenu--get-extra-item-pos (cdr item)))))

    val))

(defun js2-imenu--extract-line-info (item)
  "Recursively parse the original imenu items created by js2-mode.
The line numbers of items will be extracted."
  (let (val)
    (if item
      (cond
       ;; Marker or line number
       ((setq val (js2-imenu--get-pos item))
        (push (js2-imenu--get-line-start-end val)
              js2-imenu-original-item-lines))

       ;; The item is Alist, example: (hello . 163)
       ((and (listp item) (not (listp (cdr item))))
        (setq val (js2-imenu--get-pos (cdr item)))
        (if val (push (js2-imenu--get-line-start-end val)
                      js2-imenu-original-item-lines)))

       ;; The item is a Plist
       ((and (listp item) (listp (cdr item)))
        (js2-imenu--extract-line-info (cadr item))
        (js2-imenu--extract-line-info (cdr item)))

       ;;Error handling
       (t (message "[Impossible to here! item=%s]" item)
          )))
    ))

(defun js2-imenu--item-exist (pos lines)
  "Try to detect does POS belong to some LINE"
  (let (rlt)
    (dolist (line lines)
      (if (and (< pos (cadr line)) (>= pos (car line)))
          (setq rlt t)))
    rlt))

(defun js2-imenu--is-item-already-created (item)
  (unless (js2-imenu--item-exist
           (js2-imenu--get-extra-item-pos item)
           js2-imenu-original-item-lines)
    item))

(defun js2-imenu--check-single-item (r)
  (cond
   ((and (listp (cdr r)))
    (let (new-types)
      (setq new-types
            (delq nil (mapcar 'js2-imenu--is-item-already-created (cdr r))))
      (if new-types (setcdr r (delq nil new-types))
        (setq r nil))))
   (t (if (js2-imenu--item-exist (js2-imenu--get-extra-item-pos r)
                                 js2-imenu-original-item-lines)
          (setq r nil))))
  r)

(defun js2-imenu--remove-duplicate-items (extra-rlt)
  (delq nil (mapcar 'js2-imenu--check-single-item extra-rlt)))

(defun js2-imenu--merge-imenu-items (rlt extra-rlt)
  "RLT contains imenu items created from AST.
EXTRA-RLT contains items parsed with simple regex.
Merge RLT and EXTRA-RLT, items in RLT has *higher* priority."
  ;; Clear the lines.
  (set (make-variable-buffer-local 'js2-imenu-original-item-lines) nil)
  ;; Analyze the original imenu items created from AST,
  ;; I only care about line number.
  (dolist (item rlt)
    (js2-imenu--extract-line-info item))

  ;; @see https://gist.github.com/redguardtoo/558ea0133daa72010b73#file-hello-js
  ;; EXTRA-RLT sample:
  ;; ((function ("hello" . #<marker 63>) ("bye" . #<marker 128>))
  ;;  (controller ("MyController" . #<marker 128))
  ;;  (hellworld . #<marker 161>))
  (setq extra-rlt (js2-imenu--remove-duplicate-items extra-rlt))
  (append rlt extra-rlt))

(eval-after-load 'js2-mode
  '(progn
     (defadvice js2-mode-create-imenu-index (around leuven-js2-mode-create-imenu-index activate)
       (let (rlt extra-rlt)
         ad-do-it
         (setq extra-rlt
               (save-excursion
                 (imenu--generic-function js2-imenu-extra-generic-expression)))
         (setq ad-return-value (js2-imenu--merge-imenu-items ad-return-value extra-rlt))
         ad-return-value))))
;; }}
#+end_src

#+begin_src emacs-lisp :tangle no
  (defun leuven--archibus-js-imenu-make-index ()
    (save-excursion
      (imenu--generic-function leuven-archibus-javascript-common-imenu-regex-list)))
#+end_src

#+begin_src emacs-lisp :tangle no
    ;; Imenu support for frameworks and structural patterns.
    (js2-imenu-extras-setup)
#+end_src

#+begin_src emacs-lisp
    (defun js2-imenu-record-object-clone-extend ()
      (let* ((node (js2-node-at-point (1- (point)))))
      (when (js2-call-node-p node)
        (let* ((args (js2-call-node-args node))
               (methods (second args))
               (super-class (first args))
               (parent (js2-node-parent node)))
          (when (js2-object-node-p methods)
            (let ((subject (cond ((js2-var-init-node-p parent)
                                  (js2-var-init-node-target parent))
                                 ((js2-assign-node-p parent)
                                  (js2-assign-node-left parent)))))
              (when subject
                (js2-record-object-literal methods
                                           (js2-compute-nested-prop-get subject)
                                           (js2-node-abs-pos methods)))))))))
#+end_src

*** Others

Highlight every variable in its own, consistent color -- "semantic highlighting"
or "hashed highlighting" (in
http://www.wilfred.me.uk/blog/2014/09/27/the-definitive-guide-to-syntax-highlighting/).

#+begin_src emacs-lisp
    ;; Color identifiers based on their names.
    (with-eval-after-load "color-identifiers-mode-autoloads"
      (add-hook 'js2-mode-hook 'color-identifiers-mode))
#+end_src

#+begin_src emacs-lisp
    ;; JS-comint.
    ;; (define-key js2-mode-map (kbd "C-c b")   #'js-send-buffer)
    ;; (define-key js2-mode-map (kbd "C-c C-b") #'js-send-buffer-and-go)
#+end_src

#+begin_src emacs-lisp :tangle no
    ;; ;; js2-mode steals TAB, let's steal it back for yasnippet
    ;; (defun js2-tab-properly ()
    ;;   (interactive)
    ;;   (let ((yas-fallback-behavior 'return-nil))
    ;;     (unless (yas-expand)
    ;;       (indent-for-tab-command)
    ;;       (if (looking-back "^\s*")
    ;;           (back-to-indentation)))))
    ;;
    ;; (define-key js2-mode-map (kbd "TAB") #'js2-tab-properly)
#+end_src

There are 4 popular JavaScript Linting tools:

1. JSLint (the oldest),
2. JSHint,
3. JSCS and
4. ESLint.

We prefer ~eslint~ over ~jshint~.

Install Node and ~npm~ (the package manager for JavaScript):
- Install https://nodejs.org/en/download/.
- Run ~node -v~ (to see if ~node~ is correctly installed).
- Type ~npm~ at the command prompt.
- Run ~npm -v~ (to see if ~npm~ is correctly installed).

Install ESLint (globally) using ~npm~:
- Type ~npm install -g eslint~.
- Type ~eslint -v~ at the command prompt (to view version and confirm that it's
  in your ~PATH~).
- Set up a configuration file with ~eslint --init~.

#+begin_src emacs-lisp

;; Disable JSHint since we prefer ESLint checking.
(with-eval-after-load "flycheck"

  ;; (setq-default flycheck-disabled-checkers
  ;;               (append flycheck-disabled-checkers
  ;;                       '(javascript-jshint)))

  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-eslint)))

  ;; ;; use eslint with web-mode for jsx files
  ;; (flycheck-add-mode 'javascript-eslint 'web-mode)

    ;; (add-hook 'js2-mode-hook
    ;;           #'(lambda () (flycheck-select-checker "javascript-eslint")))

  (add-hook 'js2-mode-hook
            (defun leuven--js2-mode-setup ()
              (flycheck-mode t)
              ;; (when (executable-find "eslint")
              ;;   (flycheck-select-checker 'javascript-eslint))
              ))

  ;; (setq flycheck-display-errors-function
  ;;       'flycheck-display-error-messages-unless-error-list)
  ;;
  ;; ;; (setq flycheck-standard-error-navigation nil)
  ;;
  ;; (setq flycheck-global-modes '(not erc-mode
  ;;                                   message-mode
  ;;                                   git-commit-mode
  ;;                                   view-mode
  ;;                                   outline-mode
  ;;                                   text-mode
  ;;                                   org-mode))
  )
#+end_src

#+begin_src emacs-lisp
    ;; (define-key js2-mode-map (kbd "C-c d") #'my/insert-or-flush-debug)

    (defvar my/debug-counter 1)
    (defun my/insert-or-flush-debug (&optional reset beg end)
      (interactive "pr")
      (cond
       ((= reset 4)
        (save-excursion
          (flush-lines "console.log('DEBUG: [0-9]+" (point-min) (point-max))
          (setq my/debug-counter 1)))
       ((region-active-p)
        (save-excursion
          (goto-char end)
          (insert ");\n")
          (goto-char beg)
          (insert (format "console.log('DEBUG: %d', " my/debug-counter))
          (setq my/debug-counter (1+ my/debug-counter))
          (js2-indent-line)))
       (t
        ;; Wrap the region in the debug.
        (insert (format "console.log('DEBUG: %d');\n" my/debug-counter))
        (setq my/debug-counter (1+ my/debug-counter))
        (backward-char 3)
        (js2-indent-line))))
#+end_src

#+begin_src emacs-lisp
;;   (setup "jquery-doc"
;;     (setup-hook 'js-mode-hook 'jquery-doc-setup)
;;     (setup-after "popwin"
;;       (push '("^\\*jQuery doc" :regexp t) popwin:special-display-config))
;;     (setup-keybinds js-mode-map
;;       "<f1> s" 'jquery-doc)))
#+end_src

*** Tern

Tern is a stand-alone *code analyzer* for JavaScript.  Features provided are:

- *Auto-completion* on variables and properties.
- When the point is in a *function argument* list, show *argument names and types*
  at the bottom of the screen.
- *Find type* of an expression.
- *Jump to definition* of something.
- Automatic *refactoring* (*rename variable*).

The following additional keys are bound:

- M-. ::
     *Jump to* the *definition* of the thing under the cursor.

- M-, ::
     Brings you back to last place you were when you pressed ~M-.~.

- C-c C-r ::
     Rename the variable under the cursor.

- C-c C-c ::
     Find the type of the thing under the cursor.

- C-c C-d ::
     Find docs of the thing under the cursor.  Press again to open the
     associated URL (if any).

#+begin_src emacs-lisp
    (when (executable-find "tern")
      (add-hook 'js-mode-hook  #'tern-mode)
      (add-hook 'js2-mode-hook #'tern-mode)
      (add-hook 'web-mode-hook #'tern-mode))
#+end_src

*** Skewer: live web development with Emacs

Skewer lets you send HTML, CSS, and JavaScript fragments to a browser.

See [[https://www.youtube.com/watch?v=4tyTgyzUJqM][Skewer -- Emacs browser interaction]].

#+begin_tip
You may need to start Chrome with ~chrome --allow-running-insecure-content~, if
you're using the user script with HTTPS sites.
#+end_tip

Kick things off with ~run-skewer~, and then:

- ~C-x C-e~ (~skewer-eval-last-expression~) ::
     *Evaluate the form before the point* and display the result in the
     minibuffer.  If given a prefix argument, insert the result into the current
     buffer.

- ~C-M-x~ (~skewer-eval-defun~) ::
     *Evaluate the top-level form around the point*.

- ~C-c C-k~ (~skewer-load-buffer~) ::
     *Load the current buffer.*

- ~C-c C-z~ (~skewer-repl~) ::
     *Select the REPL buffer*.

#+begin_src emacs-lisp
;; (require 'css-mode)
;; (define-key css-mode-map (kbd "C-c i") #'emr-css-toggle-important)
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load "skewer-mode-autoloads-XXX" ; Not using it yet.
    (add-hook 'js2-mode-hook 'skewer-mode)
    (add-hook 'css-mode-hook 'skewer-css-mode)
    (add-hook 'html-mode-hook 'skewer-html-mode))
#+end_src

To ensure that everything is working correctly:

1. Open a new buffer with the name =myskewer.js=.
2. Enable ~JS2-mode~ (a dependency of skewer).
3. Enable ~skewer-mode~.
4. ~M-x run-skewer~ (a browser opens, go back to =myskewer.js=).
5. Type ~alert("hello");~ and hit ~C-x C-e~ at the end of that line.
6. Go back to the browser.

You should see an alert box on the page.

To tell Skewer to load the HTML (as shown in the demo), place your downloaded
files into =~/public_html= then follow the instructions for [[https://github.com/skeeto/skewer-mode#manual-version][Manual version]]. Once
that is done, visit ~localhost:8080~ in your browser.

** SQL

Working with SQL databases.

- C-c C-b (M-x sql-send-buffer) ::

- C-c C-c (M-x sql-send-paragraph) ::

- C-c C-r (M-x sql-send-region) ::

- C-c C-n (M-x sql-send-line-and-next) ::
     Send the current line to the SQL process and advances to the next line,
     skipping whitespace and comments.

- C-c C-s (M-x sql-send-string) ::

- C-c C-l a (M-x sql-list-all) ::

- C-c C-l t (M-x sql-list-table) ::

- C-c C-i (M-x sql-product-interactive) ::
     Start SQLi session.

- C-c C-z (M-x sql-show-sqli-buffer) ::
     Show the current SQLi buffer.

Server list.

#+begin_src emacs-lisp
  (require 'sql)

  (setq sql-connection-alist
        '((localhost_HQ     (sql-product  'ms)
                            (sql-port     1433)
                            (sql-server   "localhost")
                            (sql-user     "afm")
                            (sql-password "afm")
                            (sql-database "ARCHIBUS_23_1_HQ"))

          (localhost_Schema (sql-product  'ms)
                            (sql-port     1433)
                            (sql-server   "localhost")
                            (sql-user     "afm")
                            (sql-password "afm")
                            (sql-database "ARCHIBUS_23_1_Schema"))

          (localhost_PFlow  (sql-product  'ms)
                            (sql-port     1433)
                            (sql-server   "localhost")
                            (sql-user     "")
                            (sql-password "")
                            (sql-database "PFlowXiphias"))

          (localhost_CSPO   (sql-product  'oracle)
                            (sql-port     1521)
                            (sql-server   "localhost")
                            (sql-user     "afm")
                            (sql-password "AFM")
                            (sql-database "CSPOv213"))))

  (defun sql-localhost_HQ ()
    (interactive)
    (sql-connect-preset 'localhost_HQ))

  (defun sql-localhost_Schema ()
    (interactive)
    (sql-connect-preset 'localhost_Schema))

  (defun sql-localhost_CSPO ()
    (interactive)
    (sql-connect-preset 'localhost_CSPO))

  (defun sql-localhost_PFlow ()
    (interactive)
    (sql-connect-preset 'localhost_PFlow))

  ;; This makes all it all happen via M-x sql-localhost_HQ, etc.
  (defun sql-connect-preset (name)
    "Connect to a predefined SQL connection listed in `sql-connection-alist'"
    (eval `(let ,(cdr (assoc name sql-connection-alist))
             (flet ((sql-get-login (&rest what))) ; In sql.el.
               (sql-product-interactive sql-product)))))
#+end_src

See https://truongtx.me/2014/08/23/setup-emacs-as-an-sql-database-client.

#+begin_src emacs-lisp
  (add-hook 'sql-mode-hook
            #'(lambda ()
                (setq truncate-lines t)
                (sql-highlight-ms-keywords)
                (setq sql-send-terminator t)
                (setq comint-process-echoes t)))

  (add-hook 'sql-interactive-mode-hook
            #'(lambda ()
                (setq truncate-lines t)
                (setq comint-process-echoes t)
                ;; (text-scale-decrease 1)
                (setq-local show-trailing-whitespace nil)))
#+end_src

Basic config for MS SQL.

#+begin_src emacs-lisp
  ;; Default login parameters to connect to Microsoft procSQL Server.
  (setq sql-ms-login-params
        '((user     :default "afm")
          (database :default "ARCHIBUS_23_1_HQ")
          (server   :default "localhost")
          (port     :default 1433)))
#+end_src

#+begin_src emacs-lisp
  (setq sql-ms-program "sqlcmd")

  ;; Force Emacs to use CP 850 for every sqlcmd process (for accents) and
  ;; force DOS line endings.
  (add-to-list 'process-coding-system-alist '("sqlcmd" . cp850-dos))
  (add-to-list 'process-coding-system-alist '("osql" . cp850-dos))

  ;; (setq sql-ms-options '("-w" "65535" "-h" "20000" ))
  (setq sql-ms-options '("-w" "65535"))
#+end_src

#+begin_src emacs-lisp
  (setq sql-ms-program "tsql")

  (setq sql-ms-options (remove "-n" sql-ms-options))
  (setq sql-ms-options nil)

  ;; Redefined.
  (defun sql-comint-ms (product options)
    "Create comint buffer and connect to Microsoft SQL Server."
    ;; Put all parameters to the program (if defined) in a list and call
    ;; make-comint.
    (message "[Leuven Options: %s]" options)
    (let ((params options))
      (if (not (string= "" sql-server))
          (setq params (append (list "-S" sql-server) params)))
      (if (not (string= "" sql-database))
          (setq params (append (list "-D" sql-database) params)))
      (if (not (string= "" sql-user))
          (setq params (append (list "-U" sql-user) params)))
      (if (not (string= "" sql-password))
          (setq params (append (list "-P" sql-password) params))
        (if (string= "" sql-user)
            ;; if neither user nor password is provided, use system credentials.
            (setq params (append (list "-E") params))
          ;; If -P is passed to ISQL as the last argument without a password, it's
          ;; considered null.
          (setq params (append params (list "-P")))))
      (message "[Leuven Params: %s]" params)
      (sql-comint product params)))
#+end_src

Basic config for Oracle.

#+begin_src emacs-lisp
  (add-to-list 'process-coding-system-alist '("sqlplus" . windows-1252))
#+end_src

Have a look at https://www.emacswiki.org/emacs/SqlPlus.

When using sql-send-region to execute a query in a SQLi buffer, the table
formatting is off because the column names are printed on the same row as the
the prompt. By adding a newline before the comint output we can make sure
everything lines up nice. This will add a preceding newline to every comint
output, even queries run at the prompt - though the extra line isn't too
noticeable.

#+begin_src emacs-lisp
  (defvar sql-last-prompt-pos 1
    "position of last prompt when added recording started")
  (make-variable-buffer-local 'sql-last-prompt-pos)
  (put 'sql-last-prompt-pos 'permanent-local t)

  (defun sql-add-newline-first (output)
    "Add newline to beginning of OUTPUT for `comint-preoutput-filter-functions'
    This fixes up the display of queries sent to the inferior buffer
    programatically."
    (let ((begin-of-prompt
           (or (and comint-last-prompt-overlay
                    ;; sometimes this overlay is not on prompt
                    (save-excursion
                      (goto-char (overlay-start comint-last-prompt-overlay))
                      (looking-at-p comint-prompt-regexp)
                      (point)))
               1)))
      (if (> begin-of-prompt sql-last-prompt-pos)
          (progn
            (setq sql-last-prompt-pos begin-of-prompt)
            (concat "\n" output))
        output)))

  (defun sqli-add-hooks ()
    "Add hooks to `sql-interactive-mode-hook'."
    (add-hook 'comint-preoutput-filter-functions
              'sql-add-newline-first))

  (add-hook 'sql-interactive-mode-hook 'sqli-add-hooks)
#+end_src

#+begin_src emacs-lisp :tangle no
;; starting SQL mode loading sql-indent / sql-complete
(eval-after-load "sql"
  '(progn
     (load-library "sql-indent")
     ;; (load-library "sql-complete")
     ;; (load-library "sql-transform")
))
#+end_src

*** Troubleshooting

1. Start with ~ping~:

:  ping myhost

2. Test with ~telnet~:

:  telnet myhost 1433

3. Test with ~tsql~:

:  tsql -H myhost -p 1433 -U sa   # Bypassing `/etc/freetds/freetds.conf'.
:  tsql -S myserver -U sa         # Using `/etc/freetds/freetds.conf'.

   or ~sqsh~:

:  sqsh -S myhost -p 1433 -U sa   # Bypassing `/etc/freetds/freetds.conf'.

You need to write your command like this

#+begin_src sql :tangle no
SELECT * FROM c_props
go
#+end_src

Alternatively, in ~sqsh~, if you set the ~semicolon_hack~ variable (which turns on
the ability to use a semicolon as a sort of in-line go), you can do:

#+begin_src sql :tangle no
SELECT * FROM c_props;
#+end_src

*** Indenting

http://emacs.stackexchange.com/questions/13214/automatically-formatting-sql-code
Emacs does not come anything useful for sql indenting.
The best thing out there is sql-indent.el
Which doesn't do auto-indenting only on command indentation.
I have found it pretty useful at times.

#+begin_src emacs-lisp
  (with-eval-after-load "sql-indent"
    (add-hook 'sql-mode-hook 'sqlind-setup))
#+end_src

*** https://www.emacswiki.org/emacs/SqlBeautify

*** Word case

Automatically convert SQL *keywords to* the *upper case* (see general well-known
[[http://stackoverflow.com/questions/522356/what-sql-coding-standard-do-you-follow][coding standards]] and styles for SQL).

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "sqlup-mode-autoloads"
    (add-hook 'sql-mode-hook 'sqlup-mode)
    (add-hook 'sql-interactive-mode-hook 'sqlup-mode))
#+end_src

*** SQL Remove Square Brackets

#+begin_src emacs-lisp
)                                       ; Chapter 26 ends here.
#+end_src

* Compiling and Testing Programs

#+begin_src emacs-lisp
;;* 27 (info "(emacs)Building") Compiling and Testing Programs

(leuven--chapter leuven-load-chapter-27-building "27 Compiling and Testing Programs"
#+end_src

** Running Compilations under Emacs

My build command: ~cd /path/to/Makefile && make -f Makefile~.

You don't need a =Makefile= to perform simple tasks, because ~make~ knows a lot of
built in rules out of the box.  For example, to compile a ~.c~ source file =foo.c=
into a program ~foo~, all you need is say ~make -k foo~, and ~make~ will do it even
without a =Makefile=.

XXX Compiling with ~ant~?

#+begin_src emacs-lisp
;;** 27.1 Running (info "(emacs)Compilation")s under Emacs

  (leuven--section "27.1 Running (emacs)Compilations under Emacs")

  ;; Invoke a compiler with the same command as in the last invocation of
  ;; `compile'.
  (autoload 'recompile "compile"
    "Re-compile the program including the current buffer." t)

  (global-set-key (kbd "<f9>") #'recompile)

  ;; Scroll the `*compilation*' buffer window to follow output as it appears.
  (setq compilation-scroll-output t)

  ;; ;; Number of lines in a compilation window.
  ;; (setq compilation-window-height 8)

  ;; Always kill a running compilation process before starting a new one.
  (setq compilation-always-kill t)
#+end_src

Make the compilation window go away -- if there were no compilation errors:

#+begin_src emacs-lisp
  (defun compile-hide-window-if-successful (cur-buffer msg)
    (if (string-match "exited abnormally" msg)
        ;; There were errors.
        (message "[Compilation errors, press C-x ` to visit]")
      ;; No errors, make compilation window go away in 0.5 sec
      (run-at-time 0.5 nil
                   'delete-windows-on cur-buffer)
      (message "[No compilation errors!]")))

  ;; (add-to-list 'compilation-finish-functions #'compile-hide-window-if-successful)
#+end_src

#+begin_src emacs-lisp
  (defun compile-goto-first-error (cur-buffer msg)
    (with-current-buffer cur-buffer
      (goto-char (point-min))
      (compilation-next-error 1)
      (beep)))

  ;; (add-to-list 'compilation-finish-functions #'compile-goto-first-error)
#+end_src

#+begin_src emacs-lisp
  (defun compile-scroll-eob (cur-buffer msg)
    (let ((win (get-buffer-window cur-buffer))
          (current (selected-window)))
      (when win
        (select-window win)
        (with-current-buffer cur-buffer
          (when (> (line-number-at-pos (point-max)) (window-height))
            (goto-char (point-max))
            (recenter (window-height))))
        (select-window current))))

  (add-to-list 'compilation-finish-functions #'compile-scroll-eob)
#+end_src

#+begin_src emacs-lisp
  (defvar make-clean-command "make clean all"
    "*Command used by the `make-clean' function.")

  (defun make-clean (&optional arg)
    "Run a make clean."
    (interactive "P")
    (require 'compile)                  ; Needed for compile-internal.
    (if arg
        (setq make-clean-command
              (read-string "Command: " make-clean-command)))
    (save-some-buffers (not compilation-ask-about-save) nil)
    (compile-internal make-clean-command "No more errors"))

  (global-set-key (kbd "<S-f9>") #'make-clean)
#+end_src

You're debugging Bash code?  I normally use =mode-compile.el= for this.
Basically, it runs Bash with lots of debug output.

*** Java

Compile within Emacs using ~ant~.

#+begin_src emacs-lisp
  (defvar leuven--ant-command-history nil
    "Ant command history variable")

  (defun leuven-ant (&optional args)
    "Runs ant in the current project. Starting at the directory
     where the file being visited resides, a search is made for
     build.xml recursively. A maven command is made from the first
     directory where the build.xml file is found is then displayed in
     the minibuffer. The command can be edited as needed and then
     executed. Errors are navigate to as in any other compile mode"
    (interactive)
    (let ((fn (buffer-file-name)))
      (let ((dir (file-name-directory fn)))
        (while (and (not (file-exists-p (concat dir "/build.xml")))
                    (not (equal dir (file-truename (concat dir "/..")))))
          (setf dir (file-truename (concat dir "/.."))))
        (if (not (file-exists-p (concat dir "/build.xml")))
            (message "[No build.xml found]")
          (compile (read-from-minibuffer "Command: "
                                         (concat "ant -emacs -f "
                                         dir "/build.xml compile") nil
                                         nil
                                         'leuven--ant-command-history))))))

  (add-hook 'java-mode-hook
            #'(lambda ()
                (local-set-key "<f9>" 'leuven-ant)))
#+end_src

See smart-compile.el!

See jdc.el

#+begin_src emacs-lisp
  ;; Use Java for class files decompiled with Jad.
  (add-to-list 'auto-mode-alist '("\\.jad\\'" . java-mode))
#+end_src

#+begin_src emacs-lisp
  ;; Color identifiers based on their names.
  (with-eval-after-load "color-identifiers-mode-autoloads"
    (add-hook 'java-mode-hook 'color-identifiers-mode))
#+end_src

** Compilation Mode

When Emacs visits the locus of an error message, it momentarily highlights the
relevant source line.  The duration of this highlight is determined by the
variable ~next-error-highlight~.

#+begin_src emacs-lisp
;;** 27.2 (info "(emacs)Compilation Mode")

  (leuven--section "27.2 (emacs)Compilation Mode")

  ;; ;; Automatically jump to the first error during compilation.
  ;; (setq compilation-auto-jump-to-first-error t)

  ;; Display the next compiler error message.
  (global-set-key (kbd "<f10>")   #'next-error) ; C-M-down in IntelliJ IDEA.
                                        ; Also on `M-g n', `M-g M-n' and `C-x `'.

  ;; Display the previous compiler error message.
  (global-set-key (kbd "<S-f10>") #'previous-error) ; C-M-up in IntelliJ IDEA.
                                        ; Also on `M-g p' and `M-g M-p'.

  ;; Display the first compiler error message.
  (global-set-key (kbd "<C-f10>") #'first-error)

  ;; ;; Prefer fringe.
  ;; (setq next-error-highlight 'fringe-arrow)

  ;; Highlight and parse the whole compilation output as soon as it arrives.
  (setq compile-auto-highlight t)
#+end_src

** Searching with Grep under Emacs

Find files matching some regexp, and click on the hyperlinks to the files to
locate your match.

The commands

- ~lgrep~ (local search, with ~grep-template~) and
- ~rgrep~ (*recursive* search, with ~grep-find-template~)

are somehow more user-friendly than the ~M-x grep~ command.

The doc string of ~grep-use-null-device~ which explains that, with its default
value ~auto-detect~, Emacs invokes Grep once with ~/dev/null~ appended (causing the
search to return no results) for the purposes of detecting how to invoke it
thereafter.

#+begin_src emacs-lisp
;;** 27.4 (info "(emacs)Grep Searching") under Emacs

  (leuven--section "27.4 (emacs)Grep Searching under Emacs")

  (with-eval-after-load "grep"

    ;; Run `grep' via `find', with user-friendly interface.
    (global-set-key (kbd "C-c 3") #'rgrep)

    ;; Ignore case distinctions in the default `grep' command.
    (grep-apply-setting 'grep-command "grep -i -H -n -e ")

    ;; Do not append `null-device' (`/dev/null' or `NUL') to `grep' commands.
    (grep-apply-setting 'grep-use-null-device nil)
                                        ; Not necessary if the `grep' program
                                        ; used supports the `-H' option.

    ;; For Windows.
    (when leuven--win32-p
      ;; Default find command for `M-x grep-find'.
      (grep-apply-setting 'grep-find-command '("findstr /sn *" . 13)))
#+end_src

To exclude files from ~lgrep~ and ~rgrep~ results (if you use ~rgrep~ instead of
~grep-find~), you can set up ignored files/dirs in advance:

#+begin_src emacs-lisp
  (with-eval-after-load "grep"
    ;; Files to ignore for MEPLA.
    (add-to-list 'grep-find-ignored-files "archive-contents")

    (add-to-list 'grep-find-ignored-files "*-min.js")
    (add-to-list 'grep-find-ignored-files "*.min.js")

    ;; Files to ignore for ARCHIBUS.
    (add-to-list 'grep-find-ignored-files "ab-core.js")
    (add-to-list 'grep-find-ignored-files "ab-pgnav.js")
    (add-to-list 'grep-find-ignored-files "ab-view.js")
    (add-to-list 'grep-find-ignored-files "app.js")
    ;; (add-to-list 'grep-find-ignored-files "cordova.js")
    (add-to-list 'grep-find-ignored-files "dx.archibus.js")
    (add-to-list 'grep-find-ignored-files "app.css")
    (add-to-list 'grep-find-ignored-files "sencha-touch.css")

    ;; Directories to ignore for ARCHIBUS.
    (add-to-list 'grep-find-ignored-directories "ckeditor")
    (add-to-list 'grep-find-ignored-directories "common/mobile"))
#+end_src

#+begin_note
~helm-ag~ and ~helm-projectile-grep~ also use the settings of the
~grep-find-ignored-*~ variables.
#+end_note

*** Ripgrep

alias rg='rg --color always'

rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --glob "!.git/*" --color "always"

rg -S --no-heading

helm-ag-base-command "rg --no-heading"

Option ~--sort-files~ sorts results by file path, but disables all parallelism and
runs search in a single thread.

#+begin_src emacs-lisp
    (when (executable-find "rgXXX")        ; ripgrep.

      ;; Default grep command for `M-x grep'.
      ;; (grep-apply-setting 'grep-command "ag --nogroup --numbers ")

      ;; Default command to run for `M-x lgrep'.
      (grep-apply-setting 'grep-template "rg --no-heading -H -uu -g <F> <R> <D>")

      ;; Default find command for `M-x grep-find'.
      ;; (grep-apply-setting 'grep-find-command '("ag --noheading --column " . 25))

      ;; Default command to run for `M-x rgrep'.
      (grep-apply-setting 'grep-find-template
                          "find <D> <X> -type f <F> -exec rg <C> --no-heading -H <R> /dev/null {} +"))
                                        ; `<D>' = path.
                                        ; `<X>' for the find options to restrict
                                        ;       directory list.
                                        ; `<F>' = glob.
                                        ; ------------------------------------
                                        ; `<C>' for the place to put `-i' if the
                                        ;       search is case-insensitive.
                                        ; `<R>' = pattern.
#+end_src

See https://stackoverflow.com/questions/45526670/rgrep-in-emacs-to-use-ripgrep.

Some problems with ripgrep:
- no match highlighting,
- error parsing regex when string is, for example, ~Handler().update~ or ~myFunc(~.

find . -name "*.log" -type f -print0 | xargs -I _ sh -c 'iconv -f utf16 -t utf8 _ | grep runPMGeneration'

*** The Silver Searcher

Ag, the silver searcher (in Cygwin!):
- https://github.com/howardabrams/dot-files/blob/master/emacs.org
- https://www.reddit.com/r/emacs/comments/3fr4ro/how_do_you_grep/

Ag output options:

- ~--[no]color~ ::
     Print *color* codes in results.

- ~--column~ ::
     Print *column numbers* in results.

- ~--[no]heading~ ::

- ~--[no]group~ ::
     Same as ~--[no]break --[no]heading~.

- ~--line-numbers~ (or ~--numbers~) ::
     Print *line numbers* even for streams.

Ag search options:

- ~--depth~ ::
     Search up to *~NUM~ directories deep* (Default: ~25~).

- ~--ignore-case~ ::
     Match *case insensitively*.

- ~--all-text~ ::
     Search *all text files* (doesn't include hidden files).

#+begin_src shell :tangle no
ag %s -l --nocolor --hidden -g ""
#+end_src

#+begin_src emacs-lisp
    ;; Prefer rg > ag.
    (when (and (executable-find "agXXX") ; XXX Need to fix base dir and file extensions!!!
               (not (executable-find "rg")))

      ;; Default grep command for `M-x grep'.
      ;; (grep-apply-setting 'grep-command "ag --nogroup --numbers ")

      ;; Default command to run for `M-x lgrep'.
      ;; (grep-apply-setting 'grep-template "ag --depth 0 <R> <F>")

      ;; Default find command for `M-x grep-find'.
      ;; (grep-apply-setting 'grep-find-command '("ag --noheading --column " . 25))

      ;; Default command to run for `M-x rgrep' (`C-c 3').
      (grep-apply-setting 'grep-find-template
                          "ag --color --nogroup --line-numbers <R> ."))
                                        ; `<D>' for the base directory.
                                        ; `<X>' for the find options to restrict
                                        ;       directory list.
                                        ; `<F>' for the find options to limit
                                        ;       the files matched.
                                        ; ------------------------------------
                                        ; `<C>' for the place to put `-i' if the
                                        ;       search is case-insensitive.
                                        ; `<R>' for the regular expression to
                                        ;       search for.
#+end_src

#+begin_src emacs-lisp :tangle no
      ;; Default command to run for `M-x rgrep' (`C-c 3').
      (grep-apply-setting 'grep-find-template
                          "find <D> <X> -type f <F> -print0 | \"xargs\" -0 grep <C> -nH -e <R>")
#+end_src

#+begin_src emacs-lisp
    ;; This is how compilers number the first column, usually 1 or 0.
    ;; (setq-default grep-first-column 1)

    ;; Use `find -print0' and `xargs -0'.
    (setq grep-find-use-xargs 'gnu))    ; with-eval-after-load "grep" ends here.
#+end_src

#+begin_src emacs-lisp
  ;; Run `grep' via `find', with user-friendly interface.
  (global-set-key (kbd "C-c 3") #'rgrep)
#+end_src

** Finding Syntax Errors On The Fly

Flycheck (aka "Flymake done right") can perform static code analysis *on-the-fly*,
and *highlight warnings and errors* in the code immediately as you are editing it,
if you made a mistake.

To *list all errors in the current buffer*, you can popup an error list with
~C-c ! l~ (~M-x flycheck-list-errors~).

(See https://github.com/steelbrain/linter in Atom.)

In the error list window the following keybindings are available:

- ~n~ ::
     Move to the *next error*.

- ~p~ ::
     Move to the *previous error*.

- ~q~ ::
     Hide the error list window.

- ~RET~ ::
     Jump to the location of the error at point.

- ~g~ ::
     Refresh the error list, by triggering a new syntax check in the associated
     buffer.

- ~S~ ::
     Sort the error list by the column at point. Press repeatedly to inverse the
     sorting order.

#+begin_note
~C-c ! v~ (or ~M-x flycheck-verify-setup~) is a diagnostic tool which displays
diagnostic information about the active checker in your current buffer.  Useful
if you have ~$PATH~ issues or are missing the checker entirely on your system.
#+end_note

XXX Display errors in the right fringe

#+begin_tip
~FlyC-~, in the mode line, either means that there is *no checker* or that it got
interrupted. See ~flycheck-mode-line-status-text~ for more information.
#+end_tip

Navigate:
- Next Highlighted Error (F2)
- Previous Highlighted Error (Shift+F2).

[[http://www.flycheck.org/en/latest/user/error-reports.html][!FlyC: See errors in buffers]]

#+begin_src emacs-lisp
;;** 27.5 (info "(emacs)Flymake")

  (leuven--section "27.5 (emacs)Flymake")

  ;; Modern on-the-fly syntax checking.
  (with-eval-after-load "flycheck-autoloads"

    ;; Enable Flycheck mode in all programming modes. XXX Should not in Java?
    (add-hook 'prog-mode-hook  #'flycheck-mode)

    (add-hook 'LaTeX-mode-hook #'flycheck-mode)

    (global-set-key (kbd "M-g l") #'flycheck-list-errors))

  (with-eval-after-load "flycheck"

    ;; Delay in seconds before displaying errors at point.
    (setq flycheck-display-errors-delay 0.3)

    (setq flycheck-indication-mode 'left-fringe) ; See init.el.
    ;; ;; Indicate errors and warnings via icons in the right fringe.
    (setq flycheck-indication-mode 'right-fringe)

    ;; Remove newline checks, since they would trigger an immediate check when
    ;; we want the `flycheck-idle-change-delay' to be in effect while editing.
    (setq flycheck-check-syntax-automatically
          '(save
            idle-change
            ;; new-line
            mode-enabled))

    ;; Each buffer get its local `flycheck-idle-change-delay' because of the
    ;; buffer-sensitive adjustment above.
    (make-variable-buffer-local 'flycheck-idle-change-delay)

    (defun leuven--adjust-flycheck-automatic-syntax-eagerness ()
      "Adjust how often we check for errors based on if there are any.

This lets us fix any errors as quickly as possible, but in
a clean buffer we're an order of magnitude laxer about checking."
      (setq flycheck-idle-change-delay
            (if (assq 'error (flycheck-count-errors flycheck-current-errors))
                ; only check for REAL errors (original source: Magnar Sveen)
                1
              20)))

    ;; Functions to run after each syntax check.
    (add-hook 'flycheck-after-syntax-check-hook
              #'leuven--adjust-flycheck-automatic-syntax-eagerness)
#+end_src

A summary of the inspection results for the current file is shown in the colored
mode line on bottom.  Make it blue!

#+begin_src emacs-lisp
    ;; Change mode line color with Flycheck status.
    (with-eval-after-load "flycheck-color-mode-line"
      (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode)))
#+end_src

#+begin_src emacs-lisp :tangle no
  ;; Provide an error display function to show errors in a tooltip.
  (with-eval-after-load 'flycheck
    (flycheck-pos-tip-mode)) ; XXX Check if defined.
#+end_src

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-S-e") #'elint-current-buffer)

  (with-eval-after-load "elint"
    (add-to-list 'elint-standard-variables 'current-prefix-arg)
    (add-to-list 'elint-standard-variables 'command-line-args-left)
    (add-to-list 'elint-standard-variables 'buffer-file-coding-system)
    (add-to-list 'elint-standard-variables 'emacs-major-version)
    (add-to-list 'elint-standard-variables 'window-system))
#+end_src

** Running Debuggers Under Emacs

#+begin_src emacs-lisp
;;** 27.6 Running (info "(emacs)Debuggers") Under Emacs

  (leuven--section "27.6 Running (emacs)Debuggers Under Emacs")

  (with-eval-after-load "gdb-mi"

    ;; Enable Gdb-Many-Windows mode.
    (setq gdb-many-windows t))          ; The only important parameter for GDB.
#+end_src

#+begin_src emacs-lisp :tangle no
  (define-key jde-mode-map [f8]   'jdibug-step-over)
  (define-key jde-mode-map [M-f8] 'jdibug-step-into)
  (define-key jde-mode-map [f7]   'jdibug-step-out)
  (define-key jde-mode-map [M-f7] 'jdibug-resume)
#+end_src

Highlight the current GUD line in GDB/Emacs:

#+begin_src emacs-lisp
  (defvar gud-overlay
    (let* ((ov (make-overlay (point-min) (point-min))))
      (overlay-put ov 'face '(:background "#F6FECD"))
                                        ; Color for Leuven theme
                                        ; (highlight-yellow).
      ov)
    "Overlay variable for GUD highlighting.")

  (defadvice gud-display-line (after my-gud-highlight act)
    "Highlight current line."
    (let* ((ov gud-overlay)
           (bf (gud-find-file true-file)))
      (save-excursion
        (set-buffer bf)
        (move-overlay ov (line-beginning-position) (line-end-position)
                      (current-buffer)))))
#+end_src

** Debugging Lisp programs

Emacs has the basic debugger/stack trace, but it also has the Edebug facility,
which is very powerful, for the more complex situation.

With that source-level debugger for Emacs Lisp, you can:
- step through evaluation, stopping before and after each expression,
- set conditional or unconditional breakpoints.

#+begin_src emacs-lisp
;;** Debugging Lisp programs

  ;; Source-level debugger for Emacs Lisp.
  (with-eval-after-load "edebug"

    ;; ;; Display a trace of function entry and exit.
    ;; (setq edebug-trace t)
#+end_src

While ~edebug~'ging, use ~T~ to view a trace buffer (~*edebug-trace*~).  Emacs will
quickly execute the rest of your code, printing out the arguments and return
values for each expression it evaluates.

#+begin_src emacs-lisp
    (defadvice edebug-overlay-arrow (around leuven-highlight-line activate)
      "Highlight line currently being Edebug'ged."
      (require 'hl-line)
      (hl-line-mode)
      ad-do-it)

    (defun leuven-edebug-quit ()
      "Stop Edebug'ging and remove highlighting."
      (interactive)
      (hl-line-mode -1)
      (top-level))

    (define-key edebug-mode-map [remap top-level] #'leuven-edebug-quit))
#+end_src

** Executing Lisp Expressions

Just as in C, C++, Java, Perl, Python, etc, Lisp code is kept in files.  All
the normal editing operations are performed on files.  In this respect, hacking
in Lisp is like hacking in any other language that you are used to.  What's
different is that what you are hacking is a running Lisp program.  When you
edit a function definition or add a new one, you compile it into a running
program.  There is no compile, link, run, debug cycle as you know it from C or
Java.

Ponder that for a minute.

When you fix a bug in a C function, you have to recompile, relink, and reload
your program before you can test the fix.  You don't do that in Lisp.  You make
the fix and then go straight to testing it.  This process can be even faster
than fixing a bug in a scripting language like Perl.

** Libraries of Lisp Code for Emacs

#+begin_src emacs-lisp
;;** 27.8 (info "(emacs)Lisp Libraries") for Emacs

  (leuven--section "27.8 (emacs)Lisp Libraries")

  ;; Remove *.elc when save.
  (defun remove-elc-on-save ()
    "If you're saving an elisp file, likely the .elc is no longer valid."
    (make-local-variable 'after-save-hook)
    (add-hook 'after-save-hook
              #'(lambda ()
                  (if (file-exists-p (concat buffer-file-name "c"))
                      (delete-file (concat buffer-file-name "c"))))))

  (add-hook 'emacs-lisp-mode-hook #'remove-elc-on-save)

  ;; Force load of `.el' files when they are newer than the `.elc' files.
  (setq load-prefer-newer t)            ; From Emacs 24.4.
#+end_src

** Evaluating Emacs Lisp Expressions

- ~C-x C-e~ ::
     Evaluate the Emacs Lisp expression before point, and print the value in
     the echo area (~eval-last-sexp~).

- ~C-M-x~ (in Emacs Lisp mode) ::
     Evaluate the defun containing or after point, and print the value in the
     echo area (~eval-defun~).

To (attempt to) cleanly reevaluate a buffer of Emacs Lisp code, use
~nuke-and-eval~.

#+begin_src emacs-lisp
;;** 27.9 (info "(emacs)Lisp Eval") Expressions

  (leuven--section "27.9 (emacs)Lisp Eval Expressions")

  ;; Enable the use of the command `eval-expression' without confirmation.
  (put 'eval-expression 'disabled nil)

  ;; Maximum depth of lists to print in the result of the evaluation commands
  ;; before abbreviating them.
  (setq eval-expression-print-level nil) ; No limit.

  ;; Maximum length of lists to print in the result of the evaluation commands
  ;; before abbreviating them.
  (setq eval-expression-print-length nil) ; No limit.
#+end_src

#+begin_src emacs-lisp
  ;; ;; Limit serving to catch infinite recursions for you before they
  ;; ;; cause actual stack overflow in C, which would be fatal for Emacs.
  ;; (setq max-lisp-eval-depth 600)        ; 1000?
#+end_src

#+begin_src emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (let ((value (eval (preceding-sexp))))
      (kill-sexp -1)
      (insert (format "%S" value))))

  (global-set-key (kbd "C-c e") #'eval-and-replace)
#+end_src

For on-the-fly evaluation/substitution of Emacs Lisp code, see
https://github.com/Fuco1/litable.

See demo of it: http://www.youtube.com/watch?v=TMoPuv-xXMM.

#+begin_src emacs-lisp
  ;; Dynamic evaluation replacement with Emacs.
  (with-eval-after-load "litable-autoloads"

    (add-hook 'lisp-interaction-mode-hook #'litable-mode))
#+end_src

** Lisp Interaction Buffers (~*scratch*~)

#+begin_src emacs-lisp
;;** 27.10 (info "(emacs)Lisp Interaction") Buffers

  (leuven--section "27.10 (emacs)Lisp Interaction Buffers")

  ;; Don't display the "Welcome to GNU Emacs" buffer on startup.
  (setq inhibit-startup-screen t)

  ;; Don't insert instructions in the `*scratch*' buffer at startup.
  (setq initial-scratch-message nil)
#+end_src

Don't use any specific mode for the initial buffer.  That ensure that no Lisp
or Org specific stuff gets loaded at each startup time.

#+begin_src emacs-lisp
  ;; Major mode command symbol to use for the initial `*scratch*' buffer.
  (setq initial-major-mode 'fundamental-mode)
#+end_src

*That code must be used in the ~.emacs~ file (or libraries loaded from it).*
Otherwise, ~*scratch*~ will already have been created, in the default major
mode.

To evaluate a non-interactive command, simply use ~IELM~.

** Switching to a Buffer in a Window

Emacs's windows are locked in an eternal fight with their user as they fight
over screen estate and what buffer is allowed to be shown where. The concept of
strongly dedicated window is alien to most Emacs users as it's fairly byzantine
to figure out. This variable, which is customizable, will let you decide how
buffer switching works when a window and its buffer are fundamentally
entwined. I recommend you set it to ~prompt~ if you are curious about its effects,
as that will prompt you to decide what to do next -- no doubt annoying in the
long run, but useful for figuring out how Emacs's windowing mechanics work.

#+begin_src emacs-lisp
  (setq switch-to-buffer-in-dedicated-window 'prompt)
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 27 ends here.
#+end_src

* Maintaining Programs

#+begin_src emacs-lisp
;;* 28 (info "(emacs)Maintaining") Programs

(leuven--chapter leuven-load-chapter-28-maintaining "28 Maintaining Programs"
#+end_src

** Version Control

A unified Emacs UI for interacting with Git, SVN and other VCS (Version Control
Systems) in a generic way -- a real timesaver.

- ~C-x v d~ ::
     Open Dired buffer in VC-mode.

- ~C-x v v~ ::
     Take appropriate "next" action (add, commit).

- ~C-x v r~ (or ~M-!~ ?) ::
     Switch Git branches.

- ~C-x v +~ ::
     vc-update.

#+begin_src emacs-lisp
;;** 28.1 (info "(emacs)Version Control")

  (leuven--section "28.1 (emacs)Version Control")

  ;; Always follow symlinks to files under source-control.  Don't ask.
  (setq vc-follow-symlinks t)

  ;; (setq vc-allow-async-revert t)

  ;; (setq vc-git-diff-switches '("-w" "-U3")) ;; XXX What about mnemonicprefix=true?

;; ;; When opening a file that is a symbolic link, don't ask whether I
;; ;; want to follow the link. Just do it
;; (setq find-file-visit-truename t)
#+end_src

*** Version Control and the Mode Line

"Unmodified-according-to-VC" buffers use ~-~ as a separator in their VC
indicator, and modified buffers have ~:~ (e.g., ~CVS-1.2~ vs. ~CVS:1.2~).  The
tooltip over the VC indicator also says more explicitly.

*************** Lisp expression in mode-line-format
The Lisp expressions supported in ~mode-line-format~ are those documented in the
manual, and nothing else.  In particular, the ~:eval~ part must appear
explicitly, and any symbol stands for its value (which is not eval'ed).  IOW, a
full-blown Lisp evaluation there is not implemented...
*************** END

*** Features of the Log Entry Buffer

- ~C-c C-d~ ::
     Show the diff we are about to commit.

- ~D~ (~vc-git-previous-revision~) ::
     Get the previous revision.

Using Emacs VC, you only have to write the ChangeLog, then use ~C-c C-a~ to insert
it into the commit buffer. So there is no need to "write the same thing twice".

#+begin_src emacs-lisp
;;*** 28.1.4 (info "(emacs)Log Buffer")

  (defun leuven--vc-log-mode-setup ()
    (when (leuven--executable-ispell-program-name-p)
      (setq ispell-local-dictionary "american")
      (flyspell-mode)))

  (add-hook 'vc-log-mode-hook #'leuven--vc-log-mode-setup)
#+end_src

#+begin_src emacs-lisp
  (autoload 'vc-git-root "vc-git")
  (with-eval-after-load "vc-git"

    ;; Major mode for editing git commit messages.
    (idle-require 'git-commit))

  (with-eval-after-load "git-commit"

    ;; Turn on on-the-fly spell-checking.
    (add-hook 'git-commit-setup-hook #'flyspell-mode)

    ;; Turn off save-place.
    (add-hook 'git-commit-setup-hook
              #'(lambda ()
                  (toggle-save-place 0))))
#+end_src

See http://whattheemacsd.com/setup-magit.el-01.html.

Or use Tig?  See http://blogs.atlassian.com/2013/05/git-tig/.

*** Examining And Comparing Old Revisions

VC can show you the *history of changes* to a *particular line of code*:

1. Run the command ~vc-annotate~ (with either ~M-x vc-annotate~ or ~C-x v g~).
2. Each line will show up with its *revision*, like a normal ~blame~, and a *heatmap*.

*************** TODO Customize vc-annotate colors to be cold after 90 days
*************** END

3. Pressing ~a~ (~vc-annotate-revision-previous-to-line~) will navigate to the
   revision before the revision at the line you're on.

#+begin_src emacs-lisp
;;*** 28.1.6 (info "(emacs)Old Revisions")

  (leuven--section "28.1.6 Examining And Comparing Old Revisions")

  ;; Switches for diff under VC.
  (setq vc-diff-switches diff-switches)
#+end_src

*** VC Change Log

#+begin_src emacs-lisp
;;*** 28.1.7 (info "(emacs)VC Change Log")

  (leuven--section "28.1.7 VC Change Log")
#+end_src

- ~C-x v l~ ::
     Display the change history for the current *file* (~vc-print-log~).

- ~C-x v L~ ::
     Open the *log buffer* for the current *repository* (List the change log for the
     current VC controlled tree in a window).

     When in it:
     - ~C-m~ to read the commit message,
     - ~d~ to see the corresponding diff.

We have at least two pairs of commands:

- ~C-x v l~ vs ~C-x v L~ /and/
- ~C-x v =~ vs ~C-x v D~,

of which one operates on the current *file* vs \\
the other on the *repository* as a whole (entire project).

- ~C-x v l~ to view the file's history.
- ~n~ and ~p~ to move between commits.
- ~f~ to visit the file as of the commit at point.

The command ~vc-region-history~ shows the *log + diff of the active region*.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x v H") #'vc-region-history)
#+end_src

~git-timemachine~ makes the process of *navigating between different versions* of
a file almost completely seamless.

You call ~M-x git-timemachine RET~ from a buffer visiting a tracked file, then you
can use the following keys to navigate historic versions of the file:

- ~p~ ::
     Visit *previous* historic version.

- ~n~ ::
     Visit *next* historic version.

- ~w~ ::
     Copy the abbreviated hash of the current historic version.

- ~W~ ::
     Copy the full hash of the current historic version.

- ~q~ ::
     Exit the time machine.

#+begin_src emacs-lisp
  ;; Walk through Git revisions of a file.
  (with-eval-after-load "git-timemachine-autoloads"

    ;; Number of chars from the full SHA1 hash to use for abbreviation.
    (setq git-timemachine-abbreviation-length 7)

    (global-set-key (kbd "C-x v t") #'git-timemachine))
#+end_src

#+begin_src emacs-lisp
  ;; Pop up last commit information of current line.
  (with-eval-after-load "git-messenger-autoloads"

    (global-set-key (kbd "C-x v p") #'git-messenger:popup-message) ; `C-h g'.

    ;; Pop up commit ID and author name too.
    (setq git-messenger:show-detail t))
#+end_src

*** VC Directory Mode

#+begin_src emacs-lisp
;;*** 28.1.9 (info "(emacs)VC Directory Mode")

  (leuven--section "28.1.9 VC Directory Mode")

  (defun leuven-vc-jump ()
    "Jump to VC status buffer."
    (interactive)
    (let* ((fname (buffer-file-name))
           (dname (if fname
                      (if (file-directory-p fname)
                          fname
                        (file-name-directory fname))
                    default-directory)))
      (message "[VC status for directory: %s]" dname)
      (vc-dir dname)))

  ;; VC status without asking for a directory.
  (global-set-key (kbd "<C-f9>") #'leuven-vc-jump)

  (add-hook 'vc-dir-mode-hook
            #'(lambda ()
                ;; Hide up-to-date and unregistered files.
                (define-key vc-dir-mode-map
                  (kbd "x") #'leuven-vc-dir-hide-up-to-date-and-unregistered)
                (define-key vc-dir-mode-map
                  (kbd "E") #'vc-ediff)
                (define-key vc-dir-mode-map
                  (kbd "#") #'vc-ediff-ignore-whitespace)
                                        ; ediff-windows-wordwise?
              ))

  (defun leuven-vc-dir-hide-up-to-date-and-unregistered ()
    (interactive)
    (vc-dir-hide-up-to-date)
    (vc-dir-hide-unregistered))

  (defun vc-dir-hide-unregistered ()
    "Hide unregistered items from display."
    (interactive)
    (let ((crt (ewoc-nth vc-ewoc -1))
          (first (ewoc-nth vc-ewoc 0)))
      ;; Go over from the last item to the first and remove the unregistered
      ;; files and directories with no child files.
      (while (not (eq crt first))
        (let* ((data (ewoc-data crt))
               (dir (vc-dir-fileinfo->directory data))
               (next (ewoc-next vc-ewoc crt))
               (prev (ewoc-prev vc-ewoc crt))
               ;; ewoc-delete does not work without this...
               (inhibit-read-only t))
          (when (or
                 ;; Remove directories with no child files.
                 (and dir
                      (or
                       ;; Nothing follows this directory.
                       (not next)
                       ;; Next item is a directory.
                       (vc-dir-fileinfo->directory (ewoc-data next))))
                 ;; Remove files in the unregistered state.
                 (eq (vc-dir-fileinfo->state data) 'unregistered))
            (ewoc-delete vc-ewoc crt))
          (setq crt prev)))))

  (defun vc-ediff-ignore-whitespace (historic &optional not-urgent)
    "Ignore regions that differ in white space & line breaks only."
    (interactive (list current-prefix-arg t))
    (require 'ediff)
    (let ((ediff-ignore-similar-regions t))
      (call-interactively 'vc-ediff)))  ; XXX does not work yet!
#+end_src

*** Branches

- C-x v P (M-x vc-push) ::
     Basic *push* support.

*** Customizing VC

#+begin_src emacs-lisp
;;*** 28.1.13 (info "(emacs)Customizing VC")

  (leuven--section "28.1.13 Customizing VC")

  ;; Files covered by VC get backups (as with other files).
  (setq vc-make-backup-files t)

  ;; http://www.emacswiki.org/emacs/VcTopDirectory
  ;; For Git.
  (defadvice vc-dir-prepare-status-buffer
             (before leuven-vcs-goto-top-directory activate compile)
    (let* ((backend (ad-get-arg 2))
           (vcs-dir (ad-get-arg 1))
           (vcs-top-dir (vc-call-backend backend 'responsible-p vcs-dir)))
      (when (stringp vcs-top-dir)
        (ad-set-arg 1 vcs-top-dir))))

  (defun leuven--ediff-revision (file rev1 &optional rev2)
    "Run Ediff by comparing 'master' against the 'current'."
    (require 'ediff)
    (find-file file)
    (if (and (buffer-modified-p)
             (y-or-n-p (format "Buffer %s is modified.  Save buffer? "
                               (buffer-name))))
        (save-buffer (current-buffer)))
    (ediff-load-version-control)
    (funcall
     (intern (format "ediff-%S-internal" ediff-version-control-package))
     rev1 rev2 nil))

  (defun leuven-vc-diff (&optional arg)
    (interactive "P")
    (call-interactively
     (cond (arg
            #'(lambda ()
                (interactive)
                (vc-diff nil)))
           (t
            #'(lambda ()
                (interactive)
                (leuven--ediff-revision (buffer-file-name)
                                        (read-string "revision? "
                                                     "HEAD" nil "HEAD")
                                        ""))))))

  (define-key vc-prefix-map (kbd "=") #'leuven-vc-diff)
#+end_src

Today I learned that it is also interactive. I can cycle through revisions using
p and n, open the file at a specified revision with f, view the log with l, and
show a diff with d or changeset diff with D. (Unfortunately, the diff is ugly
and not in color.)


The best command in vc-annotate is "a": Reruns annotate from the revision _prior_
to the revision that last changed the current line, so you can dig deeper into
that line's raison d'etre, skipping uninteresting commits like whitespace
changes.

#+begin_src emacs-lisp
(setq vc-annotate-display-mode nil)

;; http://www.onerussian.com/Linux/.files/dot_emacs
(setq vc-annotate-background "seashell")
(setq vc-annotate-very-old-color "black")

(setq vc-annotate-color-map
  '((  1.0 . "#FFCCCC") ; red
    (  7.0 . "#FFE4CC") ; orange
    ( 30.0 . "#DEFFCC") ; green
    ( 90.0 . "#CCE4FF") ; blue
    (360.0 . "#C9C9C9"))) ; white
#+end_src

*************** TODO Customize `vc-annotate-background' (and future `vc-annotate-foreground')
*************** END

** Change Logs

#+begin_src emacs-lisp
;;** 28.2 (info "(emacs)Change Log")

  (leuven--section "28.2 (emacs)Change Logs")

  (with-eval-after-load "add-log"

    ;; Don't make a new entry, when the last entry was made by you and on the
    ;; same date.
    (setq add-log-always-start-new-record nil)

    ;; Add the file's version number to the change log entry.
    (setq change-log-version-info-enabled t)

    ;; Remove 'Invalid function' in Emacs 27
    ;; (add-hook 'change-log-mode-hook
    ;;           (add-to-list
    ;;            'change-log-font-lock-keywords
    ;;            '("^[0-9-]+:? +\\|^\\(Sun\\|Mon\\|Tue\\|Wed\\|Thu\\|Fri\\|Sat\\) [A-z][a-z][a-z] [0-9:+ ]+"
    ;;              (0 'change-log-date-face)
    ;;              ("\\([^<(]+?\\)[   ]*[(<]\\([[:alnum:]_.+-]+@[[:alnum:]_.-]+\\)[>)]" nil nil
    ;;               (1 'change-log-name)
    ;;               (2 'change-log-email)))))
  )
#+end_src

** Tags Tables (navigating code)

Using tags tables is the most generic approach to setup *code navigation*.  A
"tag" signifies a language object for which an index entry is available.

#+begin_note
There are many situations when you cannot or might not want to use ~tags~.  You
would like to use [[id:ea687cd8-fff0-461f-999e-c9fbc84b5901][Imenu]] because:

- Imenu is meaningful in non-programming modes and for non-visiting buffers.

- Virtually all modes already define Imenu, so it works out of the box
  everywhere, even if you read a language in which you will never write.

- And finally, Imenu operates on what you work on -- open files -- you don't get
  thousands of symbols from ~etags~ to deal with.

Using ~helm-imenu-in-all-buffers~ offers a much better, more uniform and more
consistent experience than anything else.
#+end_note

Always run ~make TAGS~ right after you build some project.

Once you've built a ~TAGS~ file (~ctags~ / ~etags~), you can find all commands that
match a regexp.

Support for tags has been in Emacs for a long time: any installation of Emacs
should comes with the ~etags~ program, which supports many different languages.

Comparison of tools:

- etags (Emacs-style TAGS file) ::
     Ada, Asm, *C*, Objective C, *C++*, C#, Cobol, Erlang, Forth, Fortran, HTML,
     *Java*, *Lisp*, Lua, Makefile, Pascal, Perl, *PHP*, Postscript, Prolog, *Python*,
     Scheme, TeX, TeXinfo, and YACC.

     On Windows, Emacs comes with ~etags~ and a similar executable file called
     ~ctags~.  In the Emacs distribution, =etags.exe= = =ctags.exe= in the =bin=
     directory.

- Exuberant Ctags ::
     Ant, Asm, Asp, Awk, Basic, BETA, *C*, *C++*, C#, Cobol, DosBatch, Eiffel,
     Erlang, Flex, Fortran, HTML, *Java*, JavaScript, *Lisp*, Lua, Makefile,
     MatLab, OCaml, Pascal, Perl, *PHP*, *Python*, REXX, *Ruby*, Scheme, Sh, SLang,
     SML, SQL, Tcl, TeX, Vera, Verilog, VHDL, Vim, and YACC.

     You should download *Exuberant Ctags* from http://ctags.sourceforge.net/ or
     from Cygwin.  Only *Exuberant* =ctags.exe= recognizes ~-e~ option (/etags mode/,
     which will create a tag file for use with the Emacs editor).

     Exuberant Ctags can be extended to look for other things via regular
     expression.  It is a wonderful thing!

     For example, I can now look for tags in my shell code to by running:

     #+begin_src shell :tangle no
     etags --langdef=shell --regex-shell='/function [_[:alnum:]]+/[_[:alnum:]]+/' --language-force=shell
     #+end_src

- Cscope ::
     C, but flexible enough to support C++ and Java, and to be used as a
     generalized "grep database".

- ebrowse ::
     For C++, you will be better off with ebrowse, a program that also comes
     with Emacs.  It understands C++ much better than etags does, and provides
     similar commands (so you don't lose anything).  Check out the Ebrowse
     manual, which is part of the Emacs distribution, for details.

- GNU Idutils ::

- GNU Global (gtags) ::
     *C*, *C++*, Yacc, *Java*, and *PHP4*.

     Global is a lot smarter about finding tags tables, and is fairly fast to
     update.

*Emacs TAGS* and *Exuberant Ctags* don't do fancy stuff, e.g. keeping an index of
function references.  They record only positions where a function (or variable
etc.) is *defined*.

Recording positions where a function is *called* (finding all *symbol references*)
is the kind of thing external tools such as *GNU Global*, *GNU Idutils* and *Cscope*
can do for you, if you're working with a language that they support.  *Grep*
would be the fallback method.

Please also see [[http://hub.opensolaris.org/bin/view/Project+opengrok/][Comparison with Similar Tools]].

Once you have a good tagging system in place, many tools become enabled for your
language, such as:

- tag decoration mode (like drawing lines over the top of function tags),
- stickyfunc mode (which shows the current function in the header line),
- [[id:5032bcdb-ac6b-4101-a0ce-28192fb7e247][Emacs Code Browser]], and
- tag jumping.

#+begin_src emacs-lisp
;;** 28.3 (info "(emacs)Tags")

  (leuven--section "28.3 (emacs)Tags Tables")
#+end_src

*** Creating Tags Tables

First of all, you must build a ~TAGS~ file (which keeps the symbols from your
project, by scanning all the source and header files with the ~etags~ command).

For example, you can have a ~TAGS~ Makefile target to do this for you:

#+begin_src makefile :tangle no
TAGS:
        rm -f TAGS
        find $$(pwd) \( -name \*.el \
                     -o -name \*.[chCH] \
                     \) -print | /usr/bin/ctags -e -
#+end_src

You can create a =TAGS= file by using ~M-x compile RET tags RET~.  Every time
you changes your source file, you need to regenerate the tag file.

Alternatively,

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "etags"

    ;; Tags enhancements.
    (try-require 'sure-tags))
#+end_src

will make sure that ~TAGS~ file exists (and builds it if it doesn't), allowing
you to

- first rebuild the ~TAGS~ file or
- specify a new one

when the search fails.

*** Finding a Tag (go to function definition)

#+begin_note
New package Xref replaces Etags's front-end and UI.

The new package Xref provides a generic framework and new commands to
find and move to definitions of functions, macros, data structures
etc., as well as go back to the location where you were before moving
to a definition.  It supersedes and obsoletes many Etags commands.
#+end_note

You can *go to* the first *definition* of a tag (matching your regexp) -- *according*
*to TAGS file* -- by using ~M-x xref-find-definitions~ (bound to ~M-.~).  The default
tag is the identifier under the cursor.

If ~M-.~ brings up the wrong method, you can type ~C-u M-.~ to continue searching
for the *next definition* with the same name.

Use ~M-,~ (~M-x xref-pop-marker-stack~) to *jump back* to where you last invoked ~M-.~.

XXX See http://marmalade-repo.org/packages/jump-dls to jump to the source of the
symbol at point using a number of possible methods, such as semantic, tags, etc.

*** Select from multiple TAGS files

You can search for *occurrences* of tags that match you regexp on all files in
the TAGS table, by using ~M-x tags-search RET~.

#+begin_src emacs-lisp
  ;; (with-eval-after-load "etags"
  ;;
  ;;   ;; Select from multiple tags.
  ;;   (try-require 'etags-select))

  (with-eval-after-load "etags-select"

    ;; Do a `find-tag-at-point', and display all exact matches.
    (global-set-key (kbd "M-?") #'etags-select-find-tag-at-point))
#+end_src

However, the default Emacs' etag feature is not quite good. You should use etags
provided by Helm.  Instead of activating ~etags-select-goto-tag~, try
~helm-etags-select~.  If the project is big, it take some time to load tag file.
But when it is done, the next search will be very fast.

See http://truongtx.me/2014/04/20/emacs-javascript-completion-and-refactoring/.

*** Find Emacs Lisp symbol definition

Find the definition of the Emacs Lisp symbol near point:

- ~C-x F~ ::
     Find *function*.

- ~C-x K~ ::
     Find function *bound to key* sequence.

- ~C-x V~ ::
     Find *variable*.

- ~M-x find-face-definition~ ::
     Find *face*.

Use ~C-x 4~ for displaying in another window, and ~C-x 5~ for displaying in
another frame.

#+begin_src emacs-lisp
  ;; Find the definition of the Emacs Lisp function or variable near point.
  (find-function-setup-keys)
#+end_src

Go to source code for symbol at point:

#+begin_src emacs-lisp
  (with-eval-after-load "lisp-mode"

    (defun leuven-goto-lisp-symbol-at-point ()
      "Go to the definition of the Emacs Lisp symbol at point."
      (interactive)
      (require 'thingatpt)              ; XXX use xref-find-definitions instead?
      (let ((sym (symbol-at-point)))    ; or (find-tag-default) or (current-word)?
        (funcall (pcase sym
                   ((pred facep)           'find-face)
                   ((pred symbol-function) 'find-function)
                   (_                      'find-variable))
                 sym)))

    (define-key emacs-lisp-mode-map (kbd "M-.") #'leuven-goto-lisp-symbol-at-point))
#+end_src

*** dump-jump (go to definition)

With this package, you can jump to a definition (of the symbol at point) for
multiple languages without any setup (e.g. *no =TAGS= file is needed anymore*).

Dumb Jump uses
- ripgrep ~rg~ (the best ~grep~ alternative),
- The Silver Searcher ~ag~, or
- falls back to ~grep~
to find potential definitions of a function or variable under point.

It uses a set of regular expressions based on the file extension, or ~major-mode~,
of the current buffer.

See https://github.com/jacktasia/dumb-jump.

Keyboard shortcuts:

| Command                             | Leuven | Sublime Text | Visual Studio |
|-------------------------------------+--------+--------------+---------------|
| Go to definition                    | C-M-g  | F12          | F12           |
| Back (can be called multiple times) |        |              |               |
| Open definition to the side         |        |              | C-k F12       |
|-------------------------------------+--------+--------------+---------------|
| Quick look                          | C-M-y  |              |               |

#+begin_src emacs-lisp
;; XXX IntelliJ IDEA:
;; C-f1
;; Quick Definition View: C-S-i
;; Quick Documentation View: C-q
  (with-eval-after-load "dumb-jump-autoloads"

    ;; ;; Use Helm as selector when there are multiple choices.
    ;; (setq dumb-jump-selector 'helm)

    ;; Prefer to use `rg' over `ag'.
    (setq dumb-jump-prefer-searcher 'rg)

    ;; Number of seconds a grep/find command can take before being warned to use
    ;; ag and config.
    (setq dumb-jump-max-find-time 5)

    (global-set-key (kbd "M-g j") #'dumb-jump-go)
    (global-set-key (kbd "<f12>") #'dumb-jump-go)
                                        ; Conflict when GDB'ing Emacs under
                                        ; Win32.
    ;; (global-set-key (kbd "C-M-g") #'dumb-jump-go)
    ;; (global-set-key (kbd "C-c S") #'dumb-jump-go)

    (global-set-key (kbd "M-g o") #'dumb-jump-go-other-window)
    ;; (global-set-key (kbd "C-M-o") #'dumb-jump-go-other-window)

    (global-set-key (kbd "M-g x") #'dumb-jump-go-prefer-external)
    (global-set-key (kbd "M-g z") #'dumb-jump-go-prefer-external-other-window)

    (global-set-key (kbd "M-g P") #'dumb-jump-back)

    ;; (define-key prog-mode-map (kbd "C-M-q") nil)

;; XXX dumb-jump-quick-look is an obsolete command (as of 2020-06-26);
;; XXX dumb-jump-quick-look has been obsoleted by the xref interface.

    (global-set-key (kbd "M-g y") #'dumb-jump-quick-look)
    (global-set-key (kbd "C-M-y") #'dumb-jump-quick-look)

    (dumb-jump-mode)
)
#+end_src

#+begin_note
~rg~ is faster, but its results aren't deterministic and it doesn't support
*multiline* search or full *PCRE*, that's where ~ag~ is useful.
#+end_note

Need to debug it?

- If ~dumb-jump-go~ fails, search the same string with ~helm-projectile-ag~.
- If ~helm-projectile-ag~ fails, see ~helm-ag--last-command~ and make it from
  command line.
- If it fails, try it with plain ~ag~ without all the flags.
- If it fails, try it with alternative tool like ~grep~ or ~ack~.

(from https://kozikow.com/2016/05/21/nice-new-emacs-package-dumb-jump-el/)

** Emacs Development Environment

*** Collection of Emacs Development Environment Tools

#+begin_src emacs-lisp
;;** 28.4 (info "(emacs)EDE")

  (leuven--section "28.4 Emacs Development Environment")
#+end_src

CEDET (integrated into Emacs 23.2) brings improvements over a plain TAGS file.
It provides:

- [[http://www.gnu.org/software/emacs/manual/semantic.html][Semantic]] ::
     A *parser* and code analyzer which provides *smart completion*
     ("Intellisense").

- EDE ::
     A *project management* system which can *generate Makefiles* to compile your
     code for you.

     #+begin_tip
     Projectile is another Emacs library providing easy project management and
     navigation.  The concept of a project is pretty basic -- just a folder
     containing special file.  Git repos are considered projects by default.  If
     you want to mark a folder manually as a project just create an empty
     =.projectile= file in it.
     #+end_tip

- SRecode ::
     A template / *code generation* system which can convert tags from semantic
     back into code.

- COGRE (COnnected GRaph Editor) ::
     A *UML diagram editor* which can generate code from a class diagram that you
     draw in Emacs.

See [[http://cedet.sourceforge.net/languagesupport.shtml][supported languages]].

The commands to display *symbol references* are:

- ~C-c , g~ ::
     ~semantic-symref-symbol~.

- ~C-c , G~ ::
     ~semantic-symref~ (current tag).

#+begin_src emacs-lisp
  (unless (string< emacs-version "23.2")
    ;; ;; Enable global EDE (project management) features.
    ;; (global-ede-mode 1)

    (setq semantic-default-submodes
          '(
            ;; Turn Semantic DB mode on (Semantic parsers store the results of
            ;; parsing source code in a database file, which can be saved for
            ;; future Emacs sessions).
            global-semanticdb-minor-mode

            ;; The idle scheduler will automatically reparse buffers in idle
            ;; time.
            global-semantic-idle-scheduler-mode ; [minimum-features]

            ;; Display a summary of the symbol at point in the echo area
            ;; (~ ElDoc).
            global-semantic-idle-summary-mode ; [code-helpers]

            ;; Display a tooltip with a list of possible completions near the
            ;; cursor.
            global-semantic-idle-completions-mode ; [gaudy-code-helpers]

            ;; Turn Semantic MRU Bookmarks on (keep track of the Most
            ;; Recently Used tags).
            global-semantic-mru-bookmark-mode

            ;; Enable Semantic-Stickyfunc mode (display a header line that shows
            ;; the declaration line of the function or tag).
            global-semantic-stickyfunc-mode ; [gaudy-code-helpers]

            ;; Enable Semantic-Highlight-Func mode.
            global-semantic-highlight-func-mode ; [excessive-code-helpers]

            ;; Turn on all active decorations.  Show Method Separators.
            global-semantic-decoration-mode ; [gaudy-code-helpers]
            ))

    ;; XXX If prog-mode, then Semantic will be launched after Emacs init, as
    ;; the scratch buffer is in Emacs Lisp...
    (add-hook 'java-mode-hook #'semantic-mode)
                                        ; Enable parser features (Semantic mode)
                                        ; and install a `Development' menu on
                                        ; the menu-bar.

    ;; ;; Smart completion, and display of information for tags & classes.
    ;; (require 'semantic/ia)
    ;;
    ;; (require 'semantic/db)

    (with-eval-after-load "semantic"

      (defun leuven--semantic ()
        ;; Automatically complete whatever symbol you are typing.
        (local-set-key
          (kbd "C-c ?") #'semantic-ia-complete-symbol) ; Better binding: `M-/'?

        ;; Jump to the definition of the symbol under cursor.
        (local-set-key
          (kbd "C-c j") #'semantic-ia-fast-jump) ; Where a symbol is declared.

        ;; Show the documentation of the symbol under cursor.
        (local-set-key
          (kbd "C-c q") #'semantic-ia-show-doc) ; Show javadoc of the right method.

        ;; Show a summary about the symbol under cursor.
        (local-set-key
          (kbd "C-c s") #'semantic-ia-show-summary)


        ;; Show possible public member functions or data members (when at `.'
        ;; or `->' after an object name).
        (local-set-key
          (kbd "C-c >") #'semantic-complete-analyze-inline)

        ;; ;; Toggle between the implementation and a prototype of symbol under
        ;; ;; cursor.
        ;; (local-set-key
        ;;   (kbd "C-c p") #'semantic-analyze-proto-impl-toggle) ; vs Projectile.

        ;; Visit the header file under cursor.
        (local-set-key
          (kbd "C-c =") #'semantic-decoration-include-visit)


        ;; Unfold the block under cursor.
        (local-set-key
          (kbd "C-c +") #'semantic-tag-folding-show-block)

        ;; Fold the block under cursor.
        (local-set-key
          (kbd "C-c -") #'semantic-tag-folding-fold-block)

        ;; C-c C-c is not a prefix key!
        ;; ;; Unfold all.
        ;; (local-set-key
        ;;   (kbd "C-c C-c +") #'semantic-tag-folding-show-all)
        ;;
        ;; ;; Fold all.
        ;; (local-set-key
        ;;   (kbd "C-c C-c -") #'semantic-tag-folding-fold-all)
        )

      (add-hook 'prog-mode-hook #'leuven--semantic)

      (defun leuven--c-mode-semantic ()
        "Completion on `.' or `->'."
        (local-set-key (kbd ".") #'semantic-complete-self-insert)
        (local-set-key (kbd ">") #'semantic-complete-self-insert)
        (local-set-key (kbd "C-c C-r") #'semantic-symref))

      (add-hook 'c-mode-common-hook #'leuven--c-mode-semantic))
                                        ; Note that this will apply to all
                                        ; cc-modes, e.g. c-mode, c++-mode,
                                        ; php-mode, csharp-mode, awk-mode.

    ;; Hooks, specific for Semantic.
    (defun leuven--semantic-imenu ()
      (imenu-add-to-menubar "TAGS"))

    (add-hook 'semantic-init-hook #'leuven--semantic-imenu)

    )
#+end_src

*** Advanced Code Browsing
:PROPERTIES:
:ID:       5032bcdb-ac6b-4101-a0ce-28192fb7e247
:END:

Some people use CEDET in combination with [[http://www.xemacs.org/Documentation/packages/html/ecb_2.html][ECB (the Emacs Code Browser)]], which
provides views of directories and files.

Keyboard navigation:

- ~C-c . g d~ ::
     Go to directories.

- ~C-c . g s~ ::
     Go to sources.

- ~C-c . g m~ ::
     Go to methods.

- ~C-c . g h~ ::
     Go to history.

- ~C-c . g 1~ ::
     Go to edit buffer.

#+begin_src emacs-lisp :tangle no
  ;; Emacs Code Browser.
  (custom-set-variables '(ecb-options-version "2.40"))
  (try-require 'ecb-autoloads)
  (with-eval-after-load "ecb-autoloads"

    ;; Trick for starting ECB 2.40 (with CEDET merged in Emacs since 23.2).
    (require 'semantic/analyze)
    (provide 'semantic-analyze)
    (provide 'semantic-ctxt)
    (provide 'semanticdb)
    (provide 'semanticdb-find)
    (provide 'semanticdb-mode)
    (provide 'semantic-load)

    (setq stack-trace-on-error t)

    ;; Don't show tip of the day at start time of ECB.
    (setq ecb-tip-of-the-day nil)

    ;; ;; Toggle activation of ECB (between `ecb-activate' and `ecb-deactivate').
    ;; (global-set-key (kbd "C-c e") #'ecb-minor-mode)
  )
#+end_src

If you've installed CEDET and ECB, EmacsAssist is worth trying out:
http://www.mail-archive.com/gnu-emacs-sources@gnu.org/msg00292.html

It uses CEDET to provide a handy symbols browser for the current file, that
narrows down the list as you type substrings.  Tastes differ, but I for one
really like this.

#+begin_src emacs-lisp :tangle no
  (try-require 'eassist)
  (with-eval-after-load "eassist"

    (defun leuven--c-mode-eassist ()
      (local-set-key (kbd "C-c t") #'eassist-switch-h-cpp)
      (local-set-key (kbd "C-x t") #'eassist-switch-h-cpp)
      ;; (local-set-key (kbd "C-c e") #'eassist-list-methods)
      )

    (add-hook 'c-mode-common-hook #'leuven--c-mode-eassist))
                                        ; Note that this will apply to all
                                        ; cc-modes, e.g. c-mode, c++-mode,
                                        ; php-mode, csharp-mode, awk-mode.
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 28 ends here.
#+end_src

*** Projectile

Projectile's features.

- C-c p p ::
     *Switch* between *projects* you have worked on.

**** Navigating project files

- C-c p f ::
     Prompt you for a *file* in project to *jump to*.

- C-c p d ::
     Prompt you for a *directory* in project to *jump to*.

- C-c p e ::
     Prompt you for a *recently visited file* in the project to *jump to*.

- C-c p b ::
     Prompt you for a project *buffer* to *jump to*.

- C-c p l ::
     *Jump to* a *file in a directory*.

**** Running grep and occur

- C-c p s g (or C-c p g in Emacs-Leuven) ::
     Run *~grep~* on the files in the project.

- C-c p s s ::
     Run *~ag~* on the files in the project. [Helm-Projectile]

- C-c p o ::
     Run *~multi-occur~* on all project's buffers currently open.

**** X

- C-c p R ::
     *Regenerate* project *~etags~ or ~gtags~* (requires ~ggtags~).

**** Running tests and compilation commands

- C-c p P ::
     Run a *test* command (~make test~) for the current project.

- C-c p c ::
     Run a *compilation* command (~make~) for the current project.

- C-c p u ::
     Run a *run* command for the current project.

**** Switching between tests and source files

- C-c p t ::
     *Toggle between* an *implementation* file *and* its *test* file.

- C-c p T ::
     *Jump to* a *test file* in project.

**** Switching between controllers and views

- C-c p a ::
     *Switch between files* with *same name* but *different extensions* (e.g. =.h= <->
     =.c= / =.cpp=).

# - C-c p g ::
#      *Jump to file at point* in project.

**** Running VC

- C-c p v ::
     Open version control for the current project.

**** Opening Dired

- C-c p D ::
     Open *Dired* at the root of the project.

**** Running a shell command

- C-c p ! ::
     Run a shell command in the project root.

**** X

- C-c p k ::
     *Kill all* project *buffers*.

- C-c p r ::
     *Replace* literal string in project.

#+begin_src emacs-lisp
  (with-eval-after-load "projectile-autoloads"

    ;; Turn on projectile mode by default for all file types
    (projectile-mode)
    ;; (projectile-global-mode) ??

    ;; Add keymap prefix.
    (define-key projectile-mode-map (kbd "C-c p")   #'projectile-command-map)

    (define-key projectile-mode-map (kbd "C-c p g") #'projectile-grep)

    (setq projectile-completion-system 'helm)
    (setq projectile-completion-system 'helm-comp-read)

    ;; Turn on Helm key bindings for projectile.
    (when (locate-library "helm-projectile")
      (helm-projectile-on))

    ;; ;; For large projects.
    ;; (setq helm-projectile-sources-list
    ;;       '(helm-source-projectile-projects
    ;;         helm-source-projectile-files-list))

  )

  (with-eval-after-load "projectile"

    ;; Indexing method.
    ;; (setq projectile-indexing-method 'native)

    ;; Enable caching of the project's files unconditionally.
    (setq projectile-enable-caching t)

    ;; Action invoked AFTER SWITCHING PROJECTS with `C-c p p'.
    (setq projectile-switch-project-action 'helm-projectile-find-file)
                                        ;; 'projectile-dired
                                        ;; 'projectile-find-file ; Default.
                                        ;; 'projectile-find-file-in-known-projects
                                        ;; 'projectile-find-file-dwim
                                        ;; 'projectile-find-dir

    ;; Don't echo messages that are not errors.
    (setq projectile-verbose nil)

    ;; Always ignore .class files.
    (add-to-list 'projectile-globally-ignored-file-suffixes ".class")

    ;; Ignore remote projects.
    (setq projectile-ignored-project-function 'file-remote-p)

    ;; Mode line lighter prefix for Projectile.
    (setq projectile-mode-line-prefix " P")
    ;; (setq projectile-mode-line-function
    ;;       '(lambda ()
    ;;          (if (and (projectile-project-p)
    ;;                   (not (file-remote-p default-directory)))
    ;;              (format " P[%s]" (projectile-project-name))
    ;;            "")))

    ;; Command to use with projectile-run-project.
    (setq projectile-project-run-cmd "mintty /bin/bash -l -e '../../start.sh'") ; ARCHIBUS.

    ;; For ARCHIBUS.
    (add-to-list 'projectile-other-file-alist '("axvw" "js")) ; Switch from AXVW -> JS.
    (add-to-list 'projectile-other-file-alist '("js" "axvw")) ; Switch from JS -> AXVW.

    (defun leuven-find-file-archibus-log ()
      (interactive)
      (when-let ((root (projectile-project-root))
                 (logfile "WEB-INF/config/archibus.log"))
          (if (file-exists-p (expand-file-name logfile root))
              (find-file (expand-file-name logfile root))
            (user-error "You're not in an ARCHIBUS project"))))
    (define-key projectile-mode-map (kbd "C-c p A") #'leuven-find-file-archibus-log)
  )
#+end_src

*** Refactoring

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "emr-autoloads"
    (add-hook 'prog-mode-hook #'emr-initialize)
    (define-key prog-mode-map (kbd "M-RET") #'emr-show-refactor-menu))
#+end_src

* Abbrevs (Snippets, Auto Replacements, or live Code Templates)

An "abbrev" is a *word* which has been defined (in a fixed list) to "expand"
into a specified *expansion*.

It allows you to write frequently used text more quickly.

#+begin_src emacs-lisp
;;* 29 (info "(emacs)Abbrevs")

(leuven--chapter leuven-load-chapter-29-abbrevs "29 Abbrevs"

  ;; See (info "(autotype)") as well
#+end_src

** Controlling Abbrev Expansion

Inspired by [[http://macromates.com/][TextMate]].  In fact, many editors support *snippets*: Eclipse,
Notepad++, etc.

*************** TODO Add rv for "REVIEW[who] text" https://www.jetbrains.com/help/idea/using-live-templates-in-todo-comments.html
*************** END

For complex templates, I use ~YASnippet~.  For example, new file templates (where
it's Lisp evaluation is handy), class and function templates with docblocks,
etc. I use it to reduce the repetitious parts of programming, and let me focus
on getting things done.

~YASnippet~ does support mirror fields and transformations.  It also does support
multiple snippets with same name.  It will also expand snippets containing
non-word-constituent characters, which ~abbrev~ can't.  So I can't have ~@p~ expand
to ~@param~ with ~abbrev~, but I can with ~YASnippet~.

XXX Look at https://github.com/vderyagin/dotemacs/blob/master/conf/yasnippet-configuration.el

#+begin_example
# -*- mode: snippet -*-
# name: file.name
# key: hello
# --
Hello,$0 ${1:this} is a ${2:snippet}.
#+end_example

Predefined YASnippet variables:
- ~$0~ indicates the position of the cursor after the template is expanded.
- ~`yas-selected-text`~ is used in *surround templates* and stands for the code
  fragment to be wrapped.

#+begin_src emacs-lisp
;;** 29.3 Controlling (info "(emacs)Expanding Abbrevs")

  (leuven--section "29.3 Controlling Expanding Abbrevs")

  ;; Yet Another Snippet extension for Emacs
  (with-eval-after-load "yasnippet-autoloads"
    (idle-require 'yasnippet))

  (with-eval-after-load "yasnippet"
#+end_src

*** Organizing snippets

Where are the snippets?  ~yas-snippet-dirs~ is assumed to contain *directories of
modes* with snippets:

- ~yas-installed-snippets-dir~ (the bundled snippets), and
- *your own snippets* in the directory =~/.emacs.d/snippets=.

Load additional snippets.

#+begin_src emacs-lisp
    ;; Add root directories that store the snippets.
    (let ((leuven-snippets              ; Additional YASnippets.
           (concat leuven--directory "snippets")))

      (when (file-directory-p leuven-snippets)
        (add-to-list 'yas-snippet-dirs leuven-snippets)))
                                        ; The first element (inserted last) is
                                        ; always the user-created snippets
                                        ; directory.

    ;; Use Snippet mode for files with a `yasnippet' extension.
    (add-to-list 'auto-mode-alist '("\\.yasnippet\\'" . snippet-mode))
#+end_src

*** Installation

**** Use YASnippet as a global minor mode

#+begin_src emacs-lisp
    ;; Enable YASnippet in all buffers.
    (yas-global-mode 1)
#+end_src

#+begin_tip
Use ~yas-global-mode~ *after* you set yas-snippet-dirs. Otherwise you have to use
~yas-reload-all~.
#+end_tip

**** Use ~yas-minor-mode~ on a per-buffer basis

#+begin_src emacs-lisp :tangle no
    ;; Enable YASnippet in programming modes only.
    (add-hook 'prog-mode-hook #'yas-minor-mode)
#+end_src

#+begin_src emacs-lisp
    (with-eval-after-load "diminish-autoloads"
      (diminish 'yas-minor-mode " y"))

    ;; Load the snippet tables.
    (yas-reload-all)

    ;; Wrap around region.
    (setq yas-wrap-around-region t)
#+end_src

*** Expanding snippets

- ~C-c & C-s~ ::
     Insert snippet at point.

Insert *code templates* (/snippets/) by pressing ~TAB~.

#+begin_src emacs-lisp :tangle no
    ;; ;; Bind `yas-expand' to SPC.
    ;; (define-key yas-minor-mode-map (kbd "<tab>") nil)
    ;; (define-key yas-minor-mode-map (kbd "TAB") nil)
    ;; (define-key yas-minor-mode-map (kbd "SPC") #'yas-expand)
#+end_src

#+begin_src emacs-lisp
    ;; Don't expand when you are typing in a string or comment.
    (add-hook 'prog-mode-hook
              #'(lambda ()
                  (setq yas-buffer-local-condition
                        '(if (nth 8 (syntax-ppss))
                                        ; Non-nil if in a string or comment.
                             '(require-snippet-condition . force-in-comment)
                           t))))

    ;; UI for selecting snippet when there are multiple candidates.
    (setq yas-prompt-functions '(yas-dropdown-prompt))
#+end_src

YASnippet allows navigating through the data input fields, where you can specify
your own data.  Use the ~TAB~ key to go forward and the ~Shift+TAB~ keys to go back.

*** Writing snippets

See http://cupfullofcode.com/snippet-expansion-with-yasnippet/.

- ~C-c & C-n~ (~yas-new-snippet~) ::
     Creates a new snippet, pre-filled out with the basic structure.

- ~C-c & C-v~ ::
    ~yas-visit-snippet-file~.

*** YASnippet menu

After editing your snippets:

- ~M-x yas-recompile-all~ to compile all snippets,

- ~M-x yas-reload-all~ to reload them all.

#+begin_src emacs-lisp
    (global-set-key (kbd "C-c & C-r") #'yas-reload-all)
#+end_src

Automatically reload snippets after saving.

#+begin_src emacs-lisp
    ;; Automatically reload snippets after saving.
    (defun recompile-and-reload-all-snippets ()
      (interactive)
      (when (derived-mode-p 'snippet-mode)
        (yas-recompile-all)
        (yas-reload-all)
        (message "[Reloaded all snippets]")))

    (add-hook 'after-save-hook #'recompile-and-reload-all-snippets)
#+end_src

Display all available snippets with ~M-x yas-describe-tables~ (or ~C-c & C-l~ in
Emacs-Leuven):

#+begin_src emacs-lisp
    (global-set-key (kbd "C-c & C-l") #'yas-describe-tables)
#+end_src

See http://stackoverflow.com/questions/10155181/display-all-snippets-of-yasnippet.

#+begin_src emacs-lisp
    (defvar leuven-contextual-menu-map
      (let ((map (make-sparse-keymap "Contextual menu")))
        (define-key map [help-for-help] (cons "Help" 'help-for-help))
        (define-key map [seperator-two] '(menu-item "--"))
        map)
      "Keymap for the contextual menu.")

    (defun leuven-popup-contextual-menu (event &optional prefix)
      "Popup a contextual menu."
      (interactive "@e \nP")
        (define-key leuven-contextual-menu-map [lawlist-major-mode-menu]
          `(menu-item ,(symbol-name major-mode)
            ,(mouse-menu-major-mode-map) :visible t))
        (define-key leuven-contextual-menu-map (vector major-mode)
          `(menu-item ,(concat "Insert " (symbol-name major-mode) " snippet")
            ,(gethash major-mode yas--menu-table)
              :visible (yas--show-menu-p ',major-mode)))
        (popup-menu leuven-contextual-menu-map event prefix))

    (global-set-key [mouse-3] #'leuven-popup-contextual-menu)
#+end_src

*** Frequently Asked Questions

**** Why is there an extra newline?

#+begin_src emacs-lisp
    (add-hook 'snippet-mode-hook
              #'(lambda ()
                  (setq require-final-newline nil)))
#+end_src

**** Why doesn't TAB expand a snippet?

1. Check the mode line to see if there's ~yas~. If not, then try
   ~M-x yas-minor-mode~ to manually turn on the minor mode and try to expand the
   snippet again.

   If it works, then, you can add the following code to your =.emacs= before
   loading YASnippet:

   #+begin_example
   (add-hook 'the-major-mode-hook #'yas-minor-mode-on)
   #+end_example

   where ~the-major-mode~ is the major mode in which ~yas-minor-mode~ isn't enabled
   by default.

   You can also use the command ~M-x yas-global-mode~ to turn on YASnippet
   automatically for all major modes.

2. If ~yas-minor-mode~ is on but the snippet still not expanded, then try to see
   what command is bound to the ~TAB~ key: press ~C-h k~ and then press ~TAB~. Emacs
   will show you the result.

   You'll see a buffer prompted by Emacs saying that ~TAB~ runs the command "...".
   Alternatively, you might see ~TAB~ runs the command "...". Note the
   difference between ~TAB~ and ~TAB~ where the latter has priority.

   If you see ~TAB~ bound to a command other than ~yas-expand~ (e.g. in org-mode),
   you can try a work around. See
   https://github.com/capitaomorte/yasnippet/blob/master/doc/faq.org.

**** yas-key-syntaxes

~yas-key-syntaxes~ is the variable that allows you control the behavior "don't
expand words finishing with the snippet key", even if:

- the default syntax table for the major mode you are working on says that "C-s"
  (for example) is two separate words, and

- assuming you don't want to fix the major mode's behavior.

Find it at http://capitaomorte.github.io/yasnippet/snippet-reference.html#yas-key-syntaxes

#+begin_src emacs-lisp
    ;; ;; Make the "yas-minor-mode"'s expansion behavior to take input word
    ;; ;; including hyphen.
    ;; (setq yas-key-syntaxes '("w_" "w_." "^ "))
                                        ; [default:
                                        ; '("w" "w_" "w_." "w_.()"
                                        ;   yas-try-key-from-whitespace)]

    )
#+end_src

*** Reference

#+begin_src emacs-lisp
    ;; Log level for `yas--message'.
    (setq yas-verbosity 2)              ; Warning.
#+end_src

*** Quickly create disposable YASnippets

#+begin_src emacs-lisp
  (with-eval-after-load "auto-yasnippet-autoloads"
      ;; (global-set-key (kbd "H-w") #'aya-create)
      (global-set-key (kbd "H-y") #'aya-open-line))
#+end_src

** Dynamic Abbrev Expansion
:PROPERTIES:
:ID:       0fa23e4a-e42c-4317-834c-d2ef7c9d741c
:END:

"Dynamic abbrevs" allow the meanings of abbreviations (expansions) to be
*determined automatically from the contents of the buffer*.  It is completely
independent of Abbrev mode.

- ~M-/~ runs the command ~dabbrev-expand~ by default.  Expand previous word
  "dynamically".  *Expands to the most recent, preceding word* for which this is
  a prefix.

- ~C-M-/~ runs the command ~dabbrev-completion~.  Completion on current word.  Like
  ~M-/~ but finds all expansions in the current buffer and *presents suggestions
  for completion*.

See [[id:4b262301-5370-40c6-8da6-019215634e20][completion for symbol names]].

#+begin_src emacs-lisp
;;** 29.7 (info "(emacs)Dabbrev Customization")

  (leuven--section "29.7 Dabbrev Customization")

  ;; (with-eval-after-load "dabbrev"
  ;;
  ;;   ;; Preserve case when expanding the abbreviation.
  ;;   (setq dabbrev-case-replace nil))
#+end_src

** Code Completion

However, there are 3 amazing "intelligent guessing completion frameworks" in
Emacs:

- "Hippie" expansion,
- Auto-Complete and
- Company.

Hippe-expand is great (can complete whole code blocks for you, making it possible
to e.g. cycle through all if-tests in your projects).

But Auto-Complete and Company mode are even better. They'll give you a nice
IntelliSense style menu, will "learn" as you use it, and allows you to define
a file with the completions you'd like to be available in the various languages.

I prefer Company over Auto-Complete but YMMV.

*** "Hippie" expansion (Autotype)

Typically, *we bind ~hippie-expand~ to ~M-/~*, with ~dabbrev-expand~ (the standard
binding of ~M-/~) providing one of the expansion possibilities.

#+begin_src emacs-lisp
  ;; Expand text trying various ways to find its expansion.
  (global-set-key (kbd "M-/") #'hippie-expand) ; Built-in.
#+end_src

#+begin_tip
Would we want to bind ~hippie-expand~ on TAB, we should have to write a ~smart-tab~
command which would look if the major mode is Org and then act differently...
#+end_tip

# (use-package hippie
#   :load-path "vendor"
#   :bind (("C-." . hippie-expand-no-case-fold)
#          ("C-," . hippie-expand-lines))
#   :config
#   (require 'hippie))

#+begin_src emacs-lisp
  (with-eval-after-load "hippie-exp"

    ;; List of expansion functions tried (in order) by `hippie-expand'
    ;; (completion strategy).
    (setq hippie-expand-try-functions-list
          '(;; Searching the current buffer.
            try-expand-dabbrev

            ;; Emacs Lisp symbol, as many characters as unique.
            try-complete-lisp-symbol-partially

            ;; Emacs Lisp symbol.
            try-complete-lisp-symbol

            ;; Searching visible window parts.
            try-expand-dabbrev-visible

            ;; ;; Searching (almost) all other buffers (see
            ;; ;; `hippie-expand-ignore-buffers').
            ;; try-expand-dabbrev-all-buffers

            ;; File name, as many characters as unique.
            try-complete-file-name-partially

            ;; File name.
            try-complete-file-name))
#+end_src

See https://github.com/dgutov/dot-emacs/blob/master/site-lisp/hippie.el for
a local var version of ~hippie-expand-try-functions-list~ for Emacs Lisp.

Configure Hippie-expand to also expand YASnippets (on the key used by
~hippie-expand~, then).

#+begin_src emacs-lisp
    ;; Integrate YASnippet with `hippie-expand'.
    (with-eval-after-load "yasnippet"

      (add-to-list 'hippie-expand-try-functions-list
                   'yas-hippie-try-expand)))
                                        ; Makes more sense when placed at the
                                        ; top of the list.
#+end_src

*** Auto-Complete ("IntelliSensy" completion when writing code)

Auto-Complete shows completions as you type, so you can fill in long words by
typing only a few characters -- really brilliant!

Auto-complete uses the variable ~ac-modes~ to decide whether to enable
auto-completion in a particular mode; by default, ~org-mode~ (which interprets the
~TAB~ key) is not present in this list. So, to enable auto-completion in Org
mode, simply add it to the ~ac-modes~:

#+begin_example
(add-to-list 'ac-modes 'org-mode)
#+end_example

Popups:

- *Completion menu*

  Candidates suffix:
  + (nothing) -- means it is buffer string cache complete.
  + ~v~ -- Variable
  + ~f~ -- Function
  + ~s~ -- Symbol
  + ~c~ -- Constant
  + ~a~ -- Abbrev, YASnippet
  + ~d~ -- Dictionary, environment variable (e.g. ~LC_CTYPE~)
  + ~m~ -- Module

- *Quick help* (tooltip appearing at the side of the completion menu)

According to the default settings, completion is done by ~TAB~ or ~RET~:

- ~ac-expand~ (~TAB~) ::
     Select candidates in cycle.

- ~ac-complete~ (~RET~) ::
     Complete a selected candidate immediately.

There are other ways to select candidates:
- ~M-1~ to select candidate 1,
- ~M-2~ to select candidate 2,
- and so on (until 9).

Other operations are enabled temporarily *once the completion is started*:

- ~C-n~ or ~C-p~ ::
     Proceed to the *next match* or to the *previous match*.

- ~C-s~ (~ac-isearch~) ::
     *Filter* completion candidates.

- ~<C-down>~ or ~C-M-n~ (~ac-quick-help-scroll-down~) ::
     Scroll down quick help.

- ~<C-up>~ or ~C-M-p~ (~ac-quick-help-scroll-up~) ::
     Scroll up quick help.

- ~<F1>~ (or ~C-?~, ~ac-help~) ::
     Show additional *help* (for functions, arguments and objects) in *temporary
     buffer*.

     Use ~C-M-v~ (or ~C-M-S-v~) to scroll down (or up).

- ~M-<F1>~ (or ~C-M-?~, ~ac-persist-help~) ::
     Show additional *help* in *persistent buffer*.

Eventually, see [[http://stackoverflow.com/questions/19900949/how-to-make-auto-complete-work-with-yasnippet-and-abbrev][How to make auto-complete work with yasnippet and abbrev?]]

#+begin_src emacs-lisp :tangle no
;; Let's have snippets in the auto-complete dropdown
(add-to-list 'ac-sources 'ac-source-yasnippet)
#+end_src

#+begin_src emacs-lisp
  ;; Auto Completion.
  (with-eval-after-load "auto-complete-autoloads-XXX"
    (idle-require 'auto-complete-config)

    (global-set-key (kbd "C-/")     #'auto-complete)
    (global-set-key (kbd "C-S-SPC") #'auto-complete))

  (with-eval-after-load "auto-complete-config"

    ;; 6.1 Set a list of sources to use (by default + for some major modes)
    (ac-config-default))                ; ... and enable Auto-Complete mode in
                                        ; all buffers.

  (with-eval-after-load "auto-complete"
                                        ; Required by ESS.

    ;; 5.4 Completion will be started automatically by inserting 1 character.
    (setq ac-auto-start 1)              ; Also applies on arguments after
                                        ; opening parenthesis in ESS.

    ;; 7.5 Use `C-n/C-p' to select candidates (only when completion menu is
    ;; displayed).
    (setq ac-use-menu-map t)

    ;; Completion by TAB.
    (define-key ac-completing-map (kbd "<tab>")   #'ac-complete)

    ;; ;; Completion by RET.
    ;; (define-key ac-completing-map (kbd "<RET>") #'ac-complete)

    ;; Unbind some keys (inconvenient in Comint buffers).
    (define-key ac-completing-map (kbd "M-n")     nil)
    (define-key ac-completing-map (kbd "M-p")     nil)

    (define-key ac-completing-map (kbd "C-h")     #'ac-help)

    ;; Abort.
    (define-key ac-completing-map (kbd "C-g")     #'ac-stop)
    (define-key ac-completing-map (kbd "<left>")  #'ac-stop)
    ;; (define-key ac-completing-map (kbd "<right>") #'ac-stop)

    ;; Add other modes into `ac-modes'.
    (setq ac-modes
          (append ac-modes
                  '(change-log-mode
                    latex-mode
                    ;; org-mode
                    prog-mode           ; Programming modes.
                    snippet-mode
                    sql-mode
                    text-mode)))

    ;; 7.9 Just ignore case.
    (setq ac-ignore-case t)             ; ???

    ;; 8.1 Delay to completions will be available.
    (setq ac-delay 0)                   ; Faster than default 0.1.
    ;; Eclipse uses 500ms?

    ;; 8.2 Completion menu will be automatically shown.
    (setq ac-auto-show-menu 0.2)        ; [Default: 0.8].

    ;; 8.13 Delay to show quick help.
    (setq ac-quick-help-delay 0.5)

    ;; 8.15 Max height of quick help.
    (setq ac-quick-help-height 10)      ; Same as `ac-menu-height'.

    ;; 8.16 Limit on number of candidates.
    (setq ac-candidate-limit 100)

    ;; (setq ac-disable-inline t)
    ;; (setq ac-candidate-menu-min 0)

    ;; 11.1 Avoid Flyspell processes when auto completion is being started.
    (ac-flyspell-workaround)
#+end_src

#+begin_src emacs-lisp
)
#+end_src

XXX Test the following.

#+begin_src emacs-lisp :tangle no
    ;; Enable the drop down auto complete inside comment lines.
    (setq ac-disable-faces nil)
#+end_src

Integration of YASnipets:
https://github.com/joaotavora/yasnippet/issues/526

*** Company ("COMPlete ANYthing")

The best alternative to Auto-Complete seems to be Company mode.

#+begin_src emacs-lisp
(defun toggle-auto-complete-company-modes ()
  "Toggle beteen AC and Company modes."
  (interactive)
  (if auto-complete-mode
      (progn
        (auto-complete-mode -1)
        (company-mode 1)
        (message "Disable AC.  Enable Company")
        (sit-for 2))
    (auto-complete-mode 1)
    (company-mode -1)
    (message "Disable Company.  Enable AC")
    (sit-for 2)))

(global-set-key (kbd "<M-f1>") #'toggle-auto-complete-company-modes)
#+end_src

Besides that the maintainer of company-mode is incredibly competent and
friendly,

- Company mode is super easy to extend (whereas you often have to write 3-4
  times as much code to get the equivalent functionality out of AC backend);

- Company "just works", most of the time.  It's incredibly simple to use.

See https://github.com/company-mode/company-mode/issues/68 for a *feature
comparison* between both.

Completion will start automatically after you type a few letters.

Company mode has a unique take on auto-completion where it will reject
keystrokes if it doesn't match any possibilities.  It can also search available
completions and filter as well.

When the menu (with completion candidates) is displayed, press:

- ~up~ and ~down~ to select,
- ~RET~ or ~TAB~ to complete with the current selection
  (~company-complete-selection~).
- *Search through the completions* with ~C-s~, ~C-r~ and ~C-o~.
- Filter with ~C-M-s~.
- ~M-(digit)~ to quickly complete with one of the first 10 candidates.
- ~<right>~ to cancel completion.
- ~<F1>~ or ~C-h~ to *display the full documentation* for the selected symbol, or
- ~C-w~ to *show its definition*.

Not all back-ends support these last 2 commands.

#+begin_src emacs-lisp
  ;; Modular text completion framework.
  (with-eval-after-load "company-autoloads"

    ;; Enable Company mode in all buffers ....
    (global-company-mode 1)

    (global-set-key (kbd "C-c y") #'company-yasnippet)
                                        ; Better than `helm-yas-complete' as
                                        ; `company-yasnippet' shows both the key
                                        ; and the replacement.
    )
#+end_src

# #+begin_src emacs-lisp :tangle no
# ;; Hooks
# (add-hook 'web-mode-hook
#           #'(lambda ()
#               ;; Add company-mode backend for yasnippet.
#               (set (make-local-variable 'company-backends)
#                    (append company-backends '((company-yasnippet))))
#
#               ;; Auto indent.
#               (local-set-key (kbd "RET") #'newline-and-indent)
#
#               ;; Disable smartparens in web-mode.
#               (setq smartparens-mode nil)))
#
# ;; See web-mode-imenu-regexp-list.
# #+end_src

**** Common

#+begin_src emacs-lisp
  (with-eval-after-load "company"

    ;; ... Except in some modes.
    (setq company-global-modes
          '(not ess-mode                ; In (i)ESS buffers, Auto-Complete is
                inferior-ess-mode       ; enabled by default.
                magit-status-mode
                help-mode))
#+end_src

By default, the list of candidates is sorted alphabetically, unless the backend
(or we) choose(s) to sort them in a different way.

#+begin_src emacs-lisp
    ;; ;; Sort candidates according to their occurrences.
    ;; (setq company-transformers '(company-sort-by-occurrence))
    ;; (setq company-transformers '(;; company-sort-by-statistics ;; unknown
    ;;                              company-sort-by-backend-importance))
#+end_src

#+begin_src emacs-lisp
    ;; Align annotations to the right tooltip border.
    (setq company-tooltip-align-annotations t)

    ;; Minimum prefix length for idle completion.
    (setq company-minimum-prefix-length 1)

    ;; Start completion immediately.
    (setq company-idle-delay 0)

    ;; Show quick-access numbers for the first ten candidates.
    (setq company-show-numbers t)

    ;; Selecting item before first or after last wraps around.
    (setq company-selection-wrap-around t)

    ;; Abort.
    ;; (define-key company-active-map (kbd "<right>") #'company-abort)
    ;; (define-key company-active-map (kbd "<left>")  #'company-abort)

    ;; Ignore some keys (inconvenient in Comint buffers).
    (define-key company-active-map (kbd "M-n")     nil)
    (define-key company-active-map (kbd "M-p")     nil)

    ;; Completion by TAB (insert the selected candidate).
    (define-key company-active-map (kbd "<tab>")   #'company-complete-selection)

    ;; Temporarily show the documentation buffer for the selection.  Also on F1 or C-h.
    (define-key company-active-map (kbd "C-?")     #'company-show-doc-buffer)

    ;;! Temporarily display a buffer showing the selected candidate in context.
    (define-key company-active-map (kbd "M-.")     #'company-show-location) ; XXX Also on C-w.


 (setq company-auto-complete
       #'(lambda ()
           (and (company-tooltip-visible-p)
                (company-explicit-action-p))))

 (setq company-continue-commands
   '(not save-buffer
         save-some-buffers
         save-buffers-kill-terminal
         save-buffers-kill-emacs
         comint-previous-matching-input-from-input
         comint-next-matching-input-from-input))
 (setq company-require-match nil)
#+end_src

#+begin_src emacs-lisp
    ;; Do nothing if the indicated candidate contains digits (actually, it will
    ;; try to insert the digit you type).
    (advice-add 'company-complete-number :around
     #'(lambda (fun n)
         (let ((cand (nth (+ (1- n) company-tooltip-offset)
                          company-candidates)))
           (if (string-match-p "[0-9]" cand)
               (let ((last-command-event (+ ?0 n)))
                 (self-insert-command 1))
             (funcall fun n))))
     '((name . "Don't complete numbers")))
#+end_src

*First* run the *indent* function, then try *completion* only if it didn't change
anything.

XXX The following does not work in Org files (~TAB~ does not expand nodes anymore)!

#+begin_src emacs-lisp :tangle no
    ;; See `tab-always-indent'.

    (defun leuven-indent-or-complete ()
      "Indent the current line; if point doesn't move, then try to complete."
      (interactive)
      (let ((p (point)))
        ;; (if (minibufferp)
        ;;     (minibuffer-complete)
        (call-interactively 'indent-for-tab-command)
        (when (and (= p (point))
                   (not (bolp))
                   (looking-at "\\_>"))
          (call-interactively 'company-complete-selection))))

    (define-key company-mode-map (kbd "<tab>") #'leuven-indent-or-complete)

    ;; (defun leuven--tab-fix ()
    ;;   (local-set-key (kbd "<tab>") #'leuven-indent-or-complete))
    ;;
    ;; (add-hook 'prog-mode-hook #'leuven--tab-fix)
#+end_src

Only trigger the tooltip on manual invocation, but still have the preview (of
the first candidate) show up immediately:

#+begin_src emacs-lisp :tangle no
    (defun company-pseudo-tooltip-unless-just-one-frontend--only-show-tooltip-when-invoked (orig-fun &rest args)
      (when (company-explicit-action-p)
        (apply orig-fun args)))
    (advice-add 'company-pseudo-tooltip-unless-just-one-frontend
       :around #'company-pseudo-tooltip-unless-just-one-frontend--only-show-tooltip-when-invoked)
#+end_src

From https://github.com/company-mode/company-mode/issues/87.

See also https://github.com/company-mode/company-mode/issues/123.

**** Quick-access letters

Provide letters as key bindings for completion of strings.

#+begin_src emacs-lisp
    ;; From https://github.com/company-mode/company-mode/issues/188
    (defun leuven-company-quick-access-key (numbered)
      "Replace default behavior of `company--show-numbers' function.
This example lists Azerty layout second row keys."
      (let ((value (mod numbered 10)))
        (format " %s"
                (cond ((eql value 1) "a")
                      ((eql value 2) "z")
                      ((eql value 3) "e")
                      ((eql value 4) "r")
                      ((eql value 5) "t")
                      ((eql value 6) "y")
                      ((eql value 7) "u")
                      ((eql value 8) "i")
                      ((eql value 9) "o")
                      (t "p")))))

    (setq company-show-numbers-function #'leuven-company-quick-access-key)

    (define-key company-active-map (kbd "M-a") (kbd "M-1"))
    (define-key company-active-map (kbd "M-z") (kbd "M-2"))
    (define-key company-active-map (kbd "M-e") (kbd "M-3"))
    (define-key company-active-map (kbd "M-r") (kbd "M-4"))
    (define-key company-active-map (kbd "M-t") (kbd "M-5"))
    (define-key company-active-map (kbd "M-y") (kbd "M-6"))
    (define-key company-active-map (kbd "M-u") (kbd "M-7"))
    (define-key company-active-map (kbd "M-i") (kbd "M-8"))
    (define-key company-active-map (kbd "M-o") (kbd "M-9"))
    (define-key company-active-map (kbd "M-p") (kbd "M-0"))
#+end_src

**** Tab

So, Company mode and YASnippet step on each other toes. So these functions are
to help TAB have the behaviour I expect. Attempt these actions, and do the first
one that works.

1. expand yas snippet
2. auto complete with company
3. indent

#+begin_src emacs-lisp :tangle no
(defun check-expansion ()
  (save-excursion
    (if (looking-at "\\_>") t
      (backward-char 1)
      (if (looking-at "\\.") t
        (backward-char 1)
        (if (looking-at "->") t nil)))))

(defun do-yas-expand ()
  (let ((yas/fallback-behavior 'return-nil))
    (yas/expand)))

(defun tab-indent-or-complete ()
  (interactive)
  (if (minibufferp)
      (minibuffer-complete)
    (if (or (not yas/minor-mode)
            (null (do-yas-expand)))
        (if (check-expansion)
            (company-complete-common)
          (indent-for-tab-command)))))
#+end_src

I became fairly frustrated trying to bind tab, so this is a fairly dirty way of
altering the keymaps of company and yas-minor modes.

#+begin_src emacs-lisp :tangle no
(defun bind-tab-properly ()
  "Binds tab to tab-indent-or-complete, overwritting yas and company bindings"
  (interactive)
  ;;overwrite yas and company tab mappings
  (define-key yas-minor-mode-map (kbd "<tab>") #'tab-indent-or-complete)
  (define-key yas-minor-mode-map (kbd "TAB")   #'tab-indent-or-complete)
  (define-key company-active-map [tab]         #'tab-indent-or-complete)
  (define-key company-active-map (kbd "TAB")   #'tab-indent-or-complete))

(add-hook 'company-mode-hook 'bind-tab-properly)
#+end_src

#+begin_src emacs-lisp
    )                                   ; with-eval-after-load "company".
#+end_src

With the following text (where "|" stands for the cursor):

#+begin_example
GOODBYE
good|
#+end_example

- the prefix "good" will match no word (no completion to "goodBYE"!) while
- the prefix "GOOD" will match "GOODBYE" only.

**** Prog modes

In "code" modes (see ~company-dabbrev-code-modes~) and their derivatives, Company
will -- by default -- complete only symbols, not text in comments or strings.

#+begin_src emacs-lisp
  ;; Dabbrev-like company-mode back-end for code.
  (with-eval-after-load "company-dabbrev-code"

    ;; ;; Search all other buffers
    ;; (setq company-dabbrev-code-other-buffers 'all)

    ;; Offer completions in comments and strings.
    (setq company-dabbrev-code-everywhere t)

    ;; ;; Ignore case when collecting completion candidates.
    ;; (setq company-dabbrev-code-ignore-case t)

    (when (locate-library "web-mode")
      (add-to-list 'company-dabbrev-code-modes 'web-mode))
    )
#+end_src

Problem:
Company: backend (company-dabbrev-code company-gtags company-etags
company-keywords) user-error: File /cygdrive/d/Users/fni/TAGS does not exist

Use command ~company-diag~ in bug reports.

**** Company-yasnippet

In a JS file, type ~al~, and see ~al -> alert~ in the Company popup. TAB'ing on that
entry will insert the code template!

#+begin_warning
The ~company-yasnippet~ backend should be used with care, because as long as there
are snippets defined for the current major mode, this backend will always shadow
backends that come after it.
#+end_warning

#+begin_src emacs-lisp
  (add-hook 'js2-mode-hook
            #'(lambda ()
                (set (make-local-variable 'company-backends)
                     '((company-dabbrev-code company-yasnippet)))))
#+end_src

#+begin_note
~company-backends~ is a variable defined in ~company.el~.

Documentation: The list of active back-ends (completion engines).

*Only one back-end is used at a time.* The choice depends on the order of the
items in this list, and on the values they return in response to the 'prefix'
command (see below). *But a back-end can also be a "grouped" one (see below).*

Grouped back-ends:

An element of ~company-backends~ can also itself be a list of back-ends, then it's
considered to be a "grouped" back-end.

When possible, commands taking a candidate as an argument are dispatched to the
back-end it came from. In other cases, the first non-nil value among all the
back-ends is returned.

The latter is the case for the ~prefix~ command. But if the group contains the
keyword ~:with~, the back-ends after it are ignored for this command.

The completions from back-ends in a group are merged (but only from those that
return the same ~prefix~).
#+end_note

**** Tern

- http://stackoverflow.com/questions/18102833/could-not-start-tern-server-in-emacs?rq=1
- https://github.com/syl20bnr/spacemacs/issues/5733
- https://github.com/ternjs/tern/issues/256
- https://github.com/angelozerr/tern.java/wiki/Tern-Eclipse-IDE
- https://github.com/angelozerr/tern.java/wiki/Getting-Started
- http://emmet.io/blog/sublime-tern/
- http://emacs.stackexchange.com/questions/3093/how-to-navigate-a-javascript-project
- https://truongtx.me/2014/04/20/emacs-javascript-completion-and-refactoring

Installing https://github.com/angelozerr/tern.java/wiki/Installation-Update-Site.

https://nodejs.org/download/release/latest/win-x64/

**** Text modes

In the other modes, Company will pass control to other back-ends
(e.g. ~company-dabbrev~).

#+begin_src emacs-lisp
  ;; Dabbrev-like company-mode completion back-end.
  (with-eval-after-load "company-dabbrev"

    ;; Only search in the current buffer
    (setq company-dabbrev-other-buffers nil) ; Prevent Company completing
                                             ; numbers coming from other files.

    ;; Don't ignore case when collecting completion candidates.
    (setq company-dabbrev-ignore-case nil)

    ;; Don't downcase the returned candidates.
    (setq company-dabbrev-downcase nil)
    ;; Fix problem with lowercased completions in comments and strings, in many
    ;; programming modes.

    ;; Skip invisible text (Org drawers, etc.).
    (setq company-dabbrev-ignore-invisible t))
#+end_src

XXX What about ~company-search-candidates~ vs ~company-filter-candidates~?

**** Company-quickhelp frontend

#+begin_src emacs-lisp
  (with-eval-after-load "company-quickhelp-autoloads"

    ;; Enable `company-quickhelp-mode'.
    (company-quickhelp-mode 1)

    ;; ;; Delay to show quick help.
    ;; (setq company-quickhelp-delay 0.5)

    ;; Maximum number of lines to show in the popup.
    (setq company-quickhelp-max-lines 10))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 29 ends here.
#+end_src

* Dired, the Directory Editor

#+begin_src emacs-lisp
;;* 30 (info "(emacs)Dired"), the Directory Editor

(leuven--chapter leuven-load-chapter-30-dired "30 Dired, the Directory Editor"
#+end_src

** Entering Dired

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Enter")

  ;; Directory-browsing commands.
  (with-eval-after-load "dired"

    (leuven--section "30.1 (emacs)Dired Enter")
#+end_src

#+begin_note
[[id:26d881f0-0f56-4259-9b31-eb4fecb08c88][ls-lisp]], Emacs's own *emulation of ~ls~* is used by *default on MS Windows* (which
does not have an ~ls~ program).  Though, it does not support as many options as
GNU ~ls~.
#+end_note

#+begin_src emacs-lisp
    ;; Switches passed to `ls' for Dired.
    (setq dired-listing-switches "-alF")
#+end_src

** Emulation of ~ls~ on MS-Windows
:PROPERTIES:
:ID:       26d881f0-0f56-4259-9b31-eb4fecb08c88
:END:

Use Emacs's own emulation of ~ls~ in all versions of Emacs.

#+begin_src emacs-lisp
;;** (info "(emacs)ls in Lisp")

    (leuven--section "G.4 (emacs)ls in Lisp")

    ;; Emulate insert-directory completely in Emacs Lisp.
    (when (require 'ls-lisp)

      ;; Disable the case sensitive sort of file names.
      (setq ls-lisp-ignore-case t)

      ;; Sort directories first.
      (setq ls-lisp-dirs-first t)

      ;; Use `ls-lisp' in all versions of Emacs (for Dired sorting to work OK!).
      (setq ls-lisp-use-insert-directory-program nil)
                                        ; [Default: nil for Windows, t otherwise]

      ;; Use ISO 8601 dates.
      (setq ls-lisp-format-time-list
            '("%Y-%m-%d %H:%M"
              "%Y-%m-%d %H:%M"))

      ;; Use localized date/time format.
      (setq ls-lisp-use-localized-time-format t))
#+end_src

** Navigation in the Dired Buffer

In Dired, ~M->~ and ~M-<~ never took me where I wanted to go.  Now, they do.

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Navigation")

    (leuven--section "30.2 (emacs)Dired Navigation")

    (defun dired-back-to-top ()
      (interactive)
      (goto-char (point-min))
      (dired-next-line 4))

    (define-key dired-mode-map [remap beginning-of-buffer] #'dired-back-to-top)

    (defun dired-jump-to-bottom ()
      (interactive)
      (goto-char (point-max))
      (dired-next-line -1))

    (define-key dired-mode-map [remap end-of-buffer] #'dired-jump-to-bottom)
#+end_src

#+begin_src emacs-lisp
    ;; Search in filenames (instead of in everything).
    (define-key dired-mode-map (kbd "C-s") #'dired-isearch-filenames)
#+end_src

** Deleting Files with Dired

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Deletion")

    (leuven--section "30.3 (emacs)Dired Deletion")

    ;; Recursive deletes allowed, after asking for each directory at top level.
    (setq dired-recursive-deletes 'top)
#+end_src

** Visiting Files in Dired

- ~^~ ::
     ~dired-up-directory~.

- ~o~ ::
     Open the file or directory in *another window*.

- ~C-o~ ::
     Open the file but stay on Dired buffer.

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Visiting")

    (leuven--section "30.5 (emacs)Dired Visiting")
#+end_src

*** Open file with default tool (open directory with Windows Explorer)

On top of the traditional ways, there are also these add-ons which open files
using external programs (such as PDF viewers), based on their extension.

One advantage is that using the traditional ~!~ (or ~X~) switch with Dired locks up
Emacs until you close the other program.  These add-ons do not and leave Emacs
free for continued used.

#+begin_note
Alternative

Nowadays, there's at least the built-in ~dired-do-async-shell-command~, bound to
~&~.

In addition to what others have mentioned, if you are on MS Windows then, after
loading ~w32-browser.el~ and ~dired+.el~, you can use item ~Open Associated Windows
App~ in the ~Single~ menu to open a file with the associated program.

Same thing for the marked files, using ~Oepn Associated Windows Apps~ in menus
~Multiple~ and ~Multiple > Marked Here and Below~.

And you can use item ~Single > ~Open in Windows Explorer~ to open a file or folder
in Windows Explorer.

You can also right-click on a file and pick ~Open Associated Windows App~ or ~Open
in Windows Explorer~.

There are key bindings for these as wel:

- ~M-RET~ or ~mouse-2~ :: open with associated proram
- ~C-RET~ :: open in Explorer
#+end_note

*************** TODO Read http://www.piprime.fr/1302/plus-qu-un-explorateur-de-fichiers-le-mode-dired-d-emacs/

These days, there are mature programs for launching an arbitrary file with an
appropriate viewer:

- ~xdg-open~ on GNU systems,

- ~open~ on Mac OS X,

  If ~xdg-open~ is not available, one can replace it with ~gnome-open~ or ~kde-open~.

- ~start~ on MS Windows.

  Though, it is a bad idea to use ~start~ on Windows: it has too many quirks
  regarding quoting of its command line.  Instead, just invoke the existing
  primitive ~w32-shell-execute~ with the ~open~ verb.  As a nice side effect, this
  will support Unicode file names, something that is currently impossible when
  you invoke an external command.

#+begin_src emacs-lisp :tangle no
    (defun helm-open-file-with-default-tool (file)
      "Open FILE with the default tool on this platform."
      (let ((program (cond (leuven--linux-p "xdg-open")
                           (leuven--mac-p "open")))
            process-connect-type)
        (if leuven--win32-p
            (helm-w32-shell-execute-open-file file)
          (start-process "helm-open-file-with-default-tool" nil program file))))
#+end_src

#+begin_src emacs-lisp :tangle no
    (defun dired-open ()
      (interactive)
      (let ((program (cond (leuven--linux-p "xdg-open")
                           (leuven--mac-p "open"))))
        (dired-do-shell-command program nil
                                (dired-get-marked-files t current-prefix-arg))))

    (define-key dired-mode-map (kbd "F") #'dired-open)
#+end_src

Reveal active file in Explorer:

#+begin_src emacs-lisp
    (defun browse-file-directory ()
      "Open the current file's directory however the OS would."
      (interactive)
      (if default-directory
          (browse-url-of-file (expand-file-name default-directory))
        (error "No `default-directory' to open")))

    (global-set-key (kbd "C-c r") #'browse-file-directory)
#+end_src

**** Ask a WWW browser to display file

Just ask a WWW browser to display the current file.

#+begin_src emacs-lisp
    ;; In Dired, ask a WWW browser to display the file named on this line.
    (define-key dired-mode-map (kbd "e") #'browse-url-of-dired-file) ; <C-RET>?

#+end_src

It works for files as well as for directories.

It opens the Windows Explorer for:

- the *current directory* when invoked on ~.~, and
- the *parent directory* when invoked on ~..~.

*************** TODO Mapcar on the browse-url function
See code of ~w32-dired-open-files-externally~.
*************** END

*************** TODO ~C-u RET~ opens dired on Org link
We should probably have the same type of key binding for opening Explorer from
Dired.
*************** END

**** MANY FILES at once (for Windows)

For those under Windows:

#+begin_src emacs-lisp
    ;; Open files using Windows associations.
    (when (or leuven--win32-p
              leuven--cygwin-p)
      (defun w32-dired-open-files-externally (&optional arg)
        "In Dired, open the marked files (or directories) with the default
      Windows tool."
        (interactive "P")
        (mapcar
         #'(lambda (file)
             (w32-shell-execute "open" (convert-standard-filename file)))
         (dired-get-marked-files nil arg)))

      ;; ;; Bind it to `E' in Dired mode.
      ;; (define-key dired-mode-map (kbd "E") #'w32-dired-open-files-externally)
      )
#+end_src

**** ARCHIBUS

#+begin_src emacs-lisp
    (with-eval-after-load "dired"
      (define-key dired-mode-map (kbd "C-c v")
         #'(lambda ()
             "Ask a WWW browser to load ARCHIBUS View file."
             (interactive)
             (let ((archibus-prefix "http://localhost:8080/archibus/"))
               (browse-url (concat archibus-prefix (dired-get-filename 'no-dir t)))))))
#+end_src

*** Open file with ~eww~

#+begin_src emacs-lisp
    ;; Open current file with eww.
    (defun dired-open-with-eww ()
      "In Dired, visit (with eww) the file named on this line."
      (interactive)
      (eww-open-file (file-name-sans-versions (dired-get-filename) t)))

    ;; Add a binding "W" -> `dired-open-with-eww' to Dired.
    (define-key dired-mode-map (kbd "W") #'dired-open-with-eww)
#+end_src

** Operating on Files

#+begin_src emacs-lisp
;;** (info "(emacs)Operating on Files")

    (leuven--section "30.7 (emacs)Operating on Files")

    ;; Try to guess a default target directory (if there is a Dired buffer
    ;; displayed in the next window).
    (setq dired-dwim-target t)

    ;; Copy recursively without asking.
    (setq dired-recursive-copies 'always)
#+end_src

** Updating the Dired Buffer

#+begin_warning
The following code block is currently disabled, because it causes problems with
Org and PDF LaTeX: when we've opened the TeX file, to compile it from LaTeX
because an error has been reported (with no details), then the TeX file blocks
the next automatic exports (~C-u C-c C-e~), asking for confirmation because the
TeX buffer is open...

#+begin_example
Reverting buffer `prestations/'.
prestations-2013-06.tex changed on disk; really edit the buffer? (y, n, r or C-h) n
#+end_example
#+end_warning

#+begin_src emacs-lisp :tangle no
    (add-hook 'dired-mode-hook
              #'(lambda ()
                  ;; Auto-refresh Dired on file change.
                  (auto-revert-mode)))
#+end_src

Maybe the following fixes this above problem?

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Updating")

    (leuven--section "30.15 (emacs)Dired Updating")

    ;; Automatically revert Dired buffer *on revisiting*.
    (setq dired-auto-revert-buffer t)
#+end_src

Press ~s~ then ~s~, ~x~, ~t~, ~n~ or ~d~ to sort by Size, eXtension, *Time*, *Name* or name
grouping Dirs first:

#+begin_src emacs-lisp
    ;; Dired sort.
    (try-require 'dired-sort-map)
#+end_src

** Dired and ~find~

For searches in Dired, see ~dired-do-search~ (~A~).
- Search through all *marked files* for a match for regexp
- Stops when a match is found
- To continue searching for next match, use command "M-,"

#+begin_src emacs-lisp
;;** (info "(emacs)Dired and Find")

    (leuven--section "30.16 (emacs)Dired and Find")
#+end_src

#+begin_src emacs-lisp :tangle no
    ;; ;; What to use in place of `-ls' as the final argument.
    ;; (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
    ;; ;; Quicker to collate the matches and then use `xargs' to run the command
    ;; ;; (variable defined in `find-dired.el').
#+end_src

#+begin_src emacs-lisp
    ;; Search for files with names matching a wild card pattern and Dired the
    ;; output.
    (global-set-key (kbd "C-c 1") #'find-name-dired)
                                        ; Case insensitive if
                                        ; `read-file-name-completion-ignore-case'
                                        ; is non-nil.

    ;; `find-grep-dired' case insensitivity.
    (setq find-grep-options "-i -q")

    ;; Search for files with contents matching a wild card pattern and Dired the
    ;; output.
    (global-set-key (kbd "C-c 2") #'find-grep-dired)
#+end_src

** Editing the Dired Buffer

~Wdired~ mode is *great for renaming (a lot of) files* in a directory, as it allows
*editing the Dired buffer* like a text file, using all the power of Emacs.  That
is, one can use keyboard macros, search and replace, rectangle mode (great for
adding prefixes to file names), flip mode bits with the mouse, etc.!

To enter it, type ~C-x C-q~.

#+begin_src emacs-lisp
;;** (info "(emacs)Wdired")

    (leuven--section "30.17 Editing the (emacs)Wdired Buffer")

    ;; Put a Dired buffer in a mode in which filenames are editable.
    (with-eval-after-load "wdired"

      ;; Permissions bits of the files are editable.
      (setq wdired-allow-to-change-permissions t))
#+end_src

** Viewing Image Thumbnails in Dired

~M-x image-dired~ and choose a directory with images.

Prerequisites:
- [[http://www.imagemagick.org.][ImageMagick]] package
- JpegTRAN program
- [[http://www.sno.phy.queensu.ca/~phil/exiftool/][exiftool]] to *edit comments and tags* for each image.

Key bindings:

- C-t d ::
     ~image-dired-display-thumbs~ (on marked files).

- C-t e ::
     ~image-dired-dired-edit-comment-and-tags~.

For more information, see:
- http://www.emacswiki.org/Tumme
- http://wikemacs.org/wiki/Image-dired

#+begin_src emacs-lisp
;;** (info "(emacs)Image-Dired")

    (leuven--section "30.18 Viewing Image Thumbnails in Dired")

    ;; Use Dired to browse and manipulate your images.
    (with-eval-after-load "image-dired"

      ;; Maximum number of files to show before warning the user.
      (setq image-dired-show-all-from-dir-max-files 100)

      ;; Size of button-like border around thumbnails.
      (setq image-dired-thumb-relief 0)

      ;; Size of the margin around thumbnails.
      (setq image-dired-thumb-margin 4))
#+end_src

** Other Dired features

To copy the *name* of the file at point (or the folder you're looking at in Dired)
into the kill ring (in order to make use of it elsewhere), use
~dired-copy-filename-as-kill~, which is bound to ~w~ in Dired.

#+begin_tip
Use ~0 w~ to put the *full path*.
#+end_tip

** Dired "extra" features

Extra Dired functionality:

- You can *jump to the Dired buffer* corresponding to the current buffer by
  pressing *~C-x C-j~* (~dired-jump~).  If in Dired already, pop up a level and goto
  old directory's line.

  *Standard* alternative: ~C-x d RET~, though it doesn't set point on the right
  file.

- ~dired-x~ also has a feature to "guess" the right shell command and the right
  external viewer for documents (see ~dired-guess-shell-alist-user~)

#+begin_src emacs-lisp
;;** Dired Extra

    (leuven--section "30.XX (dired-x)Top")

    (require 'dired-x)                  ; with-eval-after-load "dired" ends here.


    (defadvice dired-jump (around leuven-dired-jump activate)
      "Ask for confirmation for buffers of 1,400,000 bytes or more."
      (when (or (< (buffer-size) 1400000)
                (y-or-n-p "Are you sure you want to do this? (This may take time...) "))
        ad-do-it))
    )
#+end_src

** Dired+

Extensions to Dired:

- Provide fancy *highlighting*.

- Let you act on sets of marked files in subdirs, recursively, for example.

There are global key bindings that Dired+ makes:

- ~C-x D~ :: ~diredp-dired-union~
- ~C-x E~ :: ~diredp-add-to-dired-buffer~
- ~C-x C-M-f~ :: ~diredp-fileset~
- ~C-x R~ :: ~diredp-dired-recent-dirs~

These are not bindings for Dired mode.  They are global bindings that set up
a Dired buffer.  They are thus similar to the default global bindings ~C-x d~ and
~C-x C-j~.

#+begin_src emacs-lisp
;;** Dired+

  (leuven--section "30.XX Dired+")

  (when (try-require 'dired+) ; XXX

    ;; Don't hide details in Dired.
    (setq diredp-hide-details-initially-flag nil)

    ;; Don't display the next Dired buffer the same way as the last.
    (setq diredp-hide-details-propagate-flag nil)

    ;; Don't wrap "next" command around to buffer beginning.
    (setq diredp-wrap-around-flag nil)

    ;; Dired `find-file' commands reuse directories.
    (diredp-toggle-find-file-reuse-dir 1)

    ;; Up, reusing Dired buffers.
    (define-key dired-mode-map (kbd "C-x C-j")
      #'diredp-up-directory-reuse-dir-buffer))
#+end_src

** VC diff highlighting

Like Git-gutter, Diff-hl shows you *which lines were modified compared to the
latest commit* -- it supports SVN, Git, and other VC systems!

#+begin_src emacs-lisp
;;** Diff-hl

  (leuven--section "30.XX Diff-hl")

  ;; Enable VC diff highlighting on the side of a Dired window.
  (with-eval-after-load "diff-hl-autoloads"
    (add-hook 'dired-mode-hook #'diff-hl-dired-mode))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 30 ends here.
#+end_src

* The Calendar and the Diary

#+begin_src emacs-lisp
;;* 31 The (info "(emacs)Calendar/Diary")

(leuven--chapter leuven-load-chapter-31-calendar-diary "31 The Calendar and the Diary"
#+end_src

** Calendar Motion

#+begin_src emacs-lisp
;;** 31.1 (info "(emacs)Calendar Motion")

  (leuven--section "31.1 (emacs)Calendar Motion")

  ;; Years must be written in full.
  (setq diary-abbreviated-year-flag nil)

  ;; Set the style of calendar and diary dates to ISO (how to interpret the
  ;; dates).
  (setq calendar-date-style 'iso)

  ;; Week in the calendar begins on Monday.
  (setq calendar-week-start-day 1)

  ;; Mark all visible dates that have diary entries.
  (when (file-exists-p "~/diary")
    (setq calendar-mark-diary-entries-flag t))

  ;; Mark the current date (by changing its face) after generating a calendar,
  ;; if today's date is visible.
  (add-hook 'calendar-today-visible-hook #'calendar-mark-today)
#+end_src

** Scroll Calendar

#+begin_src emacs-lisp
;;** 31.2 (info "(emacs)Scroll Calendar")

  (leuven--section "31.2 (emacs)Scroll Calendar")

  ;; Fix foolish calendar-mode scrolling after loading `calendar.el'.
  (add-hook 'calendar-load-hook
            #'(lambda ()
                (define-key calendar-mode-map (kbd ">") #'calendar-scroll-left)
                (define-key calendar-mode-map (kbd "<") #'calendar-scroll-right)))
#+end_src

** Times of Sunrise/Sunset

#+begin_src emacs-lisp
;;** 31.7 Times of (info "(emacs)Sunrise/Sunset")

  (leuven--section "31.7 Times of (emacs)Sunrise/Sunset")

  ;; ;; Calendar functions for solar events.
  ;; (with-eval-after-load "solar"
  ;;
  ;;   ;; Name of the calendar location.
  ;;   (setq calendar-location-name "Leuven, BE")
  ;;
  ;;   ;; Latitude of `calendar-location-name'.
  ;;   (setq calendar-latitude 50.88)
  ;;
  ;;   ;; Longitude of `calendar-location-name'.
  ;;   (setq calendar-longitude 4.70))
#+end_src

** Diary

The Emacs diary keeps track of appointments or other events on a daily basis, in
conjunction with the calendar.  To use the diary feature, you must first create
a "diary file" containing a list of events and their dates.

But [[id:737b836b-ac1f-4120-94ca-c9e0282268f0][Org]] outperforms it!

** Appointments

#+begin_src emacs-lisp
;;** 31.11 (info "(emacs)Appointments")

  (leuven--section "31.11 (emacs)Appointments")

  ;; Insinuate appt if `diary-file' exists.
  (if (file-readable-p "~/diary")
      (try-require 'appt)               ; Requires `diary-lib', which requires
                                        ; `diary-loaddefs'.
    (message "[Appointment reminders lib `appt' not loaded (no diary file found)]"))

  (with-eval-after-load "appt"

    ;; Send the first warning 60 minutes before an appointment.
    (setq appt-message-warning-time 60) ; [default: 12]

    ;; Warn every 15 minutes.
    (setq appt-display-interval 15)     ; [default: 3]
#+end_src

Send notifications using ~notifications-notify~ (which was added in Emacs 24).
It uses ~notify-send~ (if the ~libnotify-bin~ Ubuntu package is installed).

*************** TODO For Windows users: use `todochicku.el' (cross-platform?) and the snarl notifier

Or better look at the ~alert~ package?

*************** TODO Diff between shell-command and call-process?  Blocking call?

#+begin_src emacs-lisp
    ;; Use a separate window to display appointment reminders.
    (setq appt-display-format 'window)

    ;; Function called to display appointment reminders *in a window*.
    (setq appt-disp-window-function (function leuven--appt-display))

    (defun leuven--appt-display (mins-to-appt current-time notification-string)
      "Display a reminder for appointments.
    Use `libnotify' if available and if display is graphical, or fall back on a
    message in the echo area."
      (or (listp mins-to-appt)
          (setq notification-string (list notification-string)))
      (dotimes (i (length notification-string))
        (cond ((and (display-graphic-p)
                    (executable-find "notify-send"))
               (shell-command
                (concat "notify-send "
                        "-i /usr/share/icons/gnome/32x32/status/appointment-soon.png "
                        "-t 1000 "
                        "'Appointment' "
                        "'" (nth i notification-string) "'")))
              (t
               (message "[%s]" (nth i notification-string))
               (sit-for 1)))))
#+end_src

#+begin_src emacs-lisp
    ;; Turn appointment checking on (enable reminders).
    (when leuven-verbose-loading
      (message "[Enable appointment reminders...]"))
    (appt-activate 1)
    (when leuven-verbose-loading
      (message "[Enable appointment reminders... Done]"))
#+end_src

#+begin_src emacs-lisp
    ;; Enable appointment notification, several minutes beforehand.
    (add-hook 'diary-hook #'appt-make-list)
#+end_src

#+begin_src emacs-lisp
    (with-eval-after-load "org-agenda"

      ;; Keep your appointment list clean: if you delete an appointment from
      ;; your Org agenda file, delete the corresponding alert.
      (defadvice org-agenda-to-appt (before leuven-org-agenda-to-appt activate)
        "Clear the existing `appt-time-msg-list'."
        (setq appt-time-msg-list nil))

      ;; Add today's appointments (found in `org-agenda-files') each time the
      ;; agenda buffer is (re)built.
      (add-hook 'org-agenda-finalize-hook #'org-agenda-to-appt)
                                          ;! Don't use the `org-agenda-mode-hook'
                                          ;! because the Org agenda files would be
                                          ;! opened once by `org-agenda-to-appt',
                                          ;! and then killed by
                                          ;! `org-release-buffers' (because
                                          ;! `org-agenda-to-appt' closes all the
                                          ;! files it opened itself -- as they
                                          ;! weren't already opened), to be
                                          ;! finally re-opened!
      )
#+end_src

#+begin_src emacs-lisp
    )                                   ; with-eval-after-load "appt" ends here.
#+end_src

** Advanced Calendar/Diary Usage

#+begin_src emacs-lisp
;;** 31.15 (info "(emacs)Advanced Calendar/Diary Usage")

  (leuven--section "31.15 (emacs)Advanced Calendar/Diary Usage")

  ;; Get rid of some holidays.
  (setq holiday-general-holidays nil)   ; Too U.S.-centric holidays.
  (setq holiday-oriental-holidays nil)  ; Oriental holidays.
  (setq holiday-hebrew-holidays nil)    ; Religious holidays.
  (setq holiday-islamic-holidays nil)   ; Religious holidays.
  (setq holiday-bahai-holidays nil)     ; Baha'i holidays.
  (setq holiday-solar-holidays nil)     ; Sun-related holidays.

  ;; Mark dates of holidays in the calendar window.
  (setq calendar-mark-holidays-flag t)
#+end_src

After the calendar is loaded, ~calendar-holidays~ is the list of notable days for
the command ~M-x holidays~.

#+begin_src emacs-lisp
  (defun leuven-insert-current-date (prefix)
    "Insert the current date in ISO format.
  With one PREFIX argument, add day of week.  With two PREFIX arguments, add day
  of week and time."
    (interactive "P")
    (let ((format (cond ((not prefix) "%Y-%m-%d")
                        ((equal prefix '(4)) "%Y-%m-%d %a")
                        ((equal prefix '(16)) "%Y-%m-%d %a %H:%M"))))
      (insert (format-time-string format))))

  (global-set-key (kbd "C-c .") #'leuven-insert-current-date)
#+end_src

** Calendar framework

After displaying your ~calfw~ buffer, you can get a HTML buffer with ~M-x
htmlfontify-buffer~.

#+begin_warning
~Calfw~ requires ~Google-maps~!?
#+end_warning

#+begin_src emacs-lisp
;;* Calendar view framework on Emacs

  ;; Calendar view framework on Emacs.
  (with-eval-after-load "calfw"

    ;; Unicode characters.
    (setq cfw:fchar-junction ?
          cfw:fchar-vertical-line ?
          cfw:fchar-horizontal-line ?
          cfw:fchar-left-junction ?
          cfw:fchar-right-junction ?
          cfw:fchar-top-junction ?
          cfw:fchar-top-left-corner ?
          cfw:fchar-top-right-corner ?))

  ;; Calendar view for org-agenda.
  (with-eval-after-load "calfw-org"

    ;; Remove some strings (tags and filenames) from item summary.
    (defun cfw:org-summary-format (item)
      "Format an item (How should it be displayed?)."
      (let* ((time (cfw:org-tp item 'time))
             (time-of-day (cfw:org-tp item 'time-of-day))
             (time-str (and time-of-day
                            (format "%02i:%02i "
                                    (/ time-of-day 100)
                                    (% time-of-day 100))))
             (category (cfw:org-tp item 'org-category))
             (tags (cfw:org-tp item 'tags))
             (marker (cfw:org-tp item 'org-marker))
             (buffer (and marker (marker-buffer marker)))
             (text (cfw:org-extract-summary item))
             (props (cfw:extract-text-props item 'face 'keymap)))
        (propertize
         (concat
          (if time-str (apply 'propertize time-str props)) text " "
          ;; (and buffer (buffer-name buffer))
          )
         'keymap cfw:org-text-keymap
         ;; Delete the display property, since displaying images will break our
         ;; table layout.
         'display nil))))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 31 ends here.
#+end_src

* Sending Mail

Minimal configuration for sending a bug report, for example.

#+begin_src emacs-lisp
;;* 32 (info "(emacs)Sending Mail")

(leuven--chapter leuven-load-chapter-32-sending-mail "32 Sending Mail"

  ;; Full name of this user.
  (setq user-full-name "John Doe")

  ;; Full mailing address of this user
  ;; (used in MAIL envelope FROM, and to select the default personality ID).
  (setq user-mail-address "john.doe@example.com")

  ;; Sending mail.
  (setq send-mail-function 'smtpmail-send-it)

  ;; Default SMTP server (overriden by `smtpmail-smtp-server').
  (setq smtpmail-default-smtp-server "smtp")
                                        ; SMTP process must be running
                                        ; there... and it should be Google's own
                                        ; mail server for GMail user mail
                                        ; addresses...

  ;; ;; SMTP service port number.
  ;; (setq smtpmail-smtp-service 587)

)                                       ; Chapter 32 ends here.
#+end_src

* Gnus

#+begin_src emacs-lisp
;;* 34 (info "(emacs)Gnus")

(leuven--chapter leuven-load-chapter-34-gnus "34 Gnus"

  (global-set-key (kbd "C-c n")
    #'(lambda ()
        (interactive)
        (switch-or-start 'gnus "*Group*")))

  ;; Directory beneath which additional per-user Gnus-specific files are placed.
  (setq gnus-directory "~/.gnus.d/")    ; Should end with a directory separator.

  ;; A newsreader for GNU Emacs.
  (with-eval-after-load "gnus"

    ;; Package to compose an outgoing mail (Message, with Gnus paraphernalia).
    (setq mail-user-agent 'gnus-user-agent)

    ;; Reading mail with Gnus.
    (setq read-mail-command 'gnus))

)                                       ; Chapter 34 ends here.
#+end_src

* Document Viewing

If ~doc-view~ is not showing the PDF files as images in Emacs, it may be
because:

- no PNG support is available in Emacs (see [[id:9432da83-fa9d-4466-a4da-57f33d662bbd][Images]]), or
- some conversion utility for PDF files (Ghostscript) is not on your ~PATH~.

In that case, ~doc-view~ falls back to show you the plain text contents of the PDF
if ~doc-view-pdftotext-program~ is on your ~PATH~.

#+begin_src emacs-lisp
;;* 36 (info "(emacs)Document View")

(leuven--chapter leuven-load-chapter-36-document-view "36 Document Viewing"

  ;; View PDF/PostScript/DVI files in Emacs.
#+end_src

#+begin_verse
From Tassilo Horn:

>> https://github.com/politza/pdf-tools (available through MELPA).
>
> Oh, that looks pretty impressive.  I haven't used it, though, so I
> cannot help with this.

Ok, now I had to check it out, and Andreas, it's a really superb
package.  I'm gonna use that now for reading PDF files instead of
doc-view (where I'm the author) and Evince (which I use due to
doc-view's limitations).

But Troy is correct.  The PDF he links makes emacs freeze, although I've
been able to recover by hitting `C-g' repeatedly.  The result was that
the raw PDF data was shown.

Before I had opened that file successfully with doc-view and then did
M-x pdf-view-mode.  That worked.  When doing it that way, it seems some
if not all of PDF Tools minor modes aren't active, so I guess one of
them does something that triggers the freeze.

Andreas, do you plan to propose PDF Tools for inclusion in Emacs?  IMO,
that's really a package anybody's gonna love.  (Oh my god, how well the
syntex stuff/AUCTeX integration works!)
#+end_verse

PDF Tools (~pdf-view-mode~) is a major mode for viewing PDFs in Emacs similar (but
much more advanced) than ~doc-view-mode~.

It offers many features:
- highlighting search,
- highlighting selection,
- annotate,
- content tree.

It's the best PDF viewer on GNU/Linux (including the ones not running in Emacs).

#+begin_src emacs-lisp :tangle no
  (when (and leuven--linux-p
             (not (executable-find "epdfinfo")))
    (with-eval-after-load "pdf-tools-autoloads"
      (pdf-tools-install)))
#+end_src

** Navigation

~doc-view~ integrates with the usual bookmark facility.  So, simply use ~C-x r m~
(~bookmark-set~) to jump back to the last page you've read in a PDF document.

** Conversion

In ~doc-view-mode~, you can use ~C-s~ to do regexp search on the page images.

In addition, by pressing ~C-c C-t~, you can open the *text*-only representation
(actually, the output of the command ~pdftotext~) of the current doc in a new
buffer, which is more suitable for heavy manipulation of the text of the PDF.

Another option, without ~doc-view~, is ~! pdtotext ? - RET~.

~doc-view-enlarge~ (~+~) and ~doc-view-shrink~ (~-~) work fine to zoom in or out.

#+begin_src emacs-lisp
)                                       ; Chapter 36 ends here.
#+end_src

* Web Browsing

** EWW (Emacs Web Browser)

~EWW~ is the new Web browser for Emacs.

See https://www.gnu.org/software/emacs/manual/html_node/eww/index.html.

~M-x eww~ asks EWW to browse a URL.

- ~&~ (~eww-browse-with-external-browser~) ::
     Open the Web page in an *external browser* (when JavaScript is needed or the
     "design" is just too bad).

- F (eww-toggle-fonts) ::
     Toggle whether to use variable-pitch fonts or not.  The user can also
     customize the ~shr-use-fonts~ variable.

- R (eww-readable) ::
     Try do identify the *main textual parts of a web page* and *display only* that,
     leaving menus and the like off the page.

- D (eww-toggle-paragraph-direction) ::
     Toggle the paragraph direction between left-to-right and right-to-left.

- S ::
     List all eww buffers, and allow managing them.

HTTPS pages with valid certificates have headers marked in green, while invalid
certificates are marked in red.

*************** TODO See package ~eww-lnum~ (or ~avy~?)
(define-key eww-mode-map (kbd "f") #'eww-lnum-follow)
(define-key eww-mode-map (kbd "F") #'eww-lnum-universal)
*************** END

* Running Shell Commands from Emacs

See customizations at http://snarfed.org/why_i_run_shells_inside_emacs.

#+begin_src emacs-lisp
;;* 38 Running (info "(emacs)Shell") Commands from Emacs

(leuven--chapter leuven-load-chapter-38-shell "38 Running Shell Commands from Emacs"
#+end_src

#+begin_src emacs-lisp
  ;; Transform shell names to what they really are.
  (with-eval-after-load "sh-script"

    (add-to-list 'sh-alias-alist '(sh . bash)))

  ;; ;; Use shell from Cygwin/MinGW.
  ;; (setq shell-file-name "bash")
  ;; (setenv "SHELL" "/bin/bash")
  ;; (setq explicit-bash-args '("-i")) ; --noediting added in Emacs 24.4
  ;; (setq explicit-sh-args '("-i"))
#+end_src

** Single Shell

~M-!~ (~shell-command~) reads a line of text using the minibuffer and executes it as
a shell command, in a subshell made just for that command.

~M-|~ (~shell-command-on-region~) passes the contents of the region as the standard
input to the shell command.  By prefixing it with ~C-u~, it deletes the old region
and *replaces* it with the output from the shell command.

#+begin_src emacs-lisp
;;** 38.1 Single Shell

  (leuven--section "38.1 Single Shell")

  ;; Force interactive behavior (to get my handy shell aliases).
  ;; FIXME Fix for Zsh (zsh:1: command not found: shopt)
  ;; (defadvice shell-command (before leuven-shell-command activate)
  ;;   (ad-set-arg 0
  ;;               (concat "source ~/.bashrc; shopt -s -q expand_aliases;\n "
  ;;                       (ad-get-arg 0))))

  ;; ;; For single shell commands (= "the" reference).
  ;; (setq shell-file-name                 ; Must be in the `PATH'.
  ;;       (or (ignore-errors
  ;;             (file-name-nondirectory (or (executable-find "zsh")
  ;;                                         (executable-find "bash")
  ;;                                         (executable-find "sh"))))
  ;;           (when leuven--win32-p "cmdproxy.exe")))
  ;;
  ;; ;; Use `shell-file-name' as the default shell.
  ;; (setenv "SHELL" shell-file-name)
  ;;
  ;; ;; Switch used to have the shell execute its command line argument.
  ;; (setq shell-command-switch "-c")      ; `/c' did not work with XEmacs.

  ;; Quote process arguments to ensure correct parsing on Windows.
  (setq w32-quote-process-args t)

  ;; ;; Workaround for Cygwin when 'shell-file-name' is 'bash'.
  ;; (setq null-device "/dev/null"))
#+end_src

The above assignments may *NOT* be done *in an eval-after-load* as those variables
are used by the (La)TeX modes (default + AUCTeX) among others.

** Interactive Subshell

To run a subshell interactively, type ~M-x shell~.  This creates (or reuses)
a buffer named ~*shell*~, and runs a shell subprocess with input coming from and
output going to that buffer.

#+begin_src emacs-lisp
;;** 38.2 Interactive Subshell

  (leuven--section "38.2 Interactive Subshell")

  ;; ;; For the interactive (sub)shell (and AUCTeX compilation?).
  ;; (setq explicit-shell-file-name shell-file-name)
#+end_src

** Shell Mode
:PROPERTIES:
:ID:       9e938c3d-3752-4c12-b3a8-cc12cdcdfd88
:END:

*** Entering commands and fixing mistakes

- ~RET~ ::
     *Execute* the *command (on* the *current line)*.

- ~C-c C-u~ ::
     *Delete input* (from the prompt) up to point (equivalent to ~C-u~ in Unix
     shells).

*** Completion of filenames

- ~M-?~ ::
     Display a list of possible completions for the filename at point.

*** Manipulating the output from the last command

# - ~C-c C-e~ ::
#      Move *last line of output* from your last command *to bottom of window*,
#      showing the maximum of the output.

- ~C-c C-r~ ::
     *Show output* from last command (move first line of output to top of window).

- ~C-c C-o~ ::
     *Delete output* (only) from last command.

*** Sending signals

- ~C-c C-c~ ::
     Interrupt current job (equivalent to ~C-c~ in Unix shells, ~BREAK~ signal).

- ~C-c C-z~ ::
     Suspend or stop current job (equivalent to ~C-z~ in Unix shells, ~STOP~
     signal).

- ~C-c C-d~ ::
     Send ~EOF~ character.

#+begin_src emacs-lisp
;;** 38.3 Shell Mode

  (leuven--section "38.3 Shell Mode")

  ;; General command-interpreter-in-a-buffer stuff (Shell, SQLi, Lisp, R,
  ;; Python, ...).
  ;; (try-require 'comint)
  ;; (with-eval-after-load "comint"

    ;; Comint prompt is read only.
    (setq comint-prompt-read-only t)    ; Text is read-only (in ESS)?

    ;; No duplicates in command history.
    (setq-default comint-input-ignoredups t)

    ;; Input to interpreter causes windows showing the buffer to scroll
    ;; (insert at the bottom).
    (setq-default comint-scroll-to-bottom-on-input t)

    ;; Output to interpreter causes windows showing the buffer to scroll
    ;; (add output at the bottom).
    (setq-default comint-move-point-for-output t)

    ;; Maximum size in lines for Comint buffers.
    (setq comint-buffer-maximum-size (* 5 1024))
                                        ; If the function
                                        ; `comint-truncate-buffer' is added to
                                        ; `comint-output-filter-functions'.

    ;; Strip `^M' characters.
    (add-to-list 'process-coding-system-alist
                 '("sh" . (undecided-dos . undecided-unix))) ; `es' process.
    (add-to-list 'process-coding-system-alist
                 '("bash" . (undecided-dos . undecided-unix)))
    (add-to-list 'process-coding-system-alist
                 '("zsh" . (undecided-dos . undecided-unix)))

    ;; Show completion list when ambiguous.
    (setq comint-completion-autolist t)

    (defun leuven-comint-clear-buffer ()
      "Clear the Comint buffer."
      (interactive)
      (let ((comint-buffer-maximum-size 0))
        (comint-truncate-buffer)))

    (with-eval-after-load "comint"
      (define-key comint-mode-map (kbd "C-c C-k") #'leuven-comint-clear-buffer))

;; )
#+end_src

*************** TODO Command Prompt Here in Emacs
See http://tsdh.wordpress.com/category/lisp/emacs-lisp/ to quickly open a Shell
bufffer from Emacs.
*************** END

** Shell Prompts

#+begin_src emacs-lisp
;;** 38.4 Shell Prompts

  (leuven--section "38.4 Shell Prompts")

  ;; Regexp to match prompts in the inferior shell.
  (setq shell-prompt-pattern "^[^#$%>\n]*[#$%>] *")

  ;; Regexp to recognize prompts in the inferior process.
;;   (setq comint-prompt-regexp shell-prompt-pattern) ; Used as well by SQLi!
                                        ;! Only used if the variable
                                        ;! `comint-use-prompt-regexp' is non-nil.
#+end_src

** Shell Command History

#+begin_src emacs-lisp
;;** 38.5 Shell Command History

  (leuven--section "38.5 Shell Command History")

  (with-eval-after-load "comint"

    ;; Rejects short commands.
    (setq comint-input-filter
      #'(lambda (str)
          (and (not (string-match "\\`\\s *\\'" str))
               (> (length str) 2))))    ; Ignore '!!' and kin.
#+end_src

*** Shell History Ring

- ~C-p~ (or ~<up>~) ::
     Fetch the next *earlier* command in the history (doesn't execute it).

- ~C-n~ (or ~<down>~) ::
     Fetch the next *later* command in the history (doesn't execute it).

- ~M-p~ (or ~<C-up>~) ::
     Fetch the next *earlier* command in the history matching the string typed so
     far (doesn't execute it).

- ~M-n~ (or ~<C-down>~) ::
     Fetch the next *later* command in the history matching the string typed so
     far (doesn't execute it).

- ~M-r~ ::
     Begin an incremental *regexp search of old commands*.

- ~C-c C-l~ ::
     Display the current buffer's *history* of shell commands.

#+begin_src emacs-lisp
    ;; Cycle backwards/forwards through input history.
    (define-key comint-mode-map
      (kbd "C-p") #'comint-previous-input) ; Shell.
    (define-key comint-mode-map
      (kbd "<up>") #'comint-previous-input) ; Shell + RStudio.
    (define-key comint-mode-map
      (kbd "C-n") #'comint-next-input)  ; Shell.
    (define-key comint-mode-map
      (kbd "<down>") #'comint-next-input) ; Shell + RStudio.

    ;; Search backwards/forwards through input history for match for current
    ;; input.
    (define-key comint-mode-map
      (kbd "M-p") #'comint-previous-matching-input-from-input) ; Shell.
    (define-key comint-mode-map
      (kbd "<C-up>") #'comint-previous-matching-input-from-input) ; RStudio.
    (define-key comint-mode-map
      (kbd "M-n") #'comint-next-matching-input-from-input) ; Shell.
    (define-key comint-mode-map
      (kbd "<C-down>") #'comint-next-matching-input-from-input) ; RStudio.

    (with-eval-after-load "helm-autoloads"
      ;; Use Helm to search `comint' history.
      (define-key comint-mode-map
        (kbd "C-c C-l") #'helm-comint-input-ring)))
#+end_src

*** Shell History Copying

Manipulating the transcript: Viewing older commands.

- ~C-c C-p~ ::
     Move point to *previous command prompt*.

- ~C-c C-n~ ::
     Move point to *next command prompt*.

** Directory Tracking

#+begin_src emacs-lisp
;;** 38.6 Directory Tracking

  (leuven--section "38.6 Directory Tracking")
#+end_src

*************** TODO Fix case when 2 Shell buffers are run in the same dir (same name error!)
apply: Buffer name `*shell d:/Users/fni/*' is in use
*************** END

#+begin_src emacs-lisp
  (defun leuven--rename-buffer-to-curdir (&optional _string)
    "Change Shell buffer's name to current directory."
    (rename-buffer (concat "*shell " default-directory "*")))

  (add-hook 'shell-mode-hook
            #'(lambda ()
                (leuven--rename-buffer-to-curdir)
                (add-hook 'comint-output-filter-functions
                          #'leuven--rename-buffer-to-curdir nil t)))
                                        ; Local to Shell comint.
#+end_src

** Options

#+begin_src emacs-lisp
;;** 38.7 Options

  (leuven--section "38.7 Options")

  ;; Disable command echoing.
  (setq-default comint-process-echoes t) ; for Linux (not needed for Cygwin)
#+end_src

*** Paging in Shell

If you ever tried to run a program like ~git~ under ~M-x shell~, you will have come
across the warning "terminal is not fully functional" followed by unusable
behavior.  This is because ~git~ sends its output through a pager (probably ~less~),
which requires a real [[id:d12c2e1e-8147-4b39-8128-aaa70fbf4657][terminal emulator]].

Setting the ~PAGER~ environment variable to =/bin/cat= (but only inside Emacs)
solves this problem:

#+begin_src emacs-lisp
  (setenv "PAGER" "/usr/bin/cat")
#+end_src

** Term Mode
:PROPERTIES:
:ID:       d12c2e1e-8147-4b39-8128-aaa70fbf4657
:END:

To run a subshell in a text *terminal emulator*, use ~M-x term~.  This creates (or
reuses) a buffer named ~*terminal*~, and runs a subshell with input coming from
your keyboard, and output going to that buffer.

The terminal emulator uses Term mode, which has two input modes.

- In "line mode", Term basically acts like [[id:9e938c3d-3752-4c12-b3a8-cc12cdcdfd88][Shell Mode]].

- In "char mode", each character is sent directly to the subshell, as terminal
  input; the sole exception is the terminal escape character, which by default
  is ~C-c~.

#+begin_note

From my experience, none of the terminal emulators in Emacs (~term~, ~ansi-term~,
~multi-term~) is supported under Windows.  It looks like the main reason is all of
them rely on low-level support for terminals (~stty~, etc.) which is not provided
by Windows.

Though, ~term~, ~ansi-term~, and ~multi-term~ do *work in Cygwin Emacs*.
#+end_note

#+begin_src emacs-lisp
;;** 38.9 Term Mode

  (leuven--section "38.9 Term Mode")
#+end_src

Emacs *Shell mode* doesn't support (all) terminal control codes, so ~less~ doesn't
work ("page-at-a-time" feature).

Shell mode buffers do not use PTYs (pseudo-terminals), so programs running in
such a buffer (the shell, the programs run by the shell, etc.) can't perform
character-at-a-time input.  Each line is typed in full and only sent when ~RET~
is pressed.  To see proof, run the ~tty~ command in a Shell mode buffer, and its
output will be ~not a tty~.

Note that it may seem that this is not true because you can perform command-line
editing with ~C-b~, ~C-f~, etc.  But this is only because ~shell-mode~ itself
simulates the typical command-line editing features of shells like Bash, Zsh,
etc. using Emacs own internal editing capabilities.

Anyway, you can:

- use ~isearch~ to search through the command output,
- copy stuff into the kill ring or
- use the rectangle functions.

Or you might just prefer the Emacs key bindings over the ones your shell offers.

On the other hand, *Term mode* provides a proper *terminal emulator* (though not as
good as the good old ~xterm~).  You must use it for applications that are
interactive with your terminal (such as the command ~top~).

#+begin_note
In Shell mode, use ~M-x proced~ instead of ~top~.
#+end_note

#+begin_note
~MPlayer~ commands do not work in the Emacs shell.  Use ~term~ for ~/~ and ~*~ to
decrease / increase volume.
#+end_note

You can *switch to line mode* (~C-c C-j~) when you need Term to /basically/ act like
a Shell mode buffer, and move around the buffer pretty much like anywhere else
in Emacs.  Copy / kill-ring commands, ~isearch~, etc. do work.

Then, you can use ~C-c C-k~ to *switch* back *to character mode*, the default, which
is like your normal *terminal* emulator except the escape key.

It's wrong to think that ~M-x term~ captures everything it seems (which would
defeat the purpose of running it inside Emacs):

- In the default character mode, ~C-c~ is the key prefix.
- In line mode, you don't need a prefix.

Try also to use ~M-x ansi-term~ (Emacs terminal that accepts the ANSI-terminal
escape sequences) that is much better than ~term~:
- with ~M-x term~, you can run *only one shell*;
- with ~M-x ansi-term~, you can start more than one (~*ansi-term*<2>~,
  ~*ansi-term*<3>~).

Note that ~TERM~ is different in both environments:
- In ~M-x shell~, ~TERM=emacs~
- In ~M-x term~,  ~TERM=eterm-color~

MultiTerm (http://www.emacswiki.org/emacs/MultiTerm) works much better than
shell or term.

"Multi-term on POSIX hosts has let me switch from using screen, with one Emacs
screen and lots of shell screens; to just using Emacs, with lots of terminals
inside it."

#+begin_src emacs-lisp
  ;; Managing multiple terminal buffers in Emacs
  ;; (and fixing some troubles of `term-mode': key bindings, etc.).

  ;; (with-eval-after-load "multi-term-autoloads"
  ;;
  ;;   ;; (global-set-key (kbd "C-c t") #'multi-term-next)
  ;;   (global-set-key (kbd "C-c T") #'multi-term)) ; Create a new one.

  (with-eval-after-load "multi-term"

    (setq multi-term-program shell-file-name))
#+end_src

*************** TODO Try /visual/ commands (like ~top~ or ~less~) in ~multi-term~

#+begin_src emacs-lisp
  ;; ;; Run an inferior shell, with I/O through buffer `*shell*'.
  ;; (global-set-key
  ;;   (kbd "C-c !")
  ;;   (cond (leuven--win32-p 'shell)
  ;;         (t 'term)))

  ;; Toggle to and from the `*shell*' buffer.
  (global-set-key (kbd "C-!")
    #'(lambda ()
        (interactive)
        (switch-or-start 'shell "*shell*")))
#+end_src

** Remote Host

#+begin_src emacs-lisp
;;** 38.10 Remote Host Shell

  (leuven--section "38.10 Remote Host Shell")

  ;; Load ssh.el file.
  (add-to-list 'same-window-regexps "^\\*ssh-.*\\*\\(\\|<[0-9]+>\\)")
  (autoload 'ssh "ssh"
    "Open a network login connection via `ssh'." t)
    ;; This is to run ESS remotely on another computer in my own Emacs, or just
    ;; plain old reading remote files.

  ;; See http://emacs.1067599.n5.nabble.com/SSH-inside-Emacs-td225528.html
  ;; - plink (with `dumb' terminal option?) as interactive shell
  ;; - ssh -t -t user@host
  ;; - Cygwin'ized Emacs
  ;; - MSYS (MinGW)
#+end_src

** Serial Terminal

Since GNU Emacs 23, there's now support for serial port access.  The new command
~serial-term~ starts an interactive terminal on a serial port.

** Helper for GNU Emacs on w32

Let Emacs, for example, find the program =/usr/bin/gunzip=.

*But ~cygwin-mount-activate~ causes problems (Emacs crashes or unable to connect)
when reading mail with Gnus...*

Those problems disappear as soon as we do ~cygwin-mount-deactivate~...

#+begin_src emacs-lisp :tangle no
  ;; Let Windows Emacs recognize Cygwin paths (e.g. /usr/local/lib).
  (when (and leuven--win32-p
             (executable-find "mount")) ; Cygwin bin directory found.

    (with-eval-after-load "cygwin-mount-autoloads"

      (autoload 'cygwin-mount-activate "cygwin-mount"
        "Activate cygwin-mount- and cygwin-style-handling." t)

      ;; (cygwin-mount-activate)           ; This is sometimes VERY SLOW!
      ))
#+end_src

See =w32-settings.el= for more!

** Helper for Cygwin Emacs

If you want the *backslashes* in the *Windows paths* returned by Everything to be
interpreted correctly, you should use ~windows-path~.

#+begin_src emacs-lisp
  ;; Let Cygwin Emacs recognize Windows paths (e.g. C:\Program Files\).
  (when leuven--cygwin-p

    (try-require 'windows-path)         ; Require cygwin-mount!

    (with-eval-after-load "windows-path"

      ;; Activate windows-path-style-handling.
      (windows-path-activate)))
#+end_src

** Proced

#+begin_src emacs-lisp
;;* Proced

  ;; ;; Start Proced in a similar manner to Dired.
  ;; (global-set-key (kbd "C-x p") #'proced) ; Conflict with Bkmp.

  (with-eval-after-load "proced"

    ;; Current sort scheme for Proced listing.
    (setq-default proced-sort 'start)

    ;; Display of Proced buffer as process tree.
    (setq-default proced-tree-flag t))
#+end_src

#+begin_src emacs-lisp
)
#+end_src

* Using Emacs Server

#+begin_note
The Emacs version you're using and the ~emacsclient~ version you're using must be
from the *same Emacs version*...  If the latter is not the cause of a refused
connection, re-try ~M-x server-start~ in Emacs.
#+end_note

~emacsclient~ is waiting for Emacs to tell it it's done editing that file.
That's important if you use ~emacsclient~ as your ~EDITOR~.  If you want
~emacsclient~ to return immediately, use the ~-n~ option.

Do you use ~emacsclient~ in terminals?  If not, just use parameter ~-c -n~, which
creates an X Window and doesn't wait for ~(server-edit)~.

#+begin_src emacs-lisp
;;* 39 (info "(emacs)Emacs Server")

(leuven--chapter leuven-load-chapter-39-emacs-server "39 Using Emacs as a Server"

  ;; Use Emacs as a server (with the `emacsclient' program).
  (unless noninteractive
    (idle-require 'server))             ; After init.

  (with-eval-after-load "server"

    ;; Test whether server is (definitely) running, avoiding the message of
    ;; "server-start" while opening another Emacs session.
    (or (equal (server-running-p) t)

        ;; Start the Emacs server.
        (server-start))                 ; ~ 0.20 s

    ;; Save file without confirmation before returning to the client.
    (defadvice server-edit (before save-buffer-if-needed activate)
      "Save current buffer before marking it as done."
      (when server-buffer-clients (save-buffer))))

)                                       ; Chapter 39 ends here.
#+end_src

Since GNU Emacs 23, there is also a ~--daemon~ flag to start the server in a
convenient way.

*************** TODO Understand the following:

#+begin_src emacs-lisp :tangle no
        ;; (add-hook 'server-done-hook
        ;;        #'(lambda ()
        ;;          (shell-command "screen -r -X select `cat ~/tmp/emacsclient-caller`")))
#+end_src

and see
http://blog.jr0cket.co.uk/2012/10/using-emacs-24-server-on-mac-osx-for.html
for ideas about having the right ~emacsclient~ used to connect to the Emacs
server.
*************** END

#+begin_note
You can use ~emacsclient~ with a different Emacs daemon. For example, you can
start your Git checkout Emacs binary and the local installation with:

: /path/to/git/checkout/src/emacs --daemon=git
: emacs --daemon=local

and use ~emacsclient -s git~ or ~emacsclient -s local~ to connect to the daemon you
want to use.
#+end_note

* Printing Hard Copies

You can print any buffer with ~C-u M-x ps-print-buffer-with-faces RET~.  Because
of the ~C-u~, it will prompt for a file to place the PostScript into.  You can
then convert PS to PDF, if so desired.

You can print without faces (i.e. no colour) with ~ps-print-buffer~.

You may wish to set ~ps-print-landscape~ to ~t~.

See ~(info "(emacs)Windows Printing")~ for several methods of correctly setting up
printing on Windows.

#+begin_src emacs-lisp
;;* 40 (info "(emacs)Printing")

(leuven--chapter leuven-load-chapter-40-printing "40 Printing Hard Copies"

  ;; Print Emacs buffer on line printer
  ;; for {lpr,print}-{buffer,region}.
  (with-eval-after-load "lpr"

    ;; Name of program for printing a file.
    (setq lpr-command (executable-find "enscript"))
                                    ; TODO Install `enscript'.

    ;; List of strings to pass as extra options for the printer program.
    (setq lpr-switches (list "--font=Courier8"
                             "--header-font=Courier10"
                             (format "--header=%s" (buffer-name))))

    ;; Name of a printer to which data is sent for printing.
    (setq printer-name t))

  (defun leuven-ps-print-buffer-with-faces-query ()
    "Query user before printing the buffer."
    (interactive)
    (when (y-or-n-p "Are you sure you want to print this buffer? ")
      (ps-print-buffer-with-faces)))

  ;; Generate and print a PostScript image of the buffer.
  (when leuven--win32-p
    ;; Override `Print Screen' globally used as a hotkey by Windows.
    (w32-register-hot-key (kbd "<snapshot>"))
    (global-set-key
      (kbd "<snapshot>") #'leuven-ps-print-buffer-with-faces-query))

  ;; Print text from the buffer as PostScript.
  (with-eval-after-load "ps-print"

    (defvar gsprint-program
      (concat leuven--windows-program-files-dir "Ghostgum/gsview/gsprint.exe")
      "Defines the Windows path to the gsview executable.")

    (leuven--file-exists-and-executable-p gsprint-program)

    (if (and gsprint-program
             (executable-find gsprint-program))

        (progn
          ;; Name of a local printer for printing PostScript files.
          (setq ps-printer-name t)      ; Adjusted to run Ghostscript.


          ;; Name of program for printing a PostScript file.
          (setq ps-lpr-command gsprint-program)
                                        ; Tell Emacs where Ghostscript print
                                        ; utility is located.

          ;; List of extra switches to pass to `ps-lpr-command'.
          (setq ps-lpr-switches '("-query")))
                                        ; Tell Ghostscript to query which
                                        ; printer to use.
                                        ; '("-q" "-dNOPAUSE" "-dBATCH" "-sDEVICE=mswinpr2")

      (setq ps-printer-name "//PRINT-SERVER/Brother HL-4150CDN") ; XXX
      (setq ps-lpr-command "")
      (setq ps-lpr-switches '("raw")))

    ;; (setq ps-error-handler-message 'system)

    ;; Size of paper to format for.
    (setq ps-paper-type 'a4)
    (setq ps-warn-paper-type nil)

    ;; Print in portrait mode.
    (setq ps-landscape-mode nil)

    ;; (setq ps-print-control-characters nil)

    ;; Number of columns.
    (setq ps-number-of-columns 1)

    (setq ps-left-margin 40)
    (setq ps-right-margin 56)
    (setq ps-bottom-margin 22)
    (setq ps-top-margin 32)

    ;; Page layout: Header [file-name     2001-06-18 Mon]
    (setq ps-print-header-frame nil)    ; No box around the header.
    ;; See http://www.emacswiki.org/emacs/PsPrintPackage-23.
    (setq ps-header-frame-alist '((fore-color . "#CCCCCC")))
    (setq ps-header-lines 1)
    (setq ps-header-font-family 'Helvetica)
    ;; (setq ps-header-font-size 11)
    (setq ps-header-title-font-size 11)
    (defun ps-time-stamp-yyyy-mm-dd-aaa ()
      "Return date as \"yyyy-MM-dd ddd\" (ISO 8601 date + day of week)."
      (format-time-string "%Y-%m-%d %a"))
    (setq ps-right-header '(ps-time-stamp-yyyy-mm-dd-aaa))

    ;; Page layout: Footer [                         n/m]
    (setq ps-footer-offset 14)
    (setq ps-footer-line-pad .50)
    (setq ps-print-footer t)
    (setq ps-print-footer-frame nil)    ; No box around the footer.
    (setq ps-footer-frame-alist '((fore-color . "#666666")))
    (setq ps-footer-lines 1)
    (setq ps-footer-font-family 'Helvetica)
    (setq ps-footer-font-size 8)
    (setq ps-left-footer nil)
    (setq ps-right-footer (list "/pagenumberstring load")) ; Page n of m.

    (setq ps-font-family 'Courier)      ; See `ps-font-info-database'.
                                        ; Legitimate values include Courier,
                                        ; Helvetica, NewCenturySchlbk, Palatino
                                        ; and Times.

    ;; Font size, in points, for ordinary text, when generating PostScript.
    (setq ps-font-size 9.1)

    ;; Specify if face background should be used.
    (setq ps-use-face-background t)

    ;; Specify line spacing, in points, for ordinary text.
    (setq ps-line-spacing 3))

)                                       ; Chapter 40 ends here.
#+end_src

* Sorting Text

#+begin_src emacs-lisp
;;* 41 (info "(emacs)Sorting") Text

(leuven--chapter leuven-load-chapter-41-sorting "41 Sorting Text"

  ;; Key binding.
  (global-set-key (kbd "C-c ^") #'sort-lines)

)                                       ; Chapter 41 ends here.
#+end_src

To *reverse the order of* the *lines* in the region, use ~M-x reverse-region~.

* Saving Emacs Sessions

*************** TODO Check that there is no extra ~/.saves directory!

Pick up where you left off.

#+begin_src emacs-lisp
;;* 44 (info "(emacs)Saving Emacs Sessions")

(leuven--chapter leuven-load-chapter-44-saving-emacs-sessions "44 Saving Emacs Sessions"

  ;; Remember cursor position.
  (if (version< emacs-version "25.0")

      (progn
        ;; Automatically save place in each file.
        (setq-default save-place t)     ; Default value for all buffers.

        ;; Name of the file that records `save-place-alist' value.
        (setq save-place-file "~/.emacs.d/places")

        (require 'saveplace))

    (save-place-mode 1))

)                                       ; Chapter 44 ends here.
#+end_src

* Hyperlinking and Navigation Features

#+begin_src emacs-lisp
;;* 46 (info "(emacs)Hyperlinking")

(leuven--chapter leuven-load-chapter-46-hyperlinking "46 Hyperlinking and Navigation Features"
#+end_src

** Following URLs

#+begin_src emacs-lisp
  ;; Use proxy.
  (setq url-proxy-services              ;! Emacs expects just hostname and port
                                        ;! in `url-proxy-services', NOT prefixed
                                        ;! with "http://"
        `(("http"     . ,(getenv "http_proxy"))
          ("ftp"      . ,(getenv "http_proxy"))
          ("no_proxy" . "^.*example.com")))
          ;; Disable proxy for some hosts.
#+end_src

#+begin_src emacs-lisp
;;** Pass a URL to a WWW browser.

  (leuven--section "pass a URL to a WWW browser")

  ;; Default browser started when you click on some URL in the buffer.
  (setq browse-url-browser-function
        (cond ((or leuven--win32-p
                   leuven--cygwin-p)
               'browse-url-default-windows-browser)
              (leuven--mac-p
               'browse-url-default-macosx-browser)
              ((not (display-graphic-p)) ; Console.
               'eww-browse-url)
              (t                        ; Linux.
               'browse-url-generic)))

  ;; ;; TEMP For testing purpose
  ;; (setq browse-url-browser-function 'eww-browse-url)

  ;; Name of the browser program used by `browse-url-generic'.
  (setq browse-url-generic-program (executable-find "gnome-open"))
                                        ; Defer the decision to Gnome.  We could
                                        ; use "firefox" or "google-chrome" as
                                        ; well.

  ;; For WSL (Ubuntu on Windows).
  (setq browse-url-generic-program (executable-find "/mnt/c/Program Files/Internet Explorer/iexplore.exe"))
#+end_src

#+begin_src emacs-lisp :tangle no
  (setq browse-url-browser-function 'browse-url-generic)
  (setq browse-url-generic-program "cygstart")
#+end_src

** Finding Files and URLs at Point

#+begin_src emacs-lisp
  (leuven--section "FFAP")

  (unless (featurep 'helm-config)

    ;; Visit a file.
    (global-set-key (kbd "<f3>") #'find-file-at-point))

  ;; Find file (or URL) at point.
  (with-eval-after-load "ffap"

    ;; Function called to fetch an URL.
    (setq ffap-url-fetcher 'browse-url)); Could be `browse-url-emacs' or
                                        ; `eww-browse-url'.
#+end_src

** Google search

*************** TODO Use engine-mode
I use Google (on C-c / g) and Github (on C-c / h), but the engine-mode readme
explains how to set it up with DuckDuckGo, stack overflow, etc.  It's
configurable, but results can be displayed in eww, Emacs' built-in text-based
web browser.
*************** END

#+begin_src emacs-lisp
;;** Web search

  (leuven--section "Web search")
#+end_src

- ~C-c g SPC~ (~google-this-region~) ::
     Search selected text.

- ~C-c g RET~ (~google-this-search~) (could be bound to ~C-S-g~?) ::
     Search user's input.

- ~C-c g n~ ::
     ~google-this-noconfirm~

- ~C-c g t~ ::
     ~google-this~

#+begin_tip
The ~M-s M-w~ key binding (new in Emacs 25) uses ~eww~ to search the web for the
text in the region.  It is super handy for quick Google and documentation
searches and this will only make it more useful.

The search engine to use for this is specified by the customizable variable
~eww-search-prefix~.
#+end_tip

~url-parse~ and ~url-cookies~ are quite heavy to load, hence:

#+begin_src emacs-lisp
  ;; A set of functions and bindings to Google under point.
  (with-eval-after-load "google-this-autoloads"

    ;; Keybinding under which `google-this-mode-submap' is assigned.
    (setq google-this-keybind (kbd "C-c g"))

    (idle-require 'google-this))

  (with-eval-after-load "google-this"

    ;; Enable Google-This mode.
    (google-this-mode 1))
#+end_src

When I want to Google most of a line, I call ~google-this-line~ and edit the
prompt. And when I to Google the entire line, hitting ~RET~ one extra time doesn't
quite bother me.

If you'd like to skip confirmation, you can define the following function and
bind it to a key:

#+begin_src emacs-lisp :tangle no
    (defun google-this-line-noconfirm (prefix)
      "Google the current line without confirmationl.
    PREFIX determines quoting."
      (interactive "P")
      (google-this-line prefix 'noconfirm))
#+end_src

#+begin_src emacs-lisp
  (defun leuven-google-search-active-region-or-word-at-point ()
    "Create a Google search URL and send it to your web browser.
  If `transient-mark-mode' is non-nil and the mark is active, it defaults to the
  current region, else to the word at or before point."
    (interactive)
    (let ((query
           (if (use-region-p)
               (buffer-substring-no-properties (region-beginning) (region-end))
             (find-tag-default))))      ; or (current-word) for word at point?
      (browse-url
       (concat
        "http://www.google.com/search?q="
        (url-hexify-string query)))))

  (defun leuven-duckduckgo-search-active-region-or-word-at-point ()
    "Create a DuckDuckGo search URL and send it to your web browser.
  If `transient-mark-mode' is non-nil and the mark is active, it defaults to the
  current region, else to the word at or before point."
    (interactive)
    (let ((query
           (if (use-region-p)
               (buffer-substring-no-properties (region-beginning) (region-end))
             (find-tag-default))))      ; or (current-word) for word at point?
      (browse-url
       (concat
        "https://duckduckgo.com/?q="
        (url-hexify-string query)))))

  (global-set-key (kbd "C-c g G") #'leuven-google-search-active-region-or-word-at-point)
  (global-set-key (kbd "C-c g D") #'leuven-duckduckgo-search-active-region-or-word-at-point)
#+end_src

** How do I?  (StackOverflow)

Instant coding answers via Emacs.

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "howdoi-autoloads"

    ;; XXX Key sequence starts with non-prefix key C-c h. Conflict with Helm!
    (global-set-key (kbd "C-c h n") #'howdoi-query)
    (global-set-key (kbd "C-c h d") #'howdoi-query-insert-code-snippet-at-point))
#+end_src

** Babel translator

#+begin_src emacs-lisp
;;** Babel

  (leuven--section "Babel")

  ;; Interface to web translation services such as Babelfish.
  (when (locate-library "babel")

    (autoload 'babel "babel"
      "Use a web translation service to translate the message MSG." t)
    (autoload 'babel-region "babel"
      "Use a web translation service to translate the current region." t)
    (autoload 'babel-as-string "babel"
      "Use a web translation service to translate MSG, returning a string." t)
    (autoload 'babel-buffer "babel"
      "Use a web translation service to translate the current buffer." t)

    (defun leuven-babel-translate ()
      "Translate using many online translators."
      (interactive)
      (require 'babel)
      (let (source)
        (switch-to-buffer "*leuven--translate*")
        (erase-buffer)
        (yank)
        (setq source (buffer-substring-no-properties (point-min) (point-max)))
        (erase-buffer)
        (insert "--- Source ---\n\n")
        (insert source)
        (insert "\n\n\n--- Translation FR -> EN done by FreeTranslation ---\n\n")
        (insert (babel-work source "fr" "en" 'babel-free-fetch 'babel-free-wash))
        (insert "\n\n\n--- Translation EN -> FR done by FreeTranslation ---\n\n")
        (insert (babel-work source "en" "fr" 'babel-free-fetch 'babel-free-wash)))))

)
#+end_src

Switch between different translation directions directly from minibuffer by
using ~C-n~ and ~C-p~ key bindings.

#+begin_src emacs-lisp
  ;; Emacs interface to Google Translate.
  (with-eval-after-load "google-translate-autoloads"

    ;; Translate a text using translation directions.
    (global-set-key (kbd "C-c t") #'google-translate-smooth-translate))

  ;; Just another UI to Google.
  (with-eval-after-load "google-translate-smooth-ui"

    ;; Translation directions.
    (setq google-translate-translation-directions-alist
          '(("fr" . "en") ("en" . "fr")
            ("fr" . "nl") ("nl" . "fr")
            ("fr" . "es") ("es" . "fr"))))
#+end_src

* Other Amusements

#+begin_src emacs-lisp
;;* 47 Other (info "(emacs)Amusements")

(leuven--chapter leuven-load-chapter-47-amusements "47 Other Amusements"

  ;; Define a default menu bar.
  (with-eval-after-load "menu-bar"

    ;; Get rid of the Games in the Tools menu.
    (define-key menu-bar-tools-menu [games] nil))

)                                       ; Chapter 47 ends here.
#+end_src

* Customization

Emacs 24 custom themes allow loading multiple themes simultaneously.  If you
don't want the previous theme to stay in effect, you will need to unload it
first.

Install Leuven Theme via the [[id:8c71fa50-b62e-49ae-bcbb-2ed1ee7a5d65][Emacs Lisp Packages]] (or use the one bundled in GNU
Emacs 24.4).

#+begin_src emacs-lisp
;;* 49 (info "(emacs)Customization")

(leuven--chapter leuven-load-chapter-49-customization "49 Customization"

  (ignore-errors
    ;; Load custom theme "Leuven" and enable it.
    (load-theme 'leuven t))
#+end_src

** Color

You can govern the sort order of colors now such as HSV or RGB distance from a
particular color...

#+begin_src emacs-lisp
  ;; Color sort order for `list-colors-display'.
  (setq list-colors-sort '(rgb-dist . "#FFFFFF"))
#+end_src

** Variables

#+begin_src emacs-lisp
;;** 49.3 (info "(emacs)Variables")

  (leuven--section "49.3 (emacs)Variables")

  ;; File local variables specifications are obeyed, without query --
  ;; RISKY!
  (setq enable-local-variables t)

  ;; Obey `eval' variables -- RISKY!
  (setq enable-local-eval t)

  ;; Record safe values for some local variables.
  (setq safe-local-variable-values
        '((TeX-master . t)
          (ac-sources . (ac-source-words-in-buffer ac-source-dictionary))
          (flycheck-emacs-lisp-initialize-packages . t)
          (flycheck-mode . nil)
          (flyspell-mode . -1)
          (flyspell-mode . 1)
          (ispell-local-dictionary . "american")
          (ispell-local-dictionary . "francais")
          (org-tags-column . -80)       ; org-issues.org
          (outline-minor-mode)
          (whitespace-style face tabs spaces trailing lines
                            space-before-tab::space newline indentation::space
                            empty space-after-tab::space space-mark tab-mark
                            newline-mark)))
#+end_src

Have a look at (info "(emacs)Directory Variables").

** Key Bindings

The keys ~C-c LETTER~ are [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Binding-Conventions.html
][reserved for user functions]].

You can get a list of all the disabled functions by typing:

#+begin_src emacs-lisp :tangle no
M-: (let (lst) (mapatoms (lambda (x) (if (get x 'disabled) (push x lst)))) lst) RET
#+end_src

#+begin_src emacs-lisp
;;** 49.4 Customizing (info "(emacs)Key Bindings")

  (leuven--section "49.4 Customizing (emacs)Key Bindings")
#+end_src

See as well Print keybindings (pkb).

#+begin_src emacs-lisp
  ;; Print the key bindings in a tabular form.
  (defun leuven-keytable (arg)
    "Print the key bindings in a tabular form."
    (interactive "sEnter a modifier string:")
    (with-output-to-temp-buffer "*Key table*"
      (let* ((i 0)
             (keys (list "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l"
                         "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x"
                         "y" "z" "<RET>" "<down>" "<up>" "<right>"
                         "<left>" "<home>" "<end>" "<f1>" "<f2>" "<f3>"
                         "<f4>" "<f5>" "<f6>" "<f7>" "<f8>" "<f9>"
                         "<f10>" "<f11>" "<f12>" "1" "2" "3" "4" "5" "6"
                         "7" "8" "9" "0" "`" "~" "!" "@" "#" "$" "%" "^"
                         "&" "*" "(" ")" "-" "_" "=" "+" "\\" "|" "{" "["
                         "]" "}" ";" "'" ":" "\"" "<" ">" "," "." "/" "?"
                         ))
             (n (length keys))
             (modifiers (list "" "S-" "C-" "M-" "M-C-"))
             (k))
        (or (string= arg "") (setq modifiers (list arg)))
        (setq k (length modifiers))
        (princ (format " %-10.10s |" "Key"))
        (let ((j 0))
          (while (< j k)
            (princ (format " %-28.28s |" (nth j modifiers)))
            (setq j (1+ j))))
        (princ "\n")
        (princ (format "_%-10.10s_|" "__________"))
        (let ((j 0))
          (while (< j k)
            (princ (format "_%-28.28s_|"
                           "_______________________________"))
            (setq j (1+ j))))
        (princ "\n")
        (while (< i n)
          (princ (format " %-10.10s |" (nth i keys)))
          (let ((j 0))
            (while (< j k)
              (let* ((binding
                      (key-binding (read-kbd-macro
                                    (concat (nth j modifiers)
                                            (nth i keys)))))
                     (binding-string "_"))
                (when binding
                  (if (eq binding 'self-insert-command)
                      (setq binding-string (concat "'" (nth i keys) "'"))
                    (setq binding-string (format "%s" binding))))
                (setq binding-string
                      (substring binding-string 0
                                 (min (length binding-string) 28)))
                (princ (format " %-28.28s |" binding-string))
                (setq j (1+ j)))))
          (princ "\n")
          (setq i (1+ i)))
        (princ (format "_%-10.10s_|" "__________"))
        (let ((j 0))
          (while (< j k)
            (princ (format "_%-28.28s_|"
                           "_______________________________"))
            (setq j (1+ j))))))
    (delete-window)
    (setq truncate-lines t))
#+end_src

#+begin_src emacs-lisp
  ;; Guide the following key bindings automatically and dynamically.
  (with-eval-after-load "which-key-autoloads"
    (idle-require 'which-key))

  (with-eval-after-load "which-key"

    (which-key-mode)

    ;; Apply suggested settings for side-window that opens on right if there is
    ;; space and the bottom otherwise.
    (which-key-setup-side-window-right-bottom)

    (setq which-key-idle-delay 0.4)

    (setq which-key-sort-order 'which-key-local-then-key-order)

    ;; Set the maximum length (in characters) for key descriptions (commands or
    ;; prefixes).
    (setq which-key-max-description-length 33))
#+end_src

** Syntax Table

The syntax table contains information that tells Emacs how to operate on text,
words, sentences etc.  It will make Emacs know enough about all the symbols in
a buffer.  Syntax table is used for example for:

- commands like ~forward-word~ (~M-f~) or ~backward-kill-word~ (~M-DEL~),
- spell-checking of words,
- expansion commands of abbrevs,
- etc.

Evaluate ~current-word~ and see whether characters such as ~-~ and ~_~ are
considered part of the word (depending on the current major mode).

#+begin_src emacs-lisp
;;** 49.5 The (info "(emacs)Syntax") Table

  (leuven--section "49.5 The (emacs)Syntax Table")

  ;; Define "-" as part of a word.
  ;; (add-hook 'emacs-lisp-mode-hook
  ;;           #'(lambda ()
  ;;             (modify-syntax-entry ?- "w")))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 49 ends here.
#+end_src

* Emacs Display

#+begin_src emacs-lisp
;;* Emacs Display

(leuven--chapter leuven-load-chapter-XX-emacs-display "XX Emacs Display"
#+end_src

** Faces

You can get text properties of any char by typing ~C-u C-x =~.

Under Windows, you can get the current *font* by typing ~(w32-select-font)~
followed by ~C-x C-e~.

You can find the current *font string* by typing
~M-x ielm RET (frame-parameters) RET~ -- see the line ~font~.

To check if some font is available in Emacs do following:

1. Switch to the ~*scratch*~ buffer.

2. Type

   ~(prin1-to-string (x-list-fonts "font-you-want-to-check or pattern"))~

3. Place the cursor after the last closing paren and hit ~C-j~.  List of the names
   of available fonts matching given pattern will appear in the current buffer
   (~*scratch*~).

4. For listing of all available fonts, use

   ~(prin1-to-string (x-list-fonts "*"))~

   or

   ~(dolist (i (x-list-fonts "*")) (princ i) (terpri))~

   for a better output.

Under Linux, use the ~xfontsel~ utility (or the command-line ~xlsfonts~) to try out
different fonts.  After choosing a font, click the select button in ~xfontsel~
window.  This will copy font name you choose to copy & paste buffer.

Now Emacs should start with that font.

#+begin_src emacs-lisp
;;** (info "(elisp)Faces")

  (leuven--section "Faces")
#+end_src

For reasons unknown to me, Emacs takes a long time to change fonts in an X
environment.

Rather than using ~(set-default-font ...)~ in =.emacs=, stick the font definition in
your =.Xresources= file (key 'Emacs*font') and then use ~xrdb -load~ to activate it.
You will find that startup time is greatly improved!

Edit your =~/.Xresources= file to have a line with "Emacs.font".  Then do a

~xrdb -merge ~/.Xresources~

or restart your X11 to validate the modification.  I let Emacs do this for me:

#+begin_src emacs-lisp
  (defun leuven--merge-x-resources ()
    (let ((file (file-name-nondirectory (buffer-file-name))))
      (when (or (string= file ".Xdefaults")
                (string= file ".Xresources"))
        (start-process "xrdb" nil "xrdb" "-merge" (buffer-file-name))
        (message (format "[Merged %s into X resource database]" file)))))

  (add-hook 'after-save-hook #'leuven--merge-x-resources)
#+end_src

#+begin_src emacs-lisp
  ;; allow any scalable font
  (setq scalable-fonts-allowed t)
#+end_src

*** UTF-8

Fonts that have a good UTF-8 coverage are:

- DejaVu Sans Mono
- FreeMono (FreeSans, FreeSerif)
- Monospace

None of them has all four variants, some have regular (medium) and bold or light
and regular, one regular and oblique.

*** Anti-aliasing

To see if anti-aliasing is active, use ~xmag~ (under Linux) or any of the other
magnifier applications.  The fonts should have gray edges.

*** Adjust the height of the default face

There are a few commands to adjust the font sizes:

- ~C-x C-+~ ::
     Increase the default face height by one step.

- ~C-x C--~ ::
     Decrease the default face height by one step.

- ~C-x C-0~ ::
     Resets to defaults.

Those bindings are global and repeatable, e.g. ~C-x C-+ C-+ C-+~.

Zoom in/out (increase/decrease the font size) with ~Ctrl~ key and scroll wheel on
the mouse:

#+begin_src emacs-lisp
  ;; (global-set-key (kbd "C-+")            #'text-scale-increase)
  ;; (global-set-key (kbd "C--")            #'text-scale-decrease)
  (global-set-key (kbd "<C-wheel-up>")   #'text-scale-increase)
  (global-set-key (kbd "<C-wheel-down>") #'text-scale-decrease)

  ;; For Linux.
  (global-set-key (kbd "<C-mouse-4>")    #'text-scale-increase)
  (global-set-key (kbd "<C-mouse-5>")    #'text-scale-decrease)
#+end_src

#+begin_src emacs-lisp
)
#+end_src

** Images
:PROPERTIES:
:ID:       9432da83-fa9d-4466-a4da-57f33d662bbd
:header-args: :tangle no
:END:

#+begin_src emacs-lisp
;;** 37.17 (info "(elisp)Images")
#+end_src

How do I get image support? See ~image-library-alist~, a list of image types vs.
external libraries needed to display them.

#+begin_src emacs-lisp
(describe-variable 'image-library-alist)
#+end_src

#+results:
#+begin_example
image-library-alist is a variable defined in `C source code'.
Its value is shown below.

  This variable is potentially risky when used as a file local variable.

Documentation:
Alist of image types vs. external libraries needed to display them.

Each element is a list (IMAGE-TYPE LIBRARY...), where the car is a symbol
representing a supported image type, and the rest are strings giving
alternate filenames for the corresponding external libraries.

Emacs tries to load the libraries in the order they appear on the
list; if none is loaded, the running session of Emacs won't
support the image type.  Types 'pbm and 'xbm don't need to be
listed; they are always supported.

Value: ((xpm "libxpm.dll" "xpm4.dll" "libXpm-nox4.dll")
 (png "libpng14-14.dll" "libpng14.dll")
 (jpeg "jpeg62.dll" "libjpeg.dll" "jpeg-62.dll" "jpeg.dll")
 (tiff "libtiff3.dll" "libtiff.dll")
 (gif "giflib4.dll" "libungif4.dll" "libungif.dll")
 (svg "librsvg-2-2.dll")
 (gdk-pixbuf "libgdk_pixbuf-2.0-0.dll")
 (glib "libglib-2.0-0.dll")
 (gobject "libgobject-2.0-0.dll"))

#+end_example

#+begin_note
You can download the corresponding dlls from ezwinports
<http://sourceforge.net/projects/ezwinports/files/> and put them into
emacs's `bin` directory.

There are some instructions in the "Image support" part on page
<https://ftp.gnu.org/gnu/emacs/windows/>.
#+end_note

If you use compiled Emacs binaries (available on the [[http://ftp.gnu.org/gnu/emacs/windows/][GNU Website]]), eventually,
copy those DLLs (=libpng16.dll=, for example) from an old Windows Emacs
installation to your Emacs =bin= directory, and restart Emacs for image support to
be enabled.

If you use Cygwin Emacs, install ~libpng~ via Cygwin as well.

You can do:

#+begin_src emacs-lisp :results silent
(image-type-available-p 'png)
#+end_src

to check if you have ~png~ image support in your Emacs.

~image-library-alist~ maps image type to a list of dlls which support it.

To check all image libraries at once:

#+begin_src emacs-lisp
(mapcar #'(lambda (elt)
            (list (car elt) (image-type-available-p (car elt))))
        dynamic-library-alist)
#+end_src

If missing image libraries bother you, read ~README.W32~ (or ~nt/INSTALL~).

For animated GIF (or multi-page TIFF):
- ~f~ steps through image frame frame, and
- ~RET~ animates.
No need for ImageMagick.

* Emacs Lisp

** Variables

*** Local Variables

#+begin_src emacs-lisp
  ;; Limit on number of Lisp variable bindings & unwind-protects.
  (setq max-specpdl-size 3000)          ; XEmacs 21.5.29
#+end_src

* Calc

~C-x *~ invokes the GNU Emacs Calculator.

** Introduction

*** Basic Commands

Start the Calc: ~C-x * c~.

*** "Quick Calculator" Mode

Run the Calculator in the minibuffer: ~M-x quick-calc~ (bound to ~C-x * q~ or
~C-x * Q~).

#+begin_note
If ~quick-calc~ is called with a prefix argument, insert the result of the
calculation into the current buffer.
#+end_note

** Embedded Mode

Try the Embedded mode of Calc: ~C-x * e~ (no need to mark the region).

Similar commands: in place of ~e~,

- ~w~ ::
     Start Embedded mode on the current "word".

- ~j~ ::
     Operate on *assignments*.

You need to type ~C-x * e~ again to exit the Embedded mode.

* IRC client for Emacs

See [[http://en.wikipedia.org/wiki/List_of_IRC_commands][List of Internet Relay Chat commands]]:
- ~/whois~
- ~/leave~

#+begin_src emacs-lisp :tangle no
;;* Emacs IRC client

;; Other IRC for Emacs: rcirc, circe, bitlbee, liece, riece, zenirc, erc
;; Circe is advised by Tassilo (contributor).

  (autoload 'circe "circe"
    "Connect to an IRC server." t)

  ;; Connect to the Freenode network
  (defun leuven-irc-connect ()
    "Connect to Freenode."
    (interactive)
    (circe "irc.freenode.net" "6667" "freenode"))

  ;; ... upon hitting `M-x leuven-start-irc'.
  (defun leuven-start-irc ()
    "Start IRC."
    (interactive)
    (switch-or-start 'leuven-irc-connect "irc.freenode.net:6667"))

  (with-eval-after-load "circe"

;;** 1 Basics

    ;; Default channels to join whenever connecting to Freenode.
    (setq circe-server-auto-join-channels
          '(("^freenode$"
             "#emacs"
             ;; "#gnus"
             ;; "#latex"
             "#org-mode"
             ;; "#stumpwm"
             ;; "#zsh"
             )))

;;** 2 Reference

;;*** 2.3 Configuration

    ;; Default nick.
    (setq circe-default-nick "johndoe")

    ;; Your "real name" on IRC.
    (setq circe-default-realname "John Doe")

    ;; Authentication info.
    (setq freenode-passwd "")
    (setq circe-nickserv-passwords
          `(("freenode" ,freenode-passwd)))

;;** 3 Fighting Information Overload

;;*** 3.1 Channels

    ;; When other people say things in buffers that are currently buried (no
    ;; window is showing them), the mode line will now show you the abbreviated
    ;; channel or nick name.  Use `C-c C-SPC' to switch to these buffers.

;;*** 3.3 Keywords

    ;; List of keywords to highlight.
    (setq lui-highlight-keywords
          '(
            ;; "[^<]vauban"
            "org" "beamer" "ledger" "tikz"))

    ;; Add IRC color support to LUI.
    (try-require 'lui-irc-colors)
    (with-eval-after-load "lui-irc-colors"
      (add-to-list 'lui-pre-output-hook 'lui-irc-colors))

;;** 4 Hacking and Tweaking

;;*** 4.2 Using fly spell mode

    (when (leuven--executable-ispell-program-name-p)
      (setq lui-flyspell-p t)
      (setq lui-flyspell-alist '(("." "american"))))

;;** Others

    (setq circe-highlight-nick-type 'occurrence)

    (try-require 'circe-highlight-all-nicks)
    (with-eval-after-load "circe-highlight-all-nicks"
      (enable-circe-highlight-all-nicks))

    ;; Format for messages to queries or channels.
    (setq circe-format-self-say "<{nick}> {body}")

    ;; Truncate the buffer (at the top) if it grows too much.
    (setq lui-max-buffer-size 30000)

    ;; Column at which Lui should break output.
    (setq lui-fill-column fill-column)

    )                                   ; with-eval-after-load "circe" ends here.
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package erc
  :commands (erc erc-tls)
  :bind (:map erc-mode-map
              ("C-c r" . reset-erc-track-mode))
  :preface
  (defun irc (&optional arg)
    (interactive "P")
    (if arg
        (pcase-dolist (`(,server . ,nick)
                       '(("irc.freenode.net"     . "johnw")
                         ("irc.gitter.im"        . "jwiegley")
                         ;; ("irc.oftc.net"         . "johnw")
                         ))
          (erc-tls :server server :port 6697 :nick (concat nick "_")
                   :password (lookup-password server nick 6697)))
      (let ((pass (lookup-password "irc.freenode.net" "johnw" 6697)))
        (when (> (length pass) 32)
          (error "Failed to read ZNC password"))
        (erc :server "127.0.0.1" :port 6697 :nick "johnw"
             :password (concat "johnw/gitter:" pass))
        (sleep-for 5)
        (erc :server "127.0.0.1" :port 6697 :nick "johnw"
             :password (concat "johnw/freenode:" pass)))))

  (defun reset-erc-track-mode ()
    (interactive)
    (setq erc-modified-channels-alist nil)
    (erc-modified-channels-update)
    (erc-modified-channels-display)
    (force-mode-line-update))

  (defun setup-irc-environment ()
    (set (make-local-variable 'scroll-conservatively) 100)
    (setq erc-timestamp-only-if-changed-flag nil
          erc-timestamp-format "%H:%M "
          erc-fill-prefix "          "
          erc-fill-column 78
          erc-insert-timestamp-function 'erc-insert-timestamp-left
          ivy-use-virtual-buffers nil))

  (defcustom erc-foolish-content '()
    "Regular expressions to identify foolish content.
    Usually what happens is that you add the bots to
    `erc-ignore-list' and the bot commands to this list."
    :group 'erc
    :type '(repeat regexp))

  (defun erc-foolish-content (msg)
    "Check whether MSG is foolish."
    (erc-list-match erc-foolish-content msg))

  :init
  (add-hook 'erc-mode-hook #'setup-irc-environment)
  (when alternate-emacs
    (add-hook 'emacs-startup-hook 'irc))

  (eval-after-load 'erc-identd
    '(defun erc-identd-start (&optional port)
       "Start an identd server listening to port 8113.
  Port 113 (auth) will need to be redirected to port 8113 on your
  machine -- using iptables, or a program like redir which can be
  run from inetd. The idea is to provide a simple identd server
  when you need one, without having to install one globally on
  your system."
       (interactive (list (read-string "Serve identd requests on port: " "8113")))
       (unless port (setq port erc-identd-port))
       (when (stringp port)
         (setq port (string-to-number port)))
       (when erc-identd-process
         (delete-process erc-identd-process))
       (setq erc-identd-process
	     (make-network-process :name "identd"
			           :buffer nil
			           :host 'local :service port
			           :server t :noquery t
			           :filter 'erc-identd-filter))
       (set-process-query-on-exit-flag erc-identd-process nil)))

  :config
  (erc-track-minor-mode 1)
  (erc-track-mode 1)

  (add-hook 'erc-insert-pre-hook
            #'(lambda (s)
                (when (erc-foolish-content s)
                  (setq erc-insert-this nil)))))

(use-package erc-alert
  :disabled t
  :after erc)

(use-package erc-highlight-nicknames
  :after erc)

(use-package erc-macros
  :after erc)

(use-package erc-patch
  :disabled t
  :after erc)

(use-package erc-question
  :disabled t
  :after erc)

(use-package erc-yank
  :load-path "lisp/erc-yank"
  :after erc
  :bind (:map erc-mode-map
              ("C-y" . erc-yank )))
#+end_src

* Emacs and Microsoft Windows/MS-DOS

Eventually have a look as well at ~input-decode-map~.

#+begin_src emacs-lisp
;;* App G Emacs and (info "(emacs)Microsoft Windows/MS-DOS")

(leuven--chapter leuven-load-chapter-AppG-ms-dos "Appendix G Emacs and MS-DOS"

  ;; Divide key (needed in GNU Emacs for Windows).
  (global-set-key (kbd "<kp-divide>") (kbd "/"))

)                                       ; Chapter G ends here.
#+end_src

* Profiler

#+begin_src emacs-lisp
;;* Profiler

  (with-eval-after-load "profiler"

    (setq profiler-report-cpu-line-format
      '((100 left)                      ; The 100 above is increased from the
                                        ; default of 50 to allow the deeply
                                        ; nested call tree to be seen.
        (24 right ((19 right)
                   (5 right))))))
#+end_src

* Reporting Bugs

To get a backtrace when a specific regexp is displayed in the echo area (through
calls to message), set the variable ~debug-on-message~.

#+begin_src emacs-lisp
;; Recovery from Problems

;;* Reporting Bugs

(leuven--chapter leuven-load-chapter-99-debugging "99 Debugging"

  ;; Get the backtrace when uncaught errors occur.
  (setq debug-on-error nil)             ; Was set to `t' at beginning of file.

  ;; Hit `C-g' while it's frozen to get an Emacs Lisp backtrace.
  (setq debug-on-quit nil)              ; Was set to `t' at beginning of file.

  (setq debug-on-entry 'user-error))

;; (use-package ert
;;   :bind ("C-c e t" . ert-run-tests-interactively))
#+end_src

#+begin_src emacs-lisp
(when (and (string-match "GNU Emacs" (version))
           leuven-verbose-loading)
  (ad-disable-advice 'message 'before 'leuven-when-was-that)
  (ad-update 'message))
#+end_src

#+begin_src emacs-lisp
(when leuven-verbose-loading
  (message "| Chapter | Time |")
  (message "|---------+------|")
  (mapcar #'(lambda (el)                  ; FIXME Use `mapc' or `dolist'.
              (message el))
          (nreverse leuven--load-times-list))
  (message "|---------+------|")
  (message "|         | =vsum(@-I..@-II) |"))
#+end_src

* Post Init

#+begin_src emacs-lisp
(let ((elapsed (float-time (time-subtract (current-time)
                                          leuven--start-time))))
  (message "[Loaded %s in %.2f s]" load-file-name elapsed))
(sit-for 0.3)

#+end_src

See https://github.com/emacs-dashboard/emacs-dashboard/issues/57 (very nice
dashboard):

#+begin_src emacs-lisp
;; ;; (use-package dashboard
;; ;;   :if (< (length command-line-args) 2)
;; ;;   :preface
;;   (defun my/dashboard-banner ()
;;     "Sets a dashboard banner including information on package initialization
;;      time and garbage collections."
;;     (setq dashboard-banner-logo-title
;;           (format "Emacs ready in %.2f seconds with %d garbage collections."
;;                   (float-time
;;                    (time-subtract after-init-time before-init-time)) gcs-done)))
;;   ;; :init
;;   (add-hook 'after-init-hook 'dashboard-refresh-buffer)
;;   (add-hook 'dashboard-mode-hook 'my/dashboard-banner)
;;   ;; :custom
;;   ;; (dashboard-startup-banner 'logo)
;;   ;; :config
;;   (dashboard-setup-startup-hook)
;; ;; )
#+end_src

#+begin_src emacs-lisp
(add-hook 'after-init-hook
          #'(lambda ()
              (message "[Emacs startup time: %s; GC done: %S]" (emacs-init-time) gcs-done)
              (sit-for 0.3))
  t)
#+end_src

* Leuven

If you are like me, you want to know if there are:

- changes to existing files
- newly added files
- deleted files

and specifically do not want to know about *untracked files*.

This should do it:

#+begin_src shell :tangle no
git status --untracked-files=no --porcelain
#+end_src

See https://github.com/mordocai/.emacs.d/blob/master/init.el for many Git
functions implemented in Emacs Lisp.

"Package can be upgraded"

#+begin_src emacs-lisp
  (defun leuven-update ()
    "Update Emacs-Leuven to its latest version."
    (interactive)
    (leuven-emacs-version)
    (message "[Updating Leuven...]")
    (cd leuven--directory)
    (let ((ret (shell-command-to-string "LC_ALL=C git pull --rebase")))
      (if (string-match "\\(up to date\\|up-to-date\\)" ret)
          (message "[Configuration already up-to-date]")
        (princ ret)
        (sit-for 3)
        (message "[Configuration updated. Restart Emacs to complete the process]"))))

  (defun leuven-show-latest-commits ()
    "List latest changes in Emacs-Leuven."
    (interactive)
    (leuven-emacs-version)
    (message "[Fetching last changes in Leuven...]")
    (cd leuven--directory)
    (let ((ret (shell-command-to-string "LC_ALL=C git fetch --verbose"))
          (bufname "*Leuven latest commits*"))
      (if (string-match "\\(up to date\\|up-to-date\\)" ret)
          (message "[Configuration already up-to-date]")
       (with-output-to-temp-buffer bufname
         (shell-command
          "LC_ALL=C git log --pretty=format:'%h %ad %s' --date=short HEAD..origin"
          bufname)
         (pop-to-buffer bufname)))))

  (defun leuven-emacs-version ()
    (interactive)
    (message "[Emacs-Leuven version %s]" leuven--emacs-version))
#+end_src

# See spacemacs/check-for-new-version.

Please address particular issues or suggestions *specifically*, using ~M-x
leuven-send-bug-report~.

#+begin_src emacs-lisp
(message "* --[ Loaded Emacs-Leuven %s]--" leuven--emacs-version)
#+end_src

** Feature

#+begin_src emacs-lisp
(provide 'emacs-leuven)
#+end_src

** File Local Variables

#+begin_src emacs-lisp
;; This is for the sake of Emacs.
;; Local Variables:
;; coding: utf-8-unix
;; eval: (when (require 'rainbow-mode nil t) (rainbow-mode))
;; flycheck-emacs-lisp-initialize-packages: t
;; flycheck-mode: nil
;; ispell-local-dictionary: "american"
;; End:

;;; emacs-leuven.el ends here
#+end_src

# emacs-leuven.txt ends here
