# Hey Emacs, this is a -*- org -*- file ...
#+TITLE:     Emacs-Leuven-AI
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:  emacs, dotfile, config
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:2
#+EXCLUDE_TAGS: noexport

#+PROPERTY:  header-args :eval never :padline yes :tangle yes

#+SETUPFILE: ~/org/theme-readtheorg.setup

* Tasks

** NEXT Commentaires à envoyer à l'auteur de GPTel

- Envoi vers buffer ChatGPT ne marche pas
- Pas de trace dans l'echo area que quelque chose a été envoyé (important),
  voire reçu (nice-to-have)
- Je ne comprends pas comment utiliser le rewrite
  + D'ailleurs, il faudrait que ce soit comme org-ai-rewrite, avec un diff
  + et possibilité d'accepter/refuser des hunks, un par un, avant d'accepter le
    tout
- Je ne comprends pas comment changer le prompt à la main et s'en servir de
  suite
- À indiquer :
  + Gestion des placeholders
  + Write commit message

** TODO Research ChatGPT integration with Emacs

- [ ] Test c3po integration (recommended)
- [ ] Evaluate org-ai package
- [ ] Review CodeGPT capabilities
- [ ] Explore [[GitHub:ai-boost/awesome-prompts][Awesome Prompts Collection]]

References:
- [[YouTube:H8jvhz0CGzU][Boost your Emacs productivity with ChatGPT and Copilot]]
- https://www.armindarvish.com/post/use_emacs_as_a_chatgpt_client/

* Intro

#+begin_src emacs-lisp
;;; emacs-leuven-ai.el --- GPTel & org-ai Integration  -*- lexical-binding: t -*-

;; Author: Fabrice Niessen
;; Keywords: tools, ai, convenience
;; URL: https://...
;; Version: 0.1

;;; Commentary:

;; Provides helpers for GPTel and org-ai.

;;; Code:

;; Require a feature/library if available; if not, fail silently.
(defun eboost-try-require (feature)
  "Try to (require FEATURE) silently.
Return t on success, nil on failure. If `init-file-debug' is non-nil,
emit a warning when the feature can't be loaded."
  (if (require feature nil 'noerror)
      t
    (when init-file-debug
      (display-warning 'eboost
                       (format "Cannot load `%s'" feature)
                       :warning))
    nil))
#+end_src

#+begin_src emacs-lisp
(defun eboost-define-key-if-free (keymap key command &optional scope)
  "Bind KEY to COMMAND in KEYMAP only if KEY is unbound.
KEYMAP may be the map itself or a symbol naming it.
If already bound, emit a warning mentioning SCOPE (string)."
  (let* ((map (if (keymapp keymap)
                  keymap
                (and (symbolp keymap) (boundp keymap) (symbol-value keymap))))
         (existing-binding (and map (lookup-key map key))))
    (cond
     ((not map)
      (display-warning 'eboost "Keymap not available (yet)" :warning))
     ((or (null existing-binding) (numberp existing-binding))
      (define-key map key command))
     (t
      (when init-file-debug
        (display-warning 'eboost
                         (format "Keybinding %s is already in use%s!"
                                 (key-description key)
                                 (if scope (format " in %s" scope) ""))
                         :warning))))))
#+end_src

* Integrating AI tools into Emacs

#+begin_src emacs-lisp
;; Set OpenAI API key.
(defvar eboost-openai-api-key
  (let* ((api-key (or (getenv "OPENAI_API_KEY")
                      (let ((f (expand-file-name "~/.openai_api_key")))
                        (when (file-exists-p f)
                          (with-temp-buffer
                            (insert-file-contents f)
                            (buffer-string))))))
         (trimmed-api-key (and (stringp api-key) (string-trim api-key))))
    (cond
     ((and (stringp trimmed-api-key) (not (string-empty-p trimmed-api-key)))
      (message "[OpenAI API key loaded]")
      trimmed-api-key)
     (t
      (when init-file-debug
        (display-warning 'eboost "No valid OpenAI API key found!" :warning))
      nil)))
  "OpenAI API key from env or file; nil if unavailable.")
#+end_src

** GPTel

Usage:
- ~M-x gptel-send~ (or ~C-c RET~) :: Send the buffer up to point (or active region)
  as prompt to the AI and insert the result below.
- ~C-u M-x gptel-send~ (or ~C-u C-c RET~) :: Set LLM and input/output options (such
  as "system message") before sending prompt.
- ~M-x gptel~ :: Open a dedicated chat buffer.
- ~C-u M-x gptel~ :: Open a second dedicated chat buffer.
- gptel-mode to restore the rigth mode for a saved chat.
- gptel-abort :: Cancel query in progress.
- gptel-menu :: Direct access to menu.
- gptel-set-topic :: Limit context by Org header.
- ~gptel-add-file~
- ~gptel-add~ → Add to context DWIM
- ~gptel-make-preset~
- ~gptel-make-tool~
- ~gptel-org-set-properties~
- ~gptel-org-set-topic~
- ~gptel-rewrite~
- ~gptel-rewrite~

Inside a gptel buffer:

- ~C-u C-x RET~ or ~gptel-menu~ → Menu

*** Basic configuration

#+begin_src emacs-lisp
;; Load gptel.
(when (eboost-try-require 'gptel)
#+end_src

*** Core GPTel settings

#+begin_src emacs-lisp
  ;; Set OpenAI API key.
  (when (bound-and-true-p eboost-openai-api-key)
    (setq gptel-api-key eboost-openai-api-key))

  ;; Controls randomness (lower = more deterministic).
  (setq gptel-temperature 0.7)

  ;; Limit response length.
  (setq gptel-max-tokens 1000)

  ;; Set default mode for response buffer.
  (setq gptel-default-mode 'org-mode)

  ;; Enable GPTel's expert/power-user commands.
  (setq gptel-expert-commands t)
#+end_src

*** Display formatting configuration

#+begin_src emacs-lisp
  (defgroup eboost-gptel nil
    "Eboost tweaks and integration for GPTel."
    :group 'applications
    :prefix "eboost-gptel-")

  (defcustom eboost-gptel-prompt-prefix "** --- User prompt ---\n\n"
    "Prompt prefix inserted before user text in GPTel Org buffers."
    :type 'string
    :group 'eboost-gptel)

  (defcustom eboost-gptel-response-prefix "** --- AI response ---\n\n"
    "Response prefix inserted before AI output in GPTel Org buffers."
    :type 'string
    :group 'eboost-gptel)

  ;; Update or create the org-mode entries (no duplicates).
  (let ((cell (assq 'org-mode gptel-prompt-prefix-alist)))
    (if cell
        (setcdr cell eboost-gptel-prompt-prefix)
      (push (cons 'org-mode eboost-gptel-prompt-prefix)
            gptel-prompt-prefix-alist)))

  (let ((cell (assq 'org-mode gptel-response-prefix-alist)))
    (if cell
        (setcdr cell eboost-gptel-response-prefix)
      (push (cons 'org-mode eboost-gptel-response-prefix)
            gptel-response-prefix-alist)))
#+end_src

*** Hooks / post-response handlers

#+begin_src emacs-lisp
  ;; Add auto-scrolling after GPTel stream ends.
  (when (fboundp 'gptel-auto-scroll)
    (add-hook 'gptel-post-stream-hook #'gptel-auto-scroll))

  ;; Automatically move cursor to end of response.
  (when (fboundp 'gptel-end-of-response)
    (add-hook 'gptel-post-response-functions #'gptel-end-of-response))
#+end_src

*** Directives

*************** TODO Add directives with a key like in demo
https://www.youtube.com/watch?v=yAL0cw1ePqw at 05:35
(Also in demo of Karthink, see https://www.youtube.com/watch?v=bsRnh_brggM)
*************** END

#+begin_src emacs-lisp
(require 'subr-x)  ;; string-trim, string-empty-p, etc.

(defcustom eboost-gptel-directives-directory
  (expand-file-name "~/ai-prompts/")
  "Répertoire racine contenant des fichiers .txt pour les directives GPTel (recurse)."
  :type 'directory
  :group 'eboost-gptel)

(defun eboost--gptel-read-directive-file (name directive-file)
  "Read DIRECTIVE-FILE and set NAME entry in `gptel-directives` as a proper alist cell.
Return the directive content, or nil on failure."
  (when (file-readable-p directive-file)
    (with-temp-buffer
      (insert-file-contents directive-file)
      (let ((content (string-trim (buffer-string))))
        ;; Create or update (NAME . CONTENT)
        (setf (alist-get name gptel-directives nil nil #'eq) content)
        content))))

(defun eboost--gptel-read-directives-from-directory (dir)
  "Populate `gptel-directives` from all .txt files under DIR (recursively).
Existing entries with the same NAME are overwritten."
  ;; (setq gptel-directives nil)
  (dolist (f (directory-files-recursively (expand-file-name dir) "\\.txt\\'"))
    (condition-case err
        (let ((name (intern (file-name-base f))))
          (eboost--gptel-read-directive-file name f))
      (error
       (display-warning 'eboost
                        (format "Failed to read directive %s: %s"
                                f (error-message-string err))
                        :warning))))
  gptel-directives)

;; Automatic loading if the folder exists.
(when (file-directory-p eboost-gptel-directives-directory)
  (ignore-errors
    (eboost--gptel-read-directives-from-directory eboost-gptel-directives-directory)))
#+end_src

;; Use the system prompt builder function
(let ((build-directives-fun "~/projects/ai/AIPIHKAL/gptel-build-directives.el"))
  (when (f-exists-p build-directives-fun)
    (load build-directives-fun)
    ;; (custom-set-variables '(gptel-directives
    (setq gptel-directives (gjg/gptel-build-directives "~/projects/ai/AIPIHKAL/system-prompts/")
          gptel-system-message (alist-get 'default gptel-directives))))

*** Presets configuration

How to use them: =C-u M-x gptel-send=.

- Optimized for coding tasks, such as writing, refactoring, or explaining code.
- Designed for proofreading and improving text, such as fixing spelling,
  grammar, or style.
- A versatile preset for general conversations or ad-hoc queries with an LLM.
- Tailored for per-project workflows, such as analyzing code or documentation in
  a specific project directory.

#+begin_src emacs-lisp
  ;; (gptel-make-preset 'gpt4coding2
  ;;   :backend "openai"
  ;;   :model "gpt-4o-mini"
  ;;   :temperature 0.7)

  ;; Coding preset.
  (gptel-make-preset 'gpt4coding
    :description "A preset optimized for coding tasks"
    :backend "ChatGPT"
    :model 'gpt-4.1-mini
    :system
    "You are an expert coding assistant. Your role is to provide
   high-quality code solutions, refactorings, and explanations."
    :tools '("read_buffer" "modify_buffer")
    :temperature 0.7)

  ;; Proofreading Preset.
  (gptel-make-preset 'proofreading
    :description "Preset for proofreading tasks"
    :backend "Claude"
    :model 'claude-sonnet-4-20250514
    :system
    "You are a professional proofreader. Your task is to correct spelling,
   grammar, and improve clarity and style."
    :tools '("read_buffer" "spell_check" "grammar_check")
    :temperature 0.7)

  ;; General-purpose chat preset.
  (gptel-make-preset 'general-chat
    :description "A preset for general-purpose LLM interactions"
    :backend "ChatGPT"
    :model 'o4-mini
    :system
    "You are a helpful assistant providing clear and concise answers to a
   wide range of questions."
    :temperature 0.9)

  ;; Project-specific preset (within '.dir-locals.el').
  (gptel-make-preset 'project-agent
    :description "Preset for project-specific AI tasks"
    :backend "Claude"
    :model 'claude-sonnet-4-20250514
    :system
    "You are an AI assistant for a software project. Provide insights
   based on the project's code and documentation."
    :tools '("read_buffer" "lsp_context"))
#+end_src

*** Custom functions

**** Intégration Org-mode

#+begin_src emacs-lisp
;;;###autoload
  (defun eboost-gptel-org-send-to-chatgpt ()
    "Send selected region or Org subtree to the *ChatGPT* buffer.
    If a region is selected, send its text; otherwise, send the content of the Org subtree.
    Displays the response in the *ChatGPT* buffer."
    (interactive)

    ;; Validate context.
    (unless (derived-mode-p 'org-mode)
      (user-error "This command works in Org buffers only"))
    (unless (or (use-region-p) (org-at-heading-p))
      (user-error "Place point on an Org heading or select a region"))

    ;; Extract text.
    (let ((text (if (use-region-p)
                    (buffer-substring-no-properties (region-beginning) (region-end))
                  (save-excursion
                    (org-back-to-heading t)
                    (let ((beg (point)))
                      (org-end-of-subtree t)
                      (buffer-substring-no-properties beg (point)))))))

      ;; Prepare output buffer.
      (let ((buffer (get-buffer-create "*ChatGPT*")))
        (with-current-buffer buffer
          (goto-char (point-max))
          (insert (format-time-string
                   "\n\n* -------------------- GPT Session [%Y-%m-%d %H:%M] --------------------")
                  "\n\n" eboost-gptel-prompt-prefix
                  text
                  "\n\n" eboost-gptel-response-prefix)
          (goto-char (point-max)))

        ;; Send to GPTel with error handling.
        (condition-case err
            (gptel-request text :buffer buffer)
          (error (message "[GPTel error: %s]"
                          (error-message-string err))))

        ;; Display the buffer and provide user feedback.
        (pop-to-buffer buffer)
        (message "[GPTel: Prompt sent...]"))))

  ;; Org mode keybinding (only if free).
  (with-eval-after-load 'org
    (eboost-define-key-if-free 'org-mode-map
                               (kbd "C-c q")
                               #'eboost-gptel-org-send-to-chatgpt
                               "Org mode"))
#+end_src

**** Commit message generator

#+begin_src emacs-lisp
;;;###autoload
  (defun eboost-gptel-write-commit-message ()
    "Generate a Git commit message from the current diff region or buffer.
The result is shown in *Commit Message* and copied to the kill ring."
    (interactive)
    (unless (or (use-region-p) (> (buffer-size) 0))
      (user-error "No content to analyze"))

    (let* ((diff-text (if (use-region-p)
                          (buffer-substring-no-properties (region-beginning) (region-end))
                        (buffer-substring-no-properties (point-min) (point-max))))
           (prompt (concat "Write a Git commit message for the following diff:\n\n"
                           diff-text)))
      ;; Notify user that the process has started.
      (message "[Generating commit message...]")
      ;; Create and clear the buffer initially.
      (with-current-buffer (get-buffer-create "*Commit Message*")
        (erase-buffer))
      ;; Send request without menu.
      (gptel-request prompt
        :callback (lambda (response info)
                    (if (stringp response)
                        (let ((output-buffer (get-buffer-create "*Commit Message*")))
                                        ; Create a new reference to the buffer
                                        ; to avoid closure dependency.
                          (with-current-buffer output-buffer
                            (erase-buffer)
                            (let ((msg (string-trim response)))
                              ;; Remove leading and trailing backtick wrappers
                              ;; from the response, if any.
                              (setq msg (replace-regexp-in-string "^```\n" "" msg))
                              (setq msg (replace-regexp-in-string "```$" "" msg))
                              ;; Replace backticks with single quotes.
                              (setq msg (replace-regexp-in-string "`" "'" msg))
                              (kill-new msg) ; Add to kill ring.
                              (insert msg)
                              (message "[Commit message copied to kill ring.]"))
                          (display-buffer output-buffer)))
                      (message "[Failed to generate commit message: %s.]"
                               (plist-get info :status)))))))

  ;; Diff mode keybinding (only if free).
  (with-eval-after-load 'diff-mode
    (eboost-define-key-if-free 'diff-mode-map
                               (kbd "w")
                               #'eboost-gptel-write-commit-message
                               "diff-mode"))

  ;; Global keybinding (only if free).
  (eboost-define-key-if-free global-map
                             (kbd "C-x v w")
                             #'eboost-gptel-write-commit-message
                             "global map")
#+end_src

*** Keybindings

#+begin_src emacs-lisp
  ;; Unbind `C-c RET' in Org mode.
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-c RET") nil))

  ;; Quick access to gptel-send (only if key is free).
  (with-eval-after-load 'gptel
    (eboost-define-key-if-free global-map
                               (kbd "C-c RET")
                               #'gptel-send
                               "global map"))
#+end_src

#+begin_src emacs-lisp
)
#+end_src

** Org-ai

#+begin_src emacs-lisp
;; Load org-ai.
(when (eboost-try-require 'org-ai)

  ;; Enable org-ai-mode in Org mode.
  (add-hook 'org-mode-hook #'org-ai-mode)

  ;; Set OpenAI API key.
  (when (bound-and-true-p eboost-openai-api-key)
    (setq org-ai-openai-api-token eboost-openai-api-key))

  ;; Install YASnippet templates for org-ai.
  (when (eboost-try-require 'yasnippet)
    (org-ai-install-yasnippets)))
#+end_src

The package whisper.el is needed for transcribing speech.

* Leuven

#+begin_src emacs-lisp
(message "* --[ Loaded Emacs-Leuven AI %s ]--"
         (if (boundp 'lvn--emacs-version) lvn--emacs-version ""))
#+end_src

** Feature

#+begin_src emacs-lisp
(provide 'emacs-leuven-ai)

;;; emacs-leuven-ai.el ends here
#+end_src

# emacs-leuven-ai.txt ends here
